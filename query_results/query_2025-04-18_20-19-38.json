{
  "metadata": {
    "timestamp": "2025-04-18_20-19-38",
    "query_id": "query_2025-04-18_20-19-38",
    "original_query": "Display the system\u2019s memory usage.",
    "optimized_query": "How can I display the current memory usage of the system, including total, used, available, and cached memory in a human-readable format on a Unix-like operating system?",
    "query_intent": "To check and display the current memory usage statistics of the system.",
    "keywords": [
      "memory usage",
      "system",
      "display",
      "RAM",
      "available memory",
      "used memory"
    ],
    "optimization_metrics": {
      "precision": 1.0,
      "recall": 0,
      "f1_score": 0,
      "retrieval_time": 0.46231770515441895,
      "command_count": 5,
      "diverse_categories": 1,
      "query_specificity": 0.55,
      "overall_score": 0.6635507814089457
    }
  },
  "retrieved_commands": [
    {
      "command": "systemd-analyze",
      "description": "systemd-analyze\nmay be used to determine system boot-up\n       performance statistics and retrieve other state and tracing\n       information from the system and service manager, and to verify the\n       correctness of unit files. it is also used to access special\n       functions useful for advanced system manager debugging.\n\n       if no command is passed,\nsystemd-analyze time\nis implied.\nsystemd-analyze time\nthis command prints the time spent in the kernel before userspace\n       has been reached, the time spent in the initrd before normal\n       system userspace has been reached, and the time normal system\n       userspace took to initialize. note that these measurements simply\n       measure the time passed up to the point where all system services\n       have been spawned, but not necessarily until they fully finished\n       initialization or the disk is idle.\nexample 1. show how long the boot took\n# in a container\n           $ systemd-analyze time\n           startup finished in 296ms (userspace)\n           multi-user.target reached after 275ms in userspace\n\n           # on a real machine\n           $ systemd-analyze time\n           startup finished in 2.584s (kernel) + 19.176s (initrd) + 47.847s (userspace) = 1min 9.608s\n           multi-user.target reached after 47.820s in userspace\nsystemd-analyze blame\nthis command prints a list of all running units, ordered by the\n       time they took to initialize. this information may be used to\n       optimize boot-up times. note that the output might be misleading\n       as the initialization of one service might be slow simply because\n       it waits for the initialization of another service to complete.\n       also note:\nsystemd-analyze blame\ndoes not display results for\n       services with\ntype=simple\n, because systemd considers such services\n       to be started immediately, hence no measurement of the\n       initialization delays can be done. also note that this command\n       only shows the time units took for starting up, it does not show\n       how long unit jobs spent in the execution queue. in particular it\n       shows the time units spent in \"activating\" state, which is not\n       defined for units such as device units that transition directly\n       from \"inactive\" to \"active\". this command hence gives an\n       impression of the performance of program code, but cannot\n       accurately reflect latency introduced by waiting for hardware and\n       similar events.\nexample 2. show which units took the most time during boot\n$ systemd-analyze blame\n                    32.875s pmlogger.service\n                    20.905s systemd-networkd-wait-online.service\n                    13.299s dev-vda1.device\n                    ...\n                       23ms sysroot.mount\n                       11ms initrd-udevadm-cleanup-db.service\n                        3ms sys-kernel-config.mount\nsystemd-analyze critical-chain [\nunit\n...]\n       this command prints a tree of the time-critical chain of units\n       (for each of the specified\nunit\ns or for the default target\n       otherwise). the time after the unit is active or started is\n       printed after the \"@\" character. the time the unit takes to start\n       is printed after the \"+\" character. note that the output might be\n       misleading as the initialization of services might depend on\n       socket activation and because of the parallel execution of units.\n       also, similarly to the\nblame\ncommand, this only takes into account\n       the time units spent in \"activating\" state, and hence does not\n       cover units that never went through an \"activating\" state (such as\n       device units that transition directly from \"inactive\" to\n       \"active\"). moreover, it does not show information on jobs (and in\n       particular not jobs that timed out).\nexample 3. systemd-analyze critical-chain\n$ systemd-analyze critical-chain\n           multi-user.target @47.820s\n           \u00e2\u0094\u0094\u00e2\u0094\u0080pmie.service @35.968s +548ms\n             \u00e2\u0094\u0094\u00e2\u0094\u0080pmcd.service @33.715s +2.247s\n               \u00e2\u0094\u0094\u00e2\u0094\u0080network-online.target @33.712s\n                 \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd-wait-online.service @12.804s +20.905s\n                   \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd.service @11.109s +1.690s\n                     \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-udevd.service @9.201s +1.904s\n                       \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-tmpfiles-setup-dev.service @7.306s +1.776s\n                         \u00e2\u0094\u0094\u00e2\u0094\u0080kmod-static-nodes.service @6.976s +177ms\n                           \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-journald.socket\n                             \u00e2\u0094\u0094\u00e2\u0094\u0080system.slice\n                               \u00e2\u0094\u0094\u00e2\u0094\u0080-.slice\nsystemd-analyze dump [\npattern\n...]\n       without any parameter, this command outputs a (usually very long)\n       human-readable serialization of the complete service manager\n       state. optional glob pattern may be specified, causing the output\n       to be limited to units whose names match one of the patterns. the\n       output format is subject to change without notice and should not\n       be parsed by applications. this command is rate limited for\n       unprivileged users.\nexample 4. show the internal state of user manager\n$ systemd-analyze --user dump\n           timestamp userspace: thu 2019-03-14 23:28:07 cet\n           timestamp finish: thu 2019-03-14 23:28:07 cet\n           timestamp generators-start: thu 2019-03-14 23:28:07 cet\n           timestamp generators-finish: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-start: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-finish: thu 2019-03-14 23:28:07 cet\n           -> unit proc-timer_list.mount:\n                   description: /proc/timer_list\n                   ...\n           -> unit default.target:\n                   description: main user target\n           ...\nsystemd-analyze malloc [\nd-bus service\n...]\n       this command can be used to request the output of the internal\n       memory state (as returned by\nmalloc_info(3)\n) of a d-bus service.\n       if no service is specified, the query will be sent to\n       org.freedesktop.systemd1 (the system or user service manager). the\n       output format is not guaranteed to be stable and should not be\n       parsed by applications.\n\n       the service must implement the org.freedesktop.memoryallocation1\n       interface. in the systemd suite, it is currently only implemented\n       by the manager.\nsystemd-analyze plot\nthis command prints either an svg graphic, detailing which system\n       services have been started at what time, highlighting the time\n       they spent on initialization, or the raw time data in json or\n       table format.\nexample 5. plot a bootchart\n$ systemd-analyze plot >bootup.svg\n           $ eog bootup.svg&\n\n       note that this plot is based on the most recent per-unit timing\n       data of loaded units. this means that if a unit gets started, then\n       stopped and then started again the information shown will cover\n       the most recent start cycle, not the first one. thus it is\n       recommended to consult this information only shortly after boot,\n       so that this distinction does not matter. moreover, units that are\n       not referenced by any other unit through a dependency might be\n       unloaded by the service manager once they terminate (and did not\n       fail). such units will not show up in the plot.\nsystemd-analyze dot [\npattern\n...]\n       this command generates textual dependency graph description in dot\n       format for further processing with the graphviz\ndot\n(1) tool. use a\n       command line like\nsystemd-analyze dot | dot -tsvg >systemd.svg\nto\n       generate a graphical dependency tree. unless\n--order\nor\n--require\nis passed, the generated graph will show both ordering and\n       requirement dependencies. optional pattern globbing style\n       specifications (e.g.  *.target) may be given at the end. a unit\n       dependency is included in the graph if any of these patterns match\n       either the origin or destination node.\nexample 6. plot all dependencies of any unit whose name starts\nwith \"avahi-daemon\"\n$ systemd-analyze dot 'avahi-daemon.*' | dot -tsvg >avahi.svg\n           $ eog avahi.svg\nexample 7. plot the dependencies between all known target units\n$ systemd-analyze dot --to-pattern='*.target' --from-pattern='*.target' \\\n                 | dot -tsvg >targets.svg\n           $ eog targets.svg\nsystemd-analyze unit-paths\nthis command outputs a list of all directories from which unit\n       files, .d overrides, and .wants, .requires symlinks may be loaded.\n       combine with\n--user\nto retrieve the list for the user manager\n       instance, and\n--global\nfor the global configuration of user\n       manager instances.\nexample 8. show all paths for generated units\n$ systemd-analyze unit-paths | grep '^/run'\n           /run/systemd/system.control\n           /run/systemd/transient\n           /run/systemd/generator.early\n           /run/systemd/system\n           /run/systemd/system.attached\n           /run/systemd/generator\n           /run/systemd/generator.late\n\n       note that this verb prints the list that is compiled into\nsystemd-analyze\nitself, and does not communicate with the running\n       manager. use\n\n           systemctl [--user] [--global] show -p unitpath --value\n\n       to retrieve the actual list that the manager uses, with any empty\n       directories omitted.\nsystemd-analyze exit-status [\nstatus\n...]\n       this command prints a list of exit statuses along with their\n       \"class\", i.e. the source of the definition (one of \"glibc\",\n       \"systemd\", \"lsb\", or \"bsd\"), see the process exit codes section in\nsystemd.exec(5)\n. if no additional arguments are specified, all\n       known statuses are shown. otherwise, only the definitions for the\n       specified codes are shown.\nexample 9. show some example exit status names\n$ systemd-analyze exit-status 0 1 {63..65}\n           name    status class\n           success 0      glibc\n           failure 1      glibc\n           -       63     -\n           usage   64     bsd\n           dataerr 65     bsd\nsystemd-analyze capability [\ncapability\n... | {-m | --mask}\nmask\n]\n       this command prints a list of linux capabilities along with their\n       numeric ids. see\ncapabilities(7)\nfor details. if no argument is\n       specified the full list of capabilities known to the service\n       manager and the kernel is shown. capabilities defined by the\n       kernel but not known to the service manager are shown as\n       \"cap_???\". optionally, if arguments are specified they may refer\n       to specific cabilities by name or numeric id, in which case only\n       the indicated capabilities are shown in the table.\n\n       alternatively, if\n--mask\nis passed, a single numeric argument must\n       be specified, which is interpreted as a hexadecimal capability\n       mask. in this case, only the capabilities present in the mask are\n       shown in the table. this mode is intended to aid in decoding\n       capability sets available via various debugging interfaces (e.g.\n       \"/proc/pid/status\").\nexample 10. show some example capability names\n$ systemd-analyze capability 0 1 {30..32}\n           name              number\n           cap_chown              0\n           cap_dac_override       1\n           cap_audit_control     30\n           cap_setfcap           31\n           cap_mac_override      32\nexample 11. decode a capability mask extracted from /proc\n$ systemd-analyze capability -m 0000000000003c00\n           name                 number\n           cap_net_bind_service     10\n           cap_net_broadcast        11\n           cap_net_admin            12\n           cap_net_raw              13\nsystemd-analyze condition\ncondition\n...\n       this command will evaluate\ncondition*=...\nand\nassert*=...\nassignments, and print their values, and the resulting value of\n       the combined condition set. see\nsystemd.unit(5)\nfor a list of\n       available conditions and asserts.\nexample 12. evaluate conditions that check kernel versions\n$ systemd-analyze condition 'conditionkernelversion = ! <4.0' \\\n                   'conditionkernelversion = >=5.1' \\\n                   'conditionacpower=|false' \\\n                   'conditionarchitecture=|!arm' \\\n                   'assertpathexists=/etc/os-release'\n           test.service: assertpathexists=/etc/os-release succeeded.\n           asserts succeeded.\n           test.service: conditionarchitecture=|!arm succeeded.\n           test.service: conditionacpower=|false failed.\n           test.service: conditionkernelversion=>=5.1 succeeded.\n           test.service: conditionkernelversion=!<4.0 succeeded.\n           conditions succeeded.\nsystemd-analyze syscall-filter [\nset\n...]\n       this command will list system calls contained in the specified\n       system call set\nset\n, or all known sets if no sets are specified.\n       argument\nset\nmust include the \"@\" prefix.\nsystemd-analyze filesystems [\nset\n...]\n       this command will list filesystems in the specified filesystem set\nset\n, or all known sets if no sets are specified. argument\nset\nmust\n       include the \"@\" prefix.\nsystemd-analyze calendar\nexpression\n...\n       this command will parse and normalize repetitive calendar time\n       events, and will calculate when they elapse next. this takes the\n       same input as the\noncalendar=\nsetting in\nsystemd.timer(5)\n,\n       following the syntax described in\nsystemd.time(7)\n. by default,\n       only the next time the calendar expression will elapse is shown;\n       use\n--iterations=\nto show the specified number of next times the\n       expression elapses. each time the expression elapses forms a\n       timestamp, see the\ntimestamp\nverb below.\nexample 13. show leap days in the near future\n$ systemd-analyze calendar --iterations=5 '*-2-29 0:0:0'\n             original form: *-2-29 0:0:0\n           normalized form: *-02-29 00:00:00\n               next elapse: sat 2020-02-29 00:00:00 utc\n                  from now: 11 months 15 days left\n                  iter. #2: thu 2024-02-29 00:00:00 utc\n                  from now: 4 years 11 months left\n                  iter. #3: tue 2028-02-29 00:00:00 utc\n                  from now: 8 years 11 months left\n                  iter. #4: sun 2032-02-29 00:00:00 utc\n                  from now: 12 years 11 months left\n                  iter. #5: fri 2036-02-29 00:00:00 utc\n                  from now: 16 years 11 months left\nsystemd-analyze timestamp\ntimestamp\n...\n       this command parses a timestamp (i.e. a single point in time) and\n       outputs the normalized form and the difference between this\n       timestamp and now. the timestamp should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing timestamps\".\nexample 14. show parsing of timestamps\n$ systemd-analyze timestamp yesterday now tomorrow\n             original form: yesterday\n           normalized form: mon 2019-05-20 00:00:00 cest\n                  (in utc): sun 2019-05-19 22:00:00 utc\n              unix seconds: @15583032000\n                  from now: 1 day 9h ago\n\n             original form: now\n           normalized form: tue 2019-05-21 09:48:39 cest\n                  (in utc): tue 2019-05-21 07:48:39 utc\n              unix seconds: @1558424919.659757\n                  from now: 43us ago\n\n             original form: tomorrow\n           normalized form: wed 2019-05-22 00:00:00 cest\n                  (in utc): tue 2019-05-21 22:00:00 utc\n              unix seconds: @15584760000\n                  from now: 14h left\nsystemd-analyze timespan\nexpression\n...\n       this command parses a time span (i.e. a difference between two\n       timestamps) and outputs the normalized form and the equivalent\n       value in microseconds. the time span should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing time spans\".\n       values without units are parsed as seconds.\nexample 15. show parsing of timespans\n$ systemd-analyze timespan 1s 300s '1year 0.000001s'\n           original: 1s\n                 \u00ee\u00bcs: 1000000\n              human: 1s\n\n           original: 300s\n                 \u00ee\u00bcs: 300000000\n              human: 5min\n\n           original: 1year 0.000001s\n                 \u00ee\u00bcs: 31557600000001\n              human: 1y 1us\nsystemd-analyze cat-config\nname\n|\npath\n...\n       this command is similar to\nsystemctl cat\n, but operates on config\n       files. it will copy the contents of a config file and any drop-ins\n       to standard output, using the usual systemd set of directories and\n       rules for precedence. each argument must be either an absolute\n       path including the prefix (such as /etc/systemd/logind.conf or\n       /usr/lib/systemd/logind.conf), or a name relative to the prefix\n       (such as systemd/logind.conf).\nexample 16. showing logind configuration\n$ systemd-analyze cat-config systemd/logind.conf\n           # /etc/systemd/logind.conf\n           ...\n           [login]\n           nautovts=8\n           ...\n\n           # /usr/lib/systemd/logind.conf.d/20-test.conf\n           ... some override from another package\n\n           # /etc/systemd/logind.conf.d/50-override.conf\n           ... some administrator override\nsystemd-analyze compare-versions\nversion1\n[\nop\n]\nversion2\nthis command has two distinct modes of operation, depending on\n       whether the operator\nop\nis specified.\n\n       in the first mode \u00e2\u0080\u0094 when\nop\nis not specified \u00e2\u0080\u0094, it will compare\n       the two version strings and print either \"\nversion1\n<\nversion2\n\", or\n       \"\nversion1\n==\nversion2\n\", or \"\nversion1\n>\nversion2\n\" as appropriate.\n\n       the exit status is\n0\nif the versions are equal,\n11\nif the version\n       of the right is smaller, and\n12\nif the version of the left is\n       smaller. (this matches the convention used by\nrpmdev-vercmp\n.)\n\n       in the second mode \u00e2\u0080\u0094 when\nop\nis specified \u00e2\u0080\u0094 it will compare the\n       two version strings using the operation\nop\nand return\n0\n(success)\n       if they condition is satisfied, and\n1\n(failure) otherwise.\nop\nmay\n       be\nlt\n,\nle\n,\neq\n,\nne\n,\nge\n,\ngt\n. in this mode, no output is printed.\n       (this matches the convention used by\ndpkg(1)\n--compare-versions\n.)\nexample 17. compare versions of a package\n$ systemd-analyze compare-versions systemd-250~rc1.fc36.aarch64 systemd-251.fc36.aarch64\n           systemd-250~rc1.fc36.aarch64 < systemd-251.fc36.aarch64\n           $ echo $?\n           12\n\n           $ systemd-analyze compare-versions 1 lt 2; echo $?\n           0\n           $ systemd-analyze compare-versions 1 ge 2; echo $?\n           1\nsystemd-analyze verify\nfile\n...\n       this command will load unit files and print warnings if any errors\n       are detected. files specified on the command line will be loaded,\n       but also any other units referenced by them. a unit's name on disk\n       can be overridden by specifying an alias after a colon; see below\n       for an example. the full unit search path is formed by combining\n       the directories for all command line arguments, and the usual unit\n       load paths. the variable\n$systemd_unit_path\nis supported, and may\n       be used to replace or augment the compiled in set of unit load\n       paths; see\nsystemd.unit(5)\n. all units files present in the\n       directories containing the command line arguments will be used in\n       preference to the other paths. if a template unit without an\n       instance name is specified (e.g.  foo@.service), \"test_instance\"\n       will be used as the instance name, which can be controlled by\n--instance=\noption.\n\n       the following errors are currently detected:\n\n       \u00e2\u0080\u00a2   unknown sections and directives,\n\n       \u00e2\u0080\u00a2   missing dependencies which are required to start the given\n           unit,\n\n       \u00e2\u0080\u00a2   man pages listed in\ndocumentation=\nwhich are not found in the\n           system,\n\n       \u00e2\u0080\u00a2   commands listed in\nexecstart=\nand similar which are not found\n           in the system or not executable.\nexample 18. misspelt directives\n$ cat ./user.slice\n           [unit]\n           whatisthis=11\n           documentation=man:nosuchfile(1)\n           requires=different.service\n\n           [service]\n           description=x\n\n           $ systemd-analyze verify ./user.slice\n           [./user.slice:9] unknown lvalue 'whatisthis' in section 'unit'\n           [./user.slice:13] unknown section 'service'. ignoring.\n           error: org.freedesktop.systemd1.loadfailed:\n              unit different.service failed to load:\n              no such file or directory.\n           failed to create user.slice/start: invalid argument\n           user.slice: man nosuchfile(1) command failed with code 16\nexample 19. missing service units\n$ tail ./a.socket ./b.socket\n           ==> ./a.socket <==\n           [socket]\n           listenstream=100\n\n           ==> ./b.socket <==\n           [socket]\n           listenstream=100\n           accept=yes\n\n           $ systemd-analyze verify ./a.socket ./b.socket\n           service a.service not loaded, a.socket cannot be started.\n           service b@0.service not loaded, b.socket cannot be started.\nexample 20. aliasing a unit\n$ cat /tmp/source\n           [unit]\n           description=hostname printer\n\n           [service]\n           type=simple\n           execstart=/usr/bin/echo %h\n           mysterykey=true\n\n           $ systemd-analyze verify /tmp/source\n           failed to prepare filename /tmp/source: invalid argument\n\n           $ systemd-analyze verify /tmp/source:alias.service\n           alias.service:7: unknown key name 'mysterykey' in section 'service', ignoring.\nsystemd-analyze security [\nunit\n...]\n       this command analyzes the security and sandboxing settings of one\n       or more specified service units. if at least one unit name is\n       specified the security settings of the specified service units are\n       inspected and a detailed analysis is shown. if no unit name is\n       specified, all currently loaded, long-running service units are\n       inspected and a terse table with results shown. the command checks\n       for various security-related service settings, assigning each a\n       numeric \"exposure level\" value, depending on how important a\n       setting is. it then calculates an overall exposure level for the\n       whole unit, which is an estimation in the range 0.0...10.0\n       indicating how exposed a service is security-wise. high exposure\n       levels indicate very little applied sandboxing. low exposure\n       levels indicate tight sandboxing and strongest security\n       restrictions. note that this only analyzes the per-service\n       security features systemd itself implements. this means that any\n       additional security mechanisms applied by the service code itself\n       are not accounted for. the exposure level determined this way\n       should not be misunderstood: a high exposure level neither means\n       that there is no effective sandboxing applied by the service code\n       itself, nor that the service is actually vulnerable to remote or\n       local attacks. high exposure levels do indicate however that most\n       likely the service might benefit from additional settings applied\n       to them.\n\n       please note that many of the security and sandboxing settings\n       individually can be circumvented \u00e2\u0080\u0094 unless combined with others.\n       for example, if a service retains the privilege to establish or\n       undo mount points many of the sandboxing options can be undone by\n       the service code itself. due to that is essential that each\n       service uses the most comprehensive and strict sandboxing and\n       security settings possible. the tool will take into account some\n       of these combinations and relationships between the settings, but\n       not all. also note that the security and sandboxing settings\n       analyzed here only apply to the operations executed by the service\n       code itself. if a service has access to an ipc system (such as\n       d-bus) it might request operations from other services that are\n       not subject to the same restrictions. any comprehensive security\n       and sandboxing analysis is hence incomplete if the ipc access\n       policy is not validated too.\nexample 21. analyze systemd-logind.service\n$ systemd-analyze security --no-pager systemd-logind.service\n             name                description                              exposure\n           \u00e2\u009c\u0097 privatenetwork=     service has access to the host's network      0.5\n           \u00e2\u009c\u0097 user=/dynamicuser=  service runs as root user                     0.4\n           \u00e2\u009c\u0097 deviceallow=        service has no device acl                     0.2\n           \u00e2\u009c\u0093 ipaddressdeny=      service blocks all ip address ranges\n           ...\n           \u00e2\u0086\u0092 overall exposure level for systemd-logind.service: 4.1 ok \u00f0\u009f\u0099\u0082\nsystemd-analyze inspect-elf\nfile\n...\n       this command will load the specified files, and if they are elf\n       objects (executables, libraries, core files, etc.) it will parse\n       the embedded packaging metadata, if any, and print it in a table\n       or json format. see the\npackage metadata for executable files\n[1]\n       document for more information.\nexample 22. print information about a core file as json\n$ systemd-analyze inspect-elf --json=pretty \\\n                   core.fsverity.1000.f77dac5dc161402aa44e15b7dd9dcf97.58561.1637106137000000\n           {\n                   \"elftype\" : \"coredump\",\n                   \"elfarchitecture\" : \"amd x86-64\",\n                   \"/home/bluca/git/fsverity-utils/fsverity\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"7c895ecd2a271f93e96268f479fdc3c64a2ec4ee\"\n                   },\n                   \"/home/bluca/git/fsverity-utils/libfsverity.so.0\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"b5e428254abf14237b0ae70ed85fffbb98a78f88\"\n                   }\n           }\nsystemd-analyze fdstore\nunit\n...\n       lists the current contents of the specified service unit's file\n       descriptor store. this shows names, inode types, device numbers,\n       inode numbers, paths and open modes of the open file descriptors.\n       the specified units must have\nfiledescriptorstoremax=\nenabled, see\nsystemd.service(5)\nfor details.\nexample 23. table output\n$ systemd-analyze fdstore systemd-journald.service\n           fdname type devno   inode rdevno path             flags\n           stored sock 0:8   4218620 -      socket:[4218620] ro\n           stored sock 0:8   4213198 -      socket:[4213198] ro\n           stored sock 0:8   4213190 -      socket:[4213190] ro\n           ...\n\n       note: the \"devno\" column refers to the major/minor numbers of the\n       device node backing the file system the file descriptor's inode is\n       on. the \"rdevno\" column refers to the major/minor numbers of the\n       device node itself if the file descriptor refers to one. compare\n       with corresponding\n.st_dev\nand\n.st_rdev\nfields in\nstruct stat\n(see\nstat(2)\nfor details). the listed inode numbers in the \"inode\"\n       column are on the file system indicated by \"devno\".\nsystemd-analyze image-policy\npolicy\n...\n       this command analyzes the specified image policy string, as per\nsystemd.image-policy(7)\n. the policy is normalized and simplified.\n       for each currently defined partition identifier (as per the\ndiscoverable partitions specification\n[2]) the effect of the image\n       policy string is shown in tabular form.\nexample 24. example output\n$ systemd-analyze image-policy swap=encrypted:usr=read-only-on+verity:root=encrypted\n           analyzing policy: root=encrypted:usr=verity+read-only-on:swap=encrypted\n                  long form: root=encrypted:usr=verity+read-only-on:swap=encrypted:=unused+absent\n\n           partition       mode        read-only growfs\n           root            encrypted   -         -\n           usr             verity      yes       -\n           home            ignore      -         -\n           srv             ignore      -         -\n           esp             ignore      -         -\n           xbootldr        ignore      -         -\n           swap            encrypted   -         -\n           root-verity     ignore      -         -\n           usr-verity      unprotected yes       -\n           root-verity-sig ignore      -         -\n           usr-verity-sig  ignore      -         -\n           tmp             ignore      -         -\n           var             ignore      -         -\n           default         ignore      -         -\nsystemd-analyze has-tpm2\nreports whether the system is equipped with a usable tpm2 device.\n       if a tpm2 device has been discovered, is supported, and is being\n       used by firmware, by the os kernel drivers and by userspace (i.e.\n       systemd) this prints \"yes\" and exits with exit status zero. if no\n       such device is discovered/supported/used, prints \"no\". otherwise,\n       prints \"partial\". in either of these two cases exits with non-zero\n       exit status. it also shows five lines indicating separately\n       whether firmware, drivers, the system, the kernel and libraries\n       discovered/support/use tpm2. currently, required libraries are\n       libtss2-esys.so.0, libtss2-rc.so.0, and libtss2-mu.so.0. the\n       requirement may be changed in the future release.\n\n       note, this checks for tpm 2.0 devices only, and does not consider\n       tpm 1.2 at all.\n\n       combine with\n--quiet\nto suppress the output.\nexample 25. example output\nyes\n           +firmware\n           +driver\n           +system\n           +subsystem\n           +libraries\n             +libtss2-esys.so.0\n             +libtss2-rc.so.0\n             +libtss2-mu.so.0\n\n       added in version 257.\nsystemd-analyze pcrs [\npcr\n...]\n       this command shows the known tpm2 pcrs along with their\n       identifying names and current values.\nexample 26. example output\n$ systemd-analyze pcrs\n           nr name                sha256\n            0 platform-code       bcd2eb527108bbb1f5528409bcbe310aa9b74f687854cc5857605993f3d9eb11\n            1 platform-config     b60622856eb7ce52637b80f30a520e6e87c347daa679f3335f4f1a600681bb01\n            2 external-code       1471262403e9a62f9c392941300b4807fbdb6f0bfdd50abfab752732087017dd\n            3 external-config     3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            4 boot-loader-code    939f7fa1458e1f7ce968874d908e524fc0debf890383d355e4ce347b7b78a95c\n            5 boot-loader-config  864c61c5ea5ecbdb6951e6cb6d9c1f4b4eac79772f7fe13b8bece569d83d3768\n            6 -                   3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            7 secure-boot-policy  9c905bd9b9891bfb889b90a54c4b537b889cfa817c4389cc25754823a9443255\n            8 -                   0000000000000000000000000000000000000000000000000000000000000000\n            9 kernel-initrd       9caa29b128113ef42aa53d421f03437be57211e5ebafc0fa8b5d4514ee37ff0c\n           10 ima                 5ea9e3dab53eb6b483b6ec9e3b2c712bea66bca1b155637841216e0094387400\n           11 kernel-boot         0000000000000000000000000000000000000000000000000000000000000000\n           12 kernel-config       627ffa4b405e911902fe1f1a8b0164693b31acab04f805f15bccfe2209c7eace\n           13 sysexts             0000000000000000000000000000000000000000000000000000000000000000\n           14 shim-policy         0000000000000000000000000000000000000000000000000000000000000000\n           15 system-identity     0000000000000000000000000000000000000000000000000000000000000000\n           16 debug               0000000000000000000000000000000000000000000000000000000000000000\n           17 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           18 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           19 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           20 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           21 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           22 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           23 application-support 0000000000000000000000000000000000000000000000000000000000000000\nsystemd-analyze srk [>\nfile\n]\n       this command reads the storage root key (srk) from the tpm2\n       device, and writes it in marshalled tpm2b_public format to stdout.\n       the output is non-printable data, so it should be redirected to a\n       file or into a pipe.\nexample 27. save the storage root key to srk.tpm2b_public\nsystemd-analyze srk >srk.tpm2b_public\nsystemd-analyze architectures [\nname\n...]\n       lists all known cpu architectures, and which ones are native. the\n       listed architecture names are those\nconditionarchitecture=\nsupports, see\nsystemd.unit(5)\nfor details. if architecture names\n       are specified only those specified are listed.\nexample 28. table output\n$ systemd-analyze architectures\n           name        support\n           alpha       foreign\n           arc         foreign\n           arc-be      foreign\n           arm         foreign\n           arm64       foreign\n           ...\n           sparc       foreign\n           sparc64     foreign\n           tilegx      foreign\n           x86         secondary\n           x86-64      native\nsystemd-analyze smbios11\nshows a list of smbios type #11 strings passed to the system. also\n       see\nsmbios-type-11(7)\n.\nexample 29. example output\n$ systemd-analyze smbios11\n           io.systemd.stub.kernel-cmdline-extra=console=ttys0\n           io.systemd.credential.binary:ssh.ephemeral-authorized_keys-all=c3nolwvkmju1mtkgqufbqumztnphqzfswkrjmu5urtvbqufbsurgd20xbfp4wlrgcljteg9zqlozotyzce1uyljcadmwm1mxvxhlsum2nmygbgvubmfydeb6zxrhcg==\n           io.systemd.credential:vmm.notify_socket=vsock-stream:2:254570042\n\n           3 smbios type #11 strings passed.\n\n       added in version 257.\nsystemd-analyze chid\nshows a list of computer hardware ids (chids) of the local system.\n       these ids identify the system's computer hardware, based on smbios\n       data. see\nusing computer hardware ids (chids)\n[3] for details about\n       chids.\nexample 30. example output\n$ systemd-analyze chid\n           type input  chid\n              3 mfpsmp 520537c0-3b59-504f-b062-9682ea236b21\n              4 mfps-- edf05dc8-a53d-5b2c-8023-630bca2a2463\n              5 mfp--- ebc6a4d9-ec48-537a-916b-c69fa4fdd814\n              6 m--smp 5ebe4bba-f598-5e90-9ff2-9fd0d3211465\n              7 m--s-- 1a3fb835-b42a-5f9c-a38c-eff5bfd5c41d\n              8 m-p-mp 2a831dce-8163-5bad-8406-435b8c752dd8\n              9 m-p--- 7c21c878-4a75-50f7-9816-21e811588da0\n             10 mf--mp 9a003537-bcc5-500e-b10a-8d8892e4fc64\n             11 mf---- bb9122bb-8a5c-50d2-a742-a85beb719909\n             13 m---mp bfc36935-5032-5987-a0a3-6311f01de33a\n\n           legend: m \u00e2\u0086\u0092 sys_vendor (lenovo) \u00e2\u0094\u0084 f \u00e2\u0086\u0092 product_family (thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 p \u00e2\u0086\u0092 product_name (20xw0055ge)\n                   s \u00e2\u0086\u0092 product_sku (lenovo_mt_20xw_bu_think_fm_thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 m \u00e2\u0086\u0092 board_vendor (lenovo)\n                   p \u00e2\u0086\u0092 board_name (20xw0055ge)\n\n       added in version 258.",
      "examples": "",
      "options": ""
    },
    {
      "command": "free",
      "description": "free\ndisplays the total amount of free and used physical and swap\n       memory in the system, as well as the buffers and caches used by\n       the kernel. the information is gathered by parsing /proc/meminfo.\n       the displayed columns are:\ntotal\ntotal usable memory (memtotal and swaptotal in\n              /proc/meminfo). this includes the physical and swap memory\n              minus a few reserved bits and kernel binary code.\nused\nused or unavailable memory (calculated as\ntotal\n-\navailable\n)\nfree\nunused memory (memfree and swapfree in /proc/meminfo)\nshared\nmemory used (mostly) by tmpfs (shmem in /proc/meminfo)\nbuffers\nmemory used by kernel buffers (buffers in /proc/meminfo)\ncache\nmemory used by the page cache and slabs (cached and\n              sreclaimable in /proc/meminfo)\nbuff/cache\nsum of\nbuffers\nand\ncache\navailable\nestimation of how much memory is available for starting new\n              applications, without swapping. unlike the data provided by\n              the\ncache\nor\nfree\nfields, this field takes into account\n              page cache and also that not all reclaimable memory slabs\n              will be reclaimed due to items being in use (memavailable\n              in /proc/meminfo, available on kernels 3.14, emulated on\n              kernels 2.6.27+, otherwise the same as\nfree\n)",
      "examples": "",
      "options": ""
    },
    {
      "command": "webvis",
      "description": "webvis\ndisplays an overview of system level web server performance\n       statistics collected from the performance co-pilot (pcp)\n       infrastructure.  the display is modulated by the values of the\n       performance metrics retrieved from the target\nhost\n(which is\n       running\npmcd(1)\nand the\npmdaweblog(1)\nperformance metrics domain\n       agent) or from the pcp archive log identified by\narchive\n.  the\n       display is updated every\ninterval\nseconds (default 2 seconds).\n\n       as in all\npmview(1)\nscenes, when the mouse is moved over one of\n       the bars, the current value and metric information for that bar\n       will be shown in the text box near the top of the display.\n\n       the height of the web request and network activity bars is\n       proportional to the performance metric values relative to the\n       maximum expected activity, as controlled by the\n-m\nand\n-r\noptions\n       (see below).  similarly the\n-b\nand\n-i\noptions control the scaling\n       for disk activity bars.\n\n       the bars in the\nwebvis\nscene represent the following information;\nrequests by size\nat the front of the scene, the \"requests by size\" row of bars\n           shows the rate of requests for different size requests (the\n           histograms are defined by the following byte counts: 0, 3\n           kbytes, 10 kbytes, 30 kbytes, 100 kbytes, 300 kbytes, 1 mbyte,\n           3 mbytes and larger than 3 mbytes).  notice that the size\n           divisions are not evenly distributed.  the \"size\" is the data\n           portion of the response to each web server request.  these\n           rates are aggregated across all monitored web servers.\nrequests by type\nthis row of bars shows the request rate for each type of http\n           request (get, post, head and other), aggregated across all\n           monitored web servers.  for a detailed display showing the\n           break down of requests\nper web server\n, see\nweblogvis(1)\n.\nnetwork\nfor every network interface there are two stacked bars.  one\n           of the bars shows the input traffic while the other bar shows\n           the output traffic.  the stacks are composed of the number of\n           errors (red), the number of drops (orange) and the number of\n           packets (green).  in general, if there are any \"dropped input\n           packets\" then the corresponding network interface is\n           saturated, or there are insufficient network resources\n           available in the kernel to adequately service the input\n           request load.  if this is the case then the\nalarm conditions\nrows (see below) may provide more detail into the source of\n           the problem.\nalarm conditions\nthe red row of bars shows an assortment of tcp error\n           conditions (aggregated for all network interfaces), the orange\n           bars show critical kernel buffer allocation problems, and the\n           yellow bar shows severe paging conditions.  if any of these\n           bars have a non-zero height then the system being monitored\n           may require kernel parameter tuning, software reconfiguration\n           or more hardware resources.  the performance metrics behind\n           the bars are:\nnetwork.tcp.drops\n- rate of dropped connections\nnetwork.tcp.conndrops\n- rate of embryonic connections dropped\nnetwork.tcp.timeoutdrop\n- rate of connections dropped by rexmit timeout\nnetwork.tcp.rcvbadsum\n- rate of packets discarded for bad checksums\nnetwork.tcp.rexmttimeo\n- rate of retransmit timeouts\nnetwork.tcp.sndrexmitpack\n- rate of data packets retransmitted\nswap.pagesout\n- page swap out rate (indicating insufficient memory)\nnetwork.mbuf.failed\n- rate of incidents where the kernel failed to find\n                  mbuf space\nnetwork.mbuf.waited\n- rate of incidents where the kernel waited to find\n                  mbuf space\ncpu\nthis column shows cpu utilization, aggregated over all cpus.\n           (cpu idle time is not included in the column).\ndisk\nthere are two cylinders showing disk metrics.  the first\n           cylinder shows the rate of read (yellow) and write (violet)\n           operations, aggregated over all disk spindles.  the second\n           cylinder shows the average (over all disks) percentage of time\n           for which a disk is busy or active.  this metric is not\n           available in pcp1.x versions, therefore if\nwebvis\nis being\n           used to monitor a host running pcp1.x this cylinder will not\n           be displayed.\n\n           to adjust the scaling of these objects, refer to the\n-b\nand\n-i\noptions described below.\nmem\nthere are two bars showing memory metrics.  the first bar\n           shows utilized memory, with different colors representing\n           different types of utilization (kernel, user, etc), while the\n           second bar shows the amount of free memory.  if\nwebvis\nis\n           being used to monitor a host running pcp1.x then only the bar\n           showing free memory will be displayed.\n\n       if any optional\ninterface\narguments are specified in the command\n       line, then just the network interfaces matching the\ninterface\narguments will appear in the\nnetwork\nsection.  by default,\nall\ninterfaces will be used.  the\ninterface\narguments are used as\n       patterns for\negrep\n(1) matching against the interface names, so\nec\nwould select all external ethernet interfaces for a challenge s.\nwebvis\nuses\npmview(1)\n, and so the user interface follows that\n       described for\npmview(1)\n, which in turn displays the scene within\n       an inventor examiner viewer.\nwebvis\npasses most command line options to\npmview(1)\n.  therefore,\n       the command line options\n-a\n,\n-a\n,\n-c\n,\n-h\n,\n-n\n,\n-o\n,\n-p\n,\n-s\n,\n-t\n,\n-t\n,\n-x\n,\n-z\nand\n-z\n, and the user interface are described in the\npmview(1)\nman page.\n\n       options specific to\nwebvis\nare:\n-b\nmaxbusy\ncontrols the maximum (normalization) value for the average\n              percentage of the time active over all disks.  the default\n              value is 30% active.\n-i\nmaxio\ncontrols the maximum (normalization) value for the sume of\n              the aggregate disk read and disk write rates.  the default\n              value is 100 i/os per second.\n-m\nmax\ncontrols the maximum (normalization) value for the packet\n              input and packet output rates.  the default value is 750\n              packets/second.\n-r\nmaxreq\ncontrols the maximum web request rate.  the default is 5%\n              of the maximum packet rate (i.e. 38 requests/second by\n              default).  the maximum web error rate is fixed at 20% of\n              the maximum web request rate (i.e. 7 errors/second by\n              default).\n-v\nthe derived configuration file for\npmview(1)\nis written on\n              standard output.  this may be saved and used directly with\npmview\nif the user wishes to customize the display, or\n              modify some of the normalization parameters.",
      "examples": "",
      "options": ""
    },
    {
      "command": "dash",
      "description": "dash\nis the standard command interpreter for the system.  the\n       current version of\ndash\nis in the process of being changed to\n       conform with the posix 1003.2 and 1003.2a specifications for the\n       shell.  this version has many features which make it appear\n       similar in some respects to the korn shell, but it is not a korn\n       shell clone (see\nksh\n(1)).  only features designated by posix, plus\n       a few berkeley extensions, are being incorporated into this shell.\n       this man page is not intended to be a tutorial or a complete\n       specification of the shell.\noverview\nthe shell is a command that reads lines from either a file or the\n       terminal, interprets them, and generally executes other commands.\n       it is the program that is running when a user logs into the system\n       (although a user can select a different shell with the\nchsh\n(1)\n       command).  the shell implements a language that has flow control\n       constructs, a macro facility that provides a variety of features\n       in addition to data storage, along with built in history and line\n       editing capabilities.  it incorporates many features to aid\n       interactive use and has the advantage that the interpretative\n       language is common to both interactive and non-interactive use\n       (shell scripts).  that is, commands can be typed directly to the\n       running shell or can be put into a file and the file can be\n       executed directly by the shell.\ninvocation\nif no args are present and if the standard input of the shell is\n       connected to a terminal (or if the\n-i\nflag is set), and the\n-c\noption is not present, the shell is considered an interactive\n       shell.  an interactive shell generally prompts before each command\n       and handles programming and command errors differently (as\n       described below).  when first starting, the shell inspects\n       argument 0, and if it begins with a dash \u00e2\u0080\u0098-\u00e2\u0080\u0099, the shell is also\n       considered a login shell.  this is normally done automatically by\n       the system when the user first logs in.  a login shell first reads\n       commands from the files\n/etc/profile\nand\n.profile\nif they exist.\n       if the environment variable env is set on entry to an interactive\n       shell, or is set in the\n.profile\nof a login shell, the shell next\n       reads commands from the file named in env.  therefore, a user\n       should place commands that are to be executed only at login time\n       in the\n.profile\nfile, and commands that are executed for every\n       interactive shell inside the env file.  to set the env variable to\n       some file, place the following line in your\n.profile\nof your home\n       directory\nenv=$home/.shinit; export env\nsubstituting for \u00e2\u0080\u009c.shinit\u00e2\u0080\u009d any filename you wish.\n\n       if command line arguments besides the options have been specified,\n       then the shell treats the first argument as the name of a file\n       from which to read commands (a shell script), and the remaining\n       arguments are set as the positional parameters of the shell ($1,\n       $2, etc).  otherwise, the shell reads commands from its standard\n       input.\nargument list processing\nall of the single letter options that have a corresponding name\n       can be used as an argument to the\n-o\noption.  the set\n-o\nname is\n       provided next to the single letter option in the description\n       below.  specifying a dash \u00e2\u0080\u009c-\u00e2\u0080\u009d turns the option on, while using a\n       plus \u00e2\u0080\u009c+\u00e2\u0080\u009d disables the option.  the following options can be set\n       from the command line or with the\nset\nbuiltin (described later).\n-a\nallexport\nexport all variables assigned to.\n-c\nread commands from the\ncommand_string\noperand instead of from the standard input.\n                              special parameter 0 will be set from the\ncommand_name\noperand and the positional\n                              parameters ($1, $2, etc.)  set from the\n                              remaining argument operands.\n-c\nnoclobber\ndon't overwrite existing files with \u00e2\u0080\u009c>\u00e2\u0080\u009d.\n-e\nerrexit\nif not interactive, exit immediately if any\n                              untested command fails.  the exit status of\n                              a command is considered to be explicitly\n                              tested if the command is used to control an\nif\n,\nelif\n,\nwhile\n, or\nuntil\n; or if the\n                              command is the left hand operand of an \u00e2\u0080\u009c&&\u00e2\u0080\u009d\n                              or \u00e2\u0080\u009c||\u00e2\u0080\u009d operator.\n-f\nnoglob\ndisable pathname expansion.\n-n\nnoexec\nif not interactive, read commands but do\n                              not execute them.  this is useful for\n                              checking the syntax of shell scripts.\n-u\nnounset\nwrite a message to standard error when\n                              attempting to expand a variable that is not\n                              set, and if the shell is not interactive,\n                              exit immediately.\n-v\nverbose\nthe shell writes its input to standard\n                              error as it is read.  useful for debugging.\n-x\nxtrace\nwrite each command to standard error\n                              (preceded by a \u00e2\u0080\u0098+ \u00e2\u0080\u0099) before it is executed.\n                              useful for debugging.\n-i\nignoreeof\nignore eof's from input when interactive.\n-i\ninteractive\nforce the shell to behave interactively.\n-l\nmake dash act as if it had been invoked as\n                              a login shell.\n-m\nmonitor\nturn on job control (set automatically when\n                              interactive).\n-s\nstdin\nread commands from standard input (set\n                              automatically if no file arguments are\n                              present).  this option has no effect when\n                              set after the shell has already started\n                              running (i.e. with\nset\n).\n-v\nvi\nenable the built-in\nvi\n(1) command line\n                              editor (disables\n-e\nif it has been set).\n-e\nemacs\nenable the built-in\nemacs\n(1) command line\n                              editor (disables\n-v\nif it has been set).\n-b\nnotify\nenable asynchronous notification of\n                              background job completion.  (unimplemented\n                              for 4.4alpha)\nlexical structure\nthe shell reads input in terms of lines from a file and breaks it\n       up into words at whitespace (blanks and tabs), and at certain\n       sequences of characters that are special to the shell called\n       \u00e2\u0080\u009coperators\u00e2\u0080\u009d.  there are two types of operators: control operators\n       and redirection operators (their meaning is discussed later).\n       following is a list of operators:\n\n             control operators:\n& && ( ) ; ;;\n|\n|| <newline>\nredirection operators:\n< > >| << >> <& >& <<- <>\nquoting\nquoting is used to remove the special meaning of certain\n       characters or words to the shell, such as operators, whitespace,\n       or keywords.  there are three types of quoting: matched single\n       quotes, matched double quotes, and backslash.\nbackslash\na backslash preserves the literal meaning of the following\n       character, with the exception of \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9.  a backslash preceding\n       a \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9 is treated as a line continuation.\nsingle quotes\nenclosing characters in single quotes preserves the literal\n       meaning of all the characters (except single quotes, making it\n       impossible to put single-quotes in a single-quoted string).\ndouble quotes\nenclosing characters within double quotes preserves the literal\n       meaning of all characters except dollarsign ($), backquote (`),\n       and backslash (\\).  the backslash inside double quotes is\n       historically weird, and serves to quote only the following\n       characters:\n$ ` \" \\ <newline>\n.\n       otherwise it remains literal.\nreserved words\nreserved words are words that have special meaning to the shell\n       and are recognized at the beginning of a line and after a control\n       operator.  the following are reserved words:\n\n             !       elif    fi      while   case\n             else    for     then    {       }\n             do      done    until   if      esac\n\n       their meaning is discussed later.\naliases\nan alias is a name and corresponding value set using the\nalias\n(1)\n       builtin command.  whenever a reserved word may occur (see above),\n       and after checking for reserved words, the shell checks the word\n       to see if it matches an alias.  if it does, it replaces it in the\n       input stream with its value.  for example, if there is an alias\n       called \u00e2\u0080\u009clf\u00e2\u0080\u009d with the value \u00e2\u0080\u009cls -f\u00e2\u0080\u009d, then the input:\nlf foobar\n\u00e2\u009f\u00a8return\u00e2\u009f\u00a9\n\n       would become\nls -f foobar\n\u00e2\u009f\u00a8return\u00e2\u009f\u00a9\n\n       aliases provide a convenient way for naive users to create\n       shorthands for commands without having to learn how to create\n       functions with arguments.  they can also be used to create\n       lexically obscure code.  this use is discouraged.\ncommands\nthe shell interprets the words it reads according to a language,\n       the specification of which is outside the scope of this man page\n       (refer to the bnf in the posix 1003.2 document).  essentially\n       though, a line is read and if the first word of the line (or after\n       a control operator) is not a reserved word, then the shell has\n       recognized a simple command.  otherwise, a complex command or some\n       other special construct may have been recognized.\nsimple commands\nif a simple command has been recognized, the shell performs the\n       following actions:\n\n             1.   leading words of the form \u00e2\u0080\u009cname=value\u00e2\u0080\u009d are stripped off\n                  and assigned to the environment of the simple command.\n                  redirection operators and their arguments (as described\n                  below) are stripped off and saved for processing.\n\n             2.   the remaining words are expanded as described in the\n                  section called \u00e2\u0080\u009cexpansions\u00e2\u0080\u009d, and the first remaining\n                  word is considered the command name and the command is\n                  located.  the remaining words are considered the\n                  arguments of the command.  if no command name resulted,\n                  then the \u00e2\u0080\u009cname=value\u00e2\u0080\u009d variable assignments recognized\n                  in item 1 affect the current shell.\n\n             3.   redirections are performed as described in the next\n                  section.\nredirections\nredirections are used to change where a command reads its input or\n       sends its output.  in general, redirections open, close, or\n       duplicate an existing reference to a file.  the overall format\n       used for redirection is:\n[n]\nredir-op file\nwhere\nredir-op\nis one of the redirection operators mentioned\n       previously.  following is a list of the possible redirections.\n       the [n] is an optional number between 0 and 9, as in \u00e2\u0080\u00983\u00e2\u0080\u0099 (not\n       \u00e2\u0080\u0098[3]\u00e2\u0080\u0099), that refers to a file descriptor.\n\n             [n]> file   redirect standard output (or n) to file.\n\n             [n]>| file  same, but override the\n-c\noption.\n\n             [n]>> file  append standard output (or n) to file.\n\n             [n]< file   redirect standard input (or n) from file.\n\n             [n1]<&n2    copy file descriptor n2 as stdin (or fd n1).\n\n             [n]<&-      close standard input (or n).\n\n             [n1]>&n2    copy file descriptor n2 as stdout (or fd n1).\n\n             [n]>&-      close standard output (or n).\n\n             [n]<> file  open file for reading and writing on standard\n                         input (or n).\n\n       the following redirection is often called a \u00e2\u0080\u009chere-document\u00e2\u0080\u009d.\n[n]<< delimiter\nhere-doc-text ...\ndelimiter\nall the text on successive lines up to the delimiter is saved away\n       and made available to the command on standard input, or file\n       descriptor n if it is specified.  if the delimiter as specified on\n       the initial line is quoted, then the here-doc-text is treated\n       literally, otherwise the text is subjected to parameter expansion,\n       command substitution, and arithmetic expansion (as described in\n       the section on \u00e2\u0080\u009cexpansions\u00e2\u0080\u009d).  if the operator is \u00e2\u0080\u009c<<-\u00e2\u0080\u009d instead of\n       \u00e2\u0080\u009c<<\u00e2\u0080\u009d, then leading tabs in the here-doc-text are stripped.\nsearch and execution\nthere are three types of commands: shell functions, builtin\n       commands, and normal programs \u00e2\u0080\u0093 and the command is searched for\n       (by name) in that order.  they each are executed in a different\n       way.\n\n       when a shell function is executed, all of the shell positional\n       parameters (except $0, which remains unchanged) are set to the\n       arguments of the shell function.  the variables which are\n       explicitly placed in the environment of the command (by placing\n       assignments to them before the function name) are made local to\n       the function and are set to the values given.  then the command\n       given in the function definition is executed.  the positional\n       parameters are restored to their original values when the command\n       completes.  this all occurs within the current shell.\n\n       shell builtins are executed internally to the shell, without\n       spawning a new process.\n\n       otherwise, if the command name doesn't match a function or\n       builtin, the command is searched for as a normal program in the\n       file system (as described in the next section).  when a normal\n       program is executed, the shell runs the program, passing the\n       arguments and the environment to the program.  if the program is\n       not a normal executable file (i.e., if it does not begin with the\n       \"magic number\" whose ascii representation is \"#!\", so\nexecve\n(2)\n       returns enoexec then) the shell will interpret the program in a\n       subshell.  the child shell will reinitialize itself in this case,\n       so that the effect will be as if a new shell had been invoked to\n       handle the ad-hoc shell script, except that the location of hashed\n       commands located in the parent shell will be remembered by the\n       child.\n\n       note that previous versions of this document and the source code\n       itself misleadingly and sporadically refer to a shell script\n       without a magic number as a \"shell procedure\".\npath search\nwhen locating a command, the shell first looks to see if it has a\n       shell function by that name.  then it looks for a builtin command\n       by that name.  if a builtin command is not found, one of two\n       things happen:\n\n       1.   command names containing a slash are simply executed without\n            performing any searches.\n\n       2.   the shell searches each entry in path in turn for the\n            command.  the value of the path variable should be a series\n            of entries separated by colons.  each entry consists of a\n            directory name.  the current directory may be indicated\n            implicitly by an empty directory name, or explicitly by a\n            single period.\ncommand exit status\neach command has an exit status that can influence the behaviour\n       of other shell commands.  the paradigm is that a command exits\n       with zero for normal or success, and non-zero for failure, error,\n       or a false indication.  the man page for each command should\n       indicate the various exit codes and what they mean.  additionally,\n       the builtin commands return exit codes, as does an executed shell\n       function.\n\n       if a command consists entirely of variable assignments then the\n       exit status of the command is that of the last command\n       substitution if any, otherwise 0.\ncomplex commands\ncomplex commands are combinations of simple commands with control\n       operators or reserved words, together creating a larger complex\n       command.  more generally, a command is one of the following:\n\u00e2\u0080\u00a2\nsimple command\n\u00e2\u0080\u00a2\npipeline\n\u00e2\u0080\u00a2\nlist or compound-list\n\u00e2\u0080\u00a2\ncompound command\n\u00e2\u0080\u00a2\nfunction definition\n\n       unless otherwise stated, the exit status of a command is that of\n       the last simple command executed by the command.\npipelines\na pipeline is a sequence of one or more commands separated by the\n       control operator |.  the standard output of all but the last\n       command is connected to the standard input of the next command.\n       the standard output of the last command is inherited from the\n       shell, as usual.\n\n       the format for a pipeline is:\n[!] command1\n[|\ncommand2 ...]\nthe standard output of command1 is connected to the standard input\n       of command2.  the standard input, standard output, or both of a\n       command is considered to be assigned by the pipeline before any\n       redirection specified by redirection operators that are part of\n       the command.\n\n       if the pipeline is not in the background (discussed later), the\n       shell waits for all commands to complete.\n\n       if the\npipefail\noption was enabled when the shell began execution\n       of the pipeline, the pipeline's exit status is the exit status of\n       the last command specified in the pipeline that exited with non-\n       zero status, or zero if all commands in the pipeline exited with a\n       status of zero. if the\npipefail\noption was not enabled, the\n       pipeline's exit status is the exit status of the last command\n       specified in the pipeline; the exit statuses of any other commands\n       are not used. if the reserved word ! precedes the pipeline, its\n       exit status is the logical not of the exit status described above.\n\n       because pipeline assignment of standard input or standard output\n       or both takes place before redirection, it can be modified by\n       redirection.  for example:\n$ command1 2>&1\n|\ncommand2\nsends both the standard output and standard error of command1 to\n       the standard input of command2.\n\n       a ; or \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9 terminator causes the preceding and-or-list\n       (described next) to be executed sequentially; a & causes\n       asynchronous execution of the preceding and-or-list.\n\n       note that unlike some other shells, each process in the pipeline\n       is a child of the invoking shell (unless it is a shell builtin, in\n       which case it executes in the current shell \u00e2\u0080\u0093 but any effect it\n       has on the environment is wiped).\nbackground commands \u00e2\u0080\u0093 &\nif a command is terminated by the control operator ampersand (&),\n       the shell executes the command asynchronously \u00e2\u0080\u0093 that is, the shell\n       does not wait for the command to finish before executing the next\n       command.\n\n       the format for running a command in background is:\ncommand1 & [command2 & ...]\nif the shell is not interactive, the standard input of an\n       asynchronous command is set to\n/dev/null\n.\nlists \u00e2\u0080\u0093 generally speaking\na list is a sequence of zero or more commands separated by\n       newlines, semicolons, or ampersands, and optionally terminated by\n       one of these three characters.  the commands in a list are\n       executed in the order they are written.  if command is followed by\n       an ampersand, the shell starts the command and immediately\n       proceeds onto the next command; otherwise it waits for the command\n       to terminate before proceeding to the next one.\nshort-circuit list operators\n\u00e2\u0080\u009c&&\u00e2\u0080\u009d and \u00e2\u0080\u009c||\u00e2\u0080\u009d are and-or list operators.  \u00e2\u0080\u009c&&\u00e2\u0080\u009d executes the first\n       command, and then executes the second command if and only if the\n       exit status of the first command is zero.  \u00e2\u0080\u009c||\u00e2\u0080\u009d is similar, but\n       executes the second command if and only if the exit status of the\n       first command is nonzero.  \u00e2\u0080\u009c&&\u00e2\u0080\u009d and \u00e2\u0080\u009c||\u00e2\u0080\u009d both have the same\n       priority.\nflow-control constructs \u00e2\u0080\u0093 if, while, for, case\nthe syntax of the if command is\n\n             if list\n             then list\n             [ elif list\n             then    list ] ...\n             [ else list ]\n             fi\n\n       the syntax of the while command is\n\n             while list\n             do   list\n             done\n\n       the two lists are executed repeatedly while the exit status of the\n       first list is zero.  the until command is similar, but has the\n       word until in place of while, which causes it to repeat until the\n       exit status of the first list is zero.\n\n       the syntax of the for command is\n\n             for variable [ in [ word ... ] ]\n             do   list\n             done\n\n       the words following\nin\nare expanded, and then the list is executed\n       repeatedly with the variable set to each word in turn.  omitting\n       in word ... is equivalent to in \"$@\".\n\n       the syntax of the break and continue command is\n\n             break [ num ]\n             continue [ num ]\n\n       break terminates the num innermost for or while loops.  continue\n       continues with the next iteration of the innermost loop.  these\n       are implemented as builtin commands.\n\n       the syntax of the case command is\n\n             case word in\n             [(]pattern) list ;;\n             ...\n             esac\n\n       the pattern can actually be one or more patterns (see \u00e2\u0080\u009cshell\n       patterns\u00e2\u0080\u009d described later), separated by \u00e2\u0080\u009c|\u00e2\u0080\u009d characters.  the \u00e2\u0080\u009c(\u00e2\u0080\u009d\n       character before the pattern is optional.\ngrouping commands together\ncommands may be grouped by writing either\n(list)\nor\n{ list; }\nthe first of these executes the commands in a subshell.  builtin\n       commands grouped into a (list) will not affect the current shell.\n       the second form does not fork another shell so is slightly more\n       efficient.  grouping commands together this way allows you to\n       redirect their output as though they were one program:\n\n             { printf \" hello \" ; printf \" world\\n\" ; } > greeting\n\n       note that \u00e2\u0080\u009c}\u00e2\u0080\u009d must follow a control operator (here, \u00e2\u0080\u009c;\u00e2\u0080\u009d) so that\n       it is recognized as a reserved word and not as another command\n       argument.\nfunctions\nthe syntax of a function definition is\nname\n()\ncommand\na function definition is an executable statement; when executed it\n       installs a function named name and returns an exit status of zero.\n       the command is normally a list enclosed between \u00e2\u0080\u009c{\u00e2\u0080\u009d and \u00e2\u0080\u009c}\u00e2\u0080\u009d.\n\n       variables may be declared to be local to a function by using a\n       local command.  this should appear as the first statement of a\n       function, and the syntax is\nlocal\n[\nvariable\n|\n-\n]\n...\nlocal is implemented as a builtin command.\n\n       when a variable is made local, it inherits the initial value and\n       exported and readonly flags from the variable with the same name\n       in the surrounding scope, if there is one.  otherwise, the\n       variable is initially unset.  the shell uses dynamic scoping, so\n       that if you make the variable x local to function f, which then\n       calls function g, references to the variable x made inside g will\n       refer to the variable x declared inside f, not to the global\n       variable named x.\n\n       the only special parameter that can be made local is \u00e2\u0080\u009c-\u00e2\u0080\u009d.  making\n       \u00e2\u0080\u009c-\u00e2\u0080\u009d local any shell options that are changed via the set command\n       inside the function to be restored to their original values when\n       the function returns.\n\n       the syntax of the return command is\nreturn\n[\nexitstatus\n]\n\n       it terminates the currently executing function.  return is\n       implemented as a builtin command.\nvariables and parameters\nthe shell maintains a set of parameters.  a parameter denoted by a\n       name is called a variable.  when starting up, the shell turns all\n       the environment variables into shell variables.  new variables can\n       be set using the form\nname=value\nvariables set by the user must have a name consisting solely of\n       alphabetics, numerics, and underscores - the first of which must\n       not be numeric.  a parameter can also be denoted by a number or a\n       special character as explained below.\npositional parameters\na positional parameter is a parameter denoted by a number (n > 0).\n       the shell sets these initially to the values of its command line\n       arguments that follow the name of the shell script.  the\nset\nbuiltin can also be used to set or reset them.\nspecial parameters\na special parameter is a parameter denoted by one of the following\n       special characters.  the value of the parameter is listed next to\n       its character.\n\n       *            expands to the positional parameters, starting from\n                    one.  when the expansion occurs within a double-\n                    quoted string it expands to a single field with the\n                    value of each parameter separated by the first\n                    character of the ifs variable, or by a \u00e2\u009f\u00a8space\u00e2\u009f\u00a9 if ifs\n                    is unset.\n\n       @            expands to the positional parameters, starting from\n                    one.  when the expansion occurs within double-quotes,\n                    each positional parameter expands as a separate\n                    argument.  if there are no positional parameters, the\n                    expansion of @ generates zero arguments, even when @\n                    is double-quoted.  what this basically means, for\n                    example, is if $1 is \u00e2\u0080\u009cabc\u00e2\u0080\u009d and $2 is \u00e2\u0080\u009cdef ghi\u00e2\u0080\u009d, then\n                    \"$@\" expands to the two arguments:\n\"abc\" \"def ghi\"\n#            expands to the number of positional parameters.\n\n       ?            expands to the exit status of the most recent\n                    pipeline.\n\n       - (hyphen.)  expands to the current option flags (the single-\n                    letter option names concatenated into a string) as\n                    specified on invocation, by the set builtin command,\n                    or implicitly by the shell.\n\n       $            expands to the process id of the invoked shell.  a\n                    subshell retains the same value of $ as its parent.\n\n       !            expands to the process id of the most recent\n                    background command executed from the current shell.\n                    for a pipeline, the process id is that of the last\n                    command in the pipeline.\n\n       0 (zero.)    expands to the name of the shell or shell script.\nword expansions\nthis clause describes the various expansions that are performed on\n       words.  not all expansions are performed on every word, as\n       explained later.\n\n       tilde expansions, parameter expansions, command substitutions,\n       arithmetic expansions, and quote removals that occur within a\n       single word expand to a single field.  it is only field splitting\n       or pathname expansion that can create multiple fields from a\n       single word.  the single exception to this rule is the expansion\n       of the special parameter @ within double-quotes, as was described\n       above.\n\n       the order of word expansion is:\n\n       1.   tilde expansion, parameter expansion, command substitution,\n            arithmetic expansion (these all occur at the same time).\n\n       2.   field splitting is performed on fields generated by step (1)\n            unless the ifs variable is null.\n\n       3.   pathname expansion (unless set\n-f\nis in effect).\n\n       4.   quote removal.\n\n       the $ character is used to introduce parameter expansion, command\n       substitution, or arithmetic evaluation.\ntilde expansion (substituting a user's home directory)\na word beginning with an unquoted tilde character (~) is subjected\n       to tilde expansion.  all the characters up to a slash (/) or the\n       end of the word are treated as a username and are replaced with\n       the user's home directory.  if the username is missing (as in\n~/foobar\n), the tilde is replaced with the value of the\nhome\nvariable (the current user's home directory).\nparameter expansion\nthe format for parameter expansion is as follows:\n${expression}\nwhere expression consists of all characters until the matching\n       \u00e2\u0080\u009c}\u00e2\u0080\u009d.  any \u00e2\u0080\u009c}\u00e2\u0080\u009d escaped by a backslash or within a quoted string,\n       and characters in embedded arithmetic expansions, command\n       substitutions, and variable expansions, are not examined in\n       determining the matching \u00e2\u0080\u009c}\u00e2\u0080\u009d.\n\n       the simplest form for parameter expansion is:\n${parameter}\nthe value, if any, of parameter is substituted.\n\n       the parameter name or symbol can be enclosed in braces, which are\n       optional except for positional parameters with more than one digit\n       or when parameter is followed by a character that could be\n       interpreted as part of the name.  if a parameter expansion occurs\n       inside double-quotes:\n\n       1.   pathname expansion is not performed on the results of the\n            expansion.\n\n       2.   field splitting is not performed on the results of the\n            expansion, with the exception of @.\n\n       in addition, a parameter expansion can be modified by using one of\n       the following formats.\n\n       ${parameter:-word}    use default values.  if parameter is unset\n                             or null, the expansion of word is\n                             substituted; otherwise, the value of\n                             parameter is substituted.\n\n       ${parameter:=word}    assign default values.  if parameter is\n                             unset or null, the expansion of word is\n                             assigned to parameter.  in all cases, the\n                             final value of parameter is substituted.\n                             only variables, not positional parameters or\n                             special parameters, can be assigned in this\n                             way.\n\n       ${parameter:?[word]}  indicate error if null or unset.  if\n                             parameter is unset or null, the expansion of\n                             word (or a message indicating it is unset if\n                             word is omitted) is written to standard\n                             error and the shell exits with a nonzero\n                             exit status.  otherwise, the value of\n                             parameter is substituted.  an interactive\n                             shell need not exit.\n\n       ${parameter:+word}    use alternative value.  if parameter is\n                             unset or null, null is substituted;\n                             otherwise, the expansion of word is\n                             substituted.\n\n       in the parameter expansions shown previously, use of the colon in\n       the format results in a test for a parameter that is unset or\n       null; omission of the colon results in a test for a parameter that\n       is only unset.\n\n       ${#parameter}         string length.  the length in characters of\n                             the value of parameter.\n\n       the following four varieties of parameter expansion provide for\n       substring processing.  in each case, pattern matching notation\n       (see \u00e2\u0080\u009cshell patterns\u00e2\u0080\u009d), rather than regular expression notation,\n       is used to evaluate the patterns.  if parameter is * or @, the\n       result of the expansion is unspecified.  enclosing the full\n       parameter expansion string in double-quotes does not cause the\n       following four varieties of pattern characters to be quoted,\n       whereas quoting characters within the braces has this effect.\n\n       ${parameter%word}     remove smallest suffix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the smallest portion of the\n                             suffix matched by the pattern deleted.\n\n       ${parameter%%word}    remove largest suffix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the largest portion of the\n                             suffix matched by the pattern deleted.\n\n       ${parameter#word}     remove smallest prefix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the smallest portion of the\n                             prefix matched by the pattern deleted.\n\n       ${parameter##word}    remove largest prefix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the largest portion of the\n                             prefix matched by the pattern deleted.\ncommand substitution\ncommand substitution allows the output of a command to be\n       substituted in place of the command name itself.  command\n       substitution occurs when the command is enclosed as follows:\n$(command)\nor (\u00e2\u0080\u009cbackquoted\u00e2\u0080\u009d version):\n`command`\nthe shell expands the command substitution by executing command in\n       a subshell environment and replacing the command substitution with\n       the standard output of the command, removing sequences of one or\n       more \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9s at the end of the substitution.  (embedded\n       \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9s before the end of the output are not removed; however,\n       during field splitting, they may be translated into \u00e2\u009f\u00a8space\u00e2\u009f\u00a9s,\n       depending on the value of ifs and quoting that is in effect.)\narithmetic expansion\narithmetic expansion provides a mechanism for evaluating an\n       arithmetic expression and substituting its value.  the format for\n       arithmetic expansion is as follows:\n$((expression))\nthe expression is treated as if it were in double-quotes, except\n       that a double-quote inside the expression is not treated\n       specially.  the shell expands all tokens in the expression for\n       parameter expansion, command substitution, and quote removal.\n\n       next, the shell treats this as an arithmetic expression and\n       substitutes the value of the expression.\nwhite space splitting (field splitting)\nafter parameter expansion, command substitution, and arithmetic\n       expansion the shell scans the results of expansions and\n       substitutions that did not occur in double-quotes for field\n       splitting and multiple fields can result.\n\n       the shell treats each character of the ifs as a delimiter and uses\n       the delimiters to split the results of parameter expansion and\n       command substitution into fields.\n\n       if ifs is empty, field splitting yields no fields if the input\n       string was empty, and one string with the unchanged value of the\n       input otherwise.  for example, with the default ifs, \u00e2\u0080\u009c\nread -r\nl\u00e2\u0080\u009d\n       will remove any initial whitespace, but \u00e2\u0080\u009cifs=\nread -r\nl\u00e2\u0080\u009d will\n       leave the entire line in l.\npathname expansion (file name generation)\nunless the\n-f\nflag is set, file name generation is performed after\n       word splitting is complete.  each word is viewed as a series of\n       patterns, separated by slashes.  the process of expansion replaces\n       the word with the names of all existing files whose names can be\n       formed by replacing each pattern with a string that matches the\n       specified pattern.  there are two restrictions on this: first, a\n       pattern cannot match a string containing a slash, and second, a\n       pattern cannot match a string starting with a period unless the\n       first character of the pattern is a period.  the next section\n       describes the patterns used for both pathname expansion and the\ncase\ncommand.\nshell patterns\na pattern consists of normal characters, which match themselves,\n       and meta-characters.  the meta-characters are \u00e2\u0080\u009c!\u00e2\u0080\u009d, \u00e2\u0080\u009c*\u00e2\u0080\u009d, \u00e2\u0080\u009c?\u00e2\u0080\u009d, and\n       \u00e2\u0080\u009c[\u00e2\u0080\u009d.  these characters lose their special meanings if they are\n       quoted.  when command or variable substitution is performed and\n       the dollar sign or back quotes are not double quoted, the value of\n       the variable or the output of the command is scanned for these\n       characters and they are turned into meta-characters.\n\n       an asterisk (\u00e2\u0080\u009c*\u00e2\u0080\u009d) matches any string of characters.  a question\n       mark matches any single character.  a left bracket (\u00e2\u0080\u009c[\u00e2\u0080\u009d)\n       introduces a character class.  the end of the character class is\n       indicated by a (\u00e2\u0080\u009c]\u00e2\u0080\u009d); if the \u00e2\u0080\u009c]\u00e2\u0080\u009d is missing then the \u00e2\u0080\u009c[\u00e2\u0080\u009d matches a\n       \u00e2\u0080\u009c[\u00e2\u0080\u009d rather than introducing a character class.  a character class\n       matches any of the characters between the square brackets.  a\n       range of characters may be specified using a minus sign.  the\n       character class may be complemented by making an exclamation point\n       the first character of the character class.\n\n       to include a \u00e2\u0080\u009c]\u00e2\u0080\u009d in a character class, make it the first character\n       listed (after the \u00e2\u0080\u009c!\u00e2\u0080\u009d, if any).  to include a minus sign, make it\n       the first or last character listed.\nbuiltins\nthis section lists the builtin commands which are builtin because\n       they need to perform some operation that can't be performed by a\n       separate process.  in addition to these, there are several other\n       commands that may be builtin for efficiency (e.g.\nprintf\n(1),\necho\n(1),\ntest\n(1), etc).\n\n       :\n\n       true   a null command that returns a 0 (true) exit value.\n\n       false  a null command that returns a 1 (false) exit value.\n\n       . file\n              the commands in the specified file are read and executed by\n              the shell.\n\n       alias [\nname\n[\n=string ...\n]]\n              if\nname=string\nis specified, the shell defines the alias\nname\nwith value\nstring\n.  if just\nname\nis specified, the\n              value of the alias\nname\nis printed.  with no arguments, the\nalias\nbuiltin prints the names and values of all defined\n              aliases (see\nunalias\n).\n\n       bg [\njob\n]\n...\ncontinue the specified jobs (or the current job if no jobs\n              are given) in the background.\n\n       command [\n-p\n] [\n-v\n] [\n-v\n]\ncommand\n[\narg ...\n]\n              execute the specified command but ignore shell functions\n              when searching for it.  (this is useful when you have a\n              shell function with the same name as a builtin command.)\n-p\nsearch for command using a path that guarantees to\n                     find all the standard utilities.\n-v\ndo not execute the command but search for the\n                     command and print the resolution of the command\n                     search.  this is the same as the type builtin.\n-v\ndo not execute the command but search for the\n                     command and print the absolute pathname of\n                     utilities, the name for builtins or the expansion of\n                     aliases.\n\n       cd|chdir\n-\ncd|chdir [\n-lp\n] [\ndirectory\n]\n              switch to the specified directory (default home).  if an\n              entry for cdpath appears in the environment of the\ncd\ncommand or the shell variable cdpath is set and the\n              directory name does not begin with a slash, then the\n              directories listed in cdpath will be searched for the\n              specified directory.  the format of cdpath is the same as\n              that of path.  if a single dash is specified as the\n              argument, it will be replaced by the value of oldpwd.  the\ncd\ncommand will print out the name of the directory that it\n              actually switched to if this is different from the name\n              that the user gave.  these may be different either because\n              the cdpath mechanism was used or because the argument is a\n              single dash.  the\n-p\noption causes the physical directory\n              structure to be used, that is, all symbolic links are\n              resolved to their respective values.  the\n-l\noption turns\n              off the effect of any preceding\n-p\noptions.\n\n       echo [\n-n\n]\nargs...\nprint the arguments on the standard output, separated by\n              spaces.  unless the\n-n\noption is present, a newline is\n              output following the arguments.\n\n              if any of the following sequences of characters is\n              encountered during output, the sequence is not output.\n              instead, the specified action is performed:\n\\b\na backspace character is output.\n\\c\nsubsequent output is suppressed.  this is normally\n                      used at the end of the last argument to suppress\n                      the trailing newline that\necho\nwould otherwise\n                      output.\n\\f\noutput a form feed.\n\\n\noutput a newline character.\n\\r\noutput a carriage return.\n\\t\noutput a (horizontal) tab character.\n\\v\noutput a vertical tab.\n\\0\ndigits\noutput the character whose value is given by zero\n                      to three octal digits.  if there are zero digits, a\n                      nul character is output.\n\\\\\noutput a backslash.\n\n              all other backslash sequences elicit undefined behaviour.\n\n       eval\nstring ...\nconcatenate all the arguments with spaces.  then re-parse\n              and execute the command.\n\n       exec [\ncommand arg ...\n]\n              unless command is omitted, the shell process is replaced\n              with the specified program (which must be a real program,\n              not a shell builtin or function).  any redirections on the\nexec\ncommand are marked as permanent, so that they are not\n              undone when the\nexec\ncommand finishes.\n\n       exit [\nexitstatus\n]\n              terminate the shell process.  if\nexitstatus\nis given it is\n              used as the exit status of the shell; otherwise the exit\n              status of the preceding command is used.\n\n       export\nname ...\nexport\n-p\nthe specified names are exported so that they will appear\n              in the environment of subsequent commands.  the only way to\n              un-export a variable is to unset it.  the shell allows the\n              value of a variable to be set at the same time it is\n              exported by writing\nexport name=value\nwith no arguments the export command lists the names of all\n              exported variables.  with the\n-p\noption specified the\n              output will be formatted suitably for non-interactive use.\n\n       fc [\n-e\neditor\n] [\nfirst\n[\nlast\n]]\n\n       fc\n-l\n[\n-nr\n] [\nfirst\n[\nlast\n]]\n\n       fc\n-s\n[\nold=new\n] [\nfirst\n]\n              the\nfc\nbuiltin lists, or edits and re-executes, commands\n              previously entered to an interactive shell.\n-e\neditor\n                     use the editor named by editor to edit the commands.\n                     the editor string is a command name, subject to\n                     search via the path variable.  the value in the\n                     fcedit variable is used as a default when\n-e\nis not\n                     specified.  if fcedit is null or unset, the value of\n                     the editor variable is used.  if editor is null or\n                     unset,\ned\n(1) is used as the editor.\n-l\n(ell)\n                     list the commands rather than invoking an editor on\n                     them.  the commands are written in the sequence\n                     indicated by the first and last operands, as\n                     affected by\n-r\n, with each command preceded by the\n                     command number.\n-n\nsuppress command numbers when listing with -l.\n-r\nreverse the order of the commands listed (with\n-l\n)\n                     or edited (with neither\n-l\nnor\n-s\n).\n-s\nre-execute the command without invoking an editor.\n\n              first\n\n              last   select the commands to list or edit.  the number of\n                     previous commands that can be accessed are\n                     determined by the value of the histsize variable.\n                     the value of first or last or both are one of the\n                     following:\n\n                     [+]number\n                            a positive number representing a command\n                            number; command numbers can be displayed with\n                            the\n-l\noption.\n-number\na negative decimal number representing the\n                            command that was executed number of commands\n                            previously.  for example, -1 is the\n                            immediately previous command.\n\n              string\n                     a string indicating the most recently entered\n                     command that begins with that string.  if the\n                     old=new operand is not also specified with\n-s\n, the\n                     string form of the first operand cannot contain an\n                     embedded equal sign.\n\n              the following environment variables affect the execution of\n              fc:\n\n              fcedit    name of the editor to use.\n\n              histsize  the number of previous commands that are\n                        accessible.\n\n       fg [\njob\n]\n              move the specified job or the current job to the\n              foreground.\n\n       getopts\noptstring var\n[\narg ...\n]\n              the posix\ngetopts\ncommand, not to be confused with the\nbell\nlabs\n-derived\ngetopt\n(1).\n\n              the first argument should be a series of letters, each of\n              which may be optionally followed by a colon to indicate\n              that the option requires an argument.  the variable\n              specified is set to the parsed option.\n\n              the\ngetopts\ncommand deprecates the older\ngetopt\n(1) utility\n              due to its handling of arguments containing whitespace.\n\n              the\ngetopts\nbuiltin may be used to obtain options and their\n              arguments from a list of parameters.  when invoked,\ngetopts\nplaces the value of the next option from the option string\n              in the list in the shell variable specified by\nvar\nand its\n              index in the shell variable optind.  when the shell is\n              invoked, optind is initialized to 1.  for each option that\n              requires an argument, the\ngetopts\nbuiltin will place it in\n              the shell variable optarg.  if an option is not allowed for\n              in the\noptstring\n, then optarg will be unset.\n\n              by default, the variables\n$1\n,\n...\n,\n$n\nare inspected; if\narg\ns are specified, they'll be parsed instead.\noptstring\nis a string of recognized option letters (see\ngetopt\n(3)).  if a letter is followed by a colon, the option\n              is expected to have an argument which may or may not be\n              separated from it by white space.  if an option character\n              is not found where expected,\ngetopts\nwill set the variable\nvar\nto a \u00e2\u0080\u009c?\u00e2\u0080\u009d;\ngetopts\nwill then unset optarg and write\n              output to standard error.  by specifying a colon as the\n              first character of\noptstring\nall errors will be ignored.\n\n              after the last option\ngetopts\nwill return a non-zero value\n              and set\nvar\nto \u00e2\u0080\u009c?\u00e2\u0080\u009d.\n\n              the following code fragment shows how one might process the\n              arguments for a command that can take the options [a] and\n              [b], and the option [c], which requires an argument.\n\n                    while getopts abc: f\n                    do\n                            case $f in\n                            a | b)  flag=$f;;\n                            c)      carg=$optarg;;\n                            \\?)     echo $usage; exit 1;;\n                            esac\n                    done\n                    shift $((optind - 1))\n\n              this code will accept any of the following as equivalent:\n\n                    cmd -acarg file file\n                    cmd -a -c arg file file\n                    cmd -carg -a file file\n                    cmd -a -carg -- file file\n\n       hash [\ncommand ...\n]\n\n       hash\n-r\nthe shell maintains a hash table which remembers the\n              locations of commands.  with no arguments whatsoever, the\nhash\ncommand prints out the contents of this table.\n              entries which have not been looked at since the last\ncd\ncommand are marked with an asterisk; it is possible for\n              these entries to be invalid.\n\n              with arguments, the\nhash\ncommand removes the specified\n              commands from the hash table (unless they are functions)\n              and then locates them.  the\n-r\noption causes the hash\n              command to delete all the entries in the hash table except\n              for functions.\n\n       jobs [\n-lp\n] [\njob ...\n]\n              display the status of all, or just the specified,\njob\ns:\n                   by default  display the job number, currency (\n+-\n)\n                               status, if any, the job state, and its\n                               shell command.\n-l\nalso output the pid of the group leader,\n                               and just the pid and shell commands of\n                               other members of the job.\n-p\ndisplay only leader pids, one per line.\n\n       kill [\n-s\nsigspec\n|\n-\nsignum\n|\n-\nsigspec\n] [\npid\n|\njob ...\n]\n              equivalent to\nkill\n(1), but a\njob\nspec may also be\n              specified.  signals can be either case-insensitive names\n              without sig prefixes or decimal numbers; the default is\n              term.\n\n       kill\n-l\n[\nsignum\n|\nexitstatus\n]\n              list available signal names without the sig prefix\n              (\nsigspec\ns).  if\nsignum\nspecified, display just the\nsigspec\nfor that signal.  if\nexitstatus\nspecified (>\n128\n), display\n              just the\nsigspec\nthat caused it.\n\n       pwd [\n-lp\n]\n              builtin command remembers what the current directory is\n              rather than recomputing it each time.  this makes it\n              faster.  however, if the current directory is renamed, the\n              builtin version of\npwd\nwill continue to print the old name\n              for the directory.  the\n-p\noption causes the physical value\n              of the current working directory to be shown, that is, all\n              symbolic links are resolved to their respective values.\n              the\n-l\noption turns off the effect of any preceding\n-p\noptions.\n\n       read [\n-p\nprompt\n] [\n-r\n]\nvariable\n[\n...\n]\n              the prompt is printed if the\n-p\noption is specified and the\n              standard input is a terminal.  then a line is read from the\n              standard input.  the trailing newline is deleted from the\n              line and the line is split as described in the section on\n              word splitting above, and the pieces are assigned to the\n              variables in order.  at least one variable must be\n              specified.  if there are more pieces than variables, the\n              remaining pieces (along with the characters in ifs that\n              separated them) are assigned to the last variable.  if\n              there are more variables than pieces, the remaining\n              variables are assigned the null string.  the\nread\nbuiltin\n              will indicate success unless eof is encountered on input,\n              in which case failure is returned.\n\n              by default, unless the\n-r\noption is specified, the\n              backslash \u00e2\u0080\u009c\\\u00e2\u0080\u009d acts as an escape character, causing the\n              following character to be treated literally.  if a\n              backslash is followed by a newline, the backslash and the\n              newline will be deleted.\n\n       readonly\nname ...\nreadonly\n-p\nthe specified names are marked as read only, so that they\n              cannot be subsequently modified or unset.  the shell allows\n              the value of a variable to be set at the same time it is\n              marked read only by writing\nreadonly name=value\nwith no arguments the readonly command lists the names of\n              all read only variables.  with the\n-p\noption specified the\n              output will be formatted suitably for non-interactive use.\n\n       printf\nformat\n[\nvalue\n]...\nprintf\nformats and prints its arguments according to\nformat\n, a character string which contains three types of\n              objects: plain characters, which are simply copied to\n              standard output, character escape sequences which are\n              converted and copied to the standard output, and format\n              specifications, each of which causes printing of the next\n              successive\nvalue\n.\n\n              each\nvalue\nis treated as a string if the corresponding\n              format specification is either\nb\n,\nc\n, or\ns\n; otherwise it is\n              evaluated as a c constant, with the following additions:\n\u00e2\u0080\u00a2\na leading plus or minus sign is allowed.\n\u00e2\u0080\u00a2\nif the leading character is a single or double\n                        quote, the value of the next byte.\n\n              the format string is reused as often as necessary until all\nvalue\ns are consumed.  any extra format specifications are\n              evaluated with zero or the null string.\n\n              character escape sequences are in backslash notation as\n              defined in ansi x3.159-1989 (\u00e2\u0080\u009cansi c89\u00e2\u0080\u009d).  the characters\n              and their meanings are as follows:\n\\a\nwrite a <bell> character.\n\\b\nwrite a <backspace> character.\n\\f\nwrite a <form-feed> character.\n\\n\nwrite a <new-line> character.\n\\r\nwrite a <carriage return> character.\n\\t\nwrite a <tab> character.\n\\v\nwrite a <vertical tab> character.\n\\\\\nwrite a backslash character.\n\\\nnum\nwrite an 8-bit character whose ascii value is\n                            the 1-, 2-, or 3-digit octal number\nnum\n.\n\n              each format specification is introduced by the percent\n              character (``%'').  the remainder of the format\n              specification includes, in the following order:\n\n              zero or more of the following flags:\n#\na `#' character specifying that the value\n                              should be printed in an ``alternative\n                              form''.  for\nb\n,\nc\n,\nd\n, and\ns\nformats, this\n                              option has no effect.  for the\no\nformat the\n                              precision of the number is increased to\n                              force the first character of the output\n                              string to a zero.  for the\nx\n(\nx\n) format, a\n                              non-zero result has the string\n0x\n(\n0x\n)\n                              prepended to it.  for\ne\n,\ne\n,\nf\n,\ng\n, and\ng\nformats, the result will always contain a\n                              decimal point, even if no digits follow the\n                              point (normally, a decimal point only\n                              appears in the results of those formats if\n                              a digit follows the decimal point).  for\ng\nand\ng\nformats, trailing zeros are not\n                              removed from the result as they would\n                              otherwise be.\n-\na minus sign `-' which specifies\nleft\nadjustment\nof the output in the indicated\n                              field;\n+\na `+' character specifying that there\n                              should always be a sign placed before the\n                              number when using signed formats.\n\n                      \u00e2\u0080\u0098 \u00e2\u0080\u0099     a space specifying that a blank should be\n                              left before a positive number for a signed\n                              format.  a `+' overrides a space if both\n                              are used;\n0\na zero `0' character indicating that zero-\n                              padding should be used rather than blank-\n                              padding.  a `-' overrides a `0' if both are\n                              used;\n\n              field width:\n                      an optional digit string specifying a\nfield width\n;\n                      if the output string has fewer characters than the\n                      field width it will be blank-padded on the left (or\n                      right, if the left-adjustment indicator has been\n                      given) to make up the field width (note that a\n                      leading zero is a flag, but an embedded zero is\n                      part of a field width);\n\n              precision:\n                      an optional period, \u00e2\u0080\u0098\n.\n\u00e2\u0080\u0099, followed by an optional\n                      digit string giving a\nprecision\nwhich specifies the\n                      number of digits to appear after the decimal point,\n                      for\ne\nand\nf\nformats, or the maximum number of bytes\n                      to be printed from a string (\nb\nand\ns\nformats); if\n                      the digit string is missing, the precision is\n                      treated as zero;\n\n              format:\n                      a character which indicates the type of format to\n                      use (one of\ndiouxxfweggbcs\n).\n\n              a field width or precision may be \u00e2\u0080\u0098\n*\n\u00e2\u0080\u0099 instead of a digit\n              string.  in this case an\nargument\nsupplies the field width\n              or precision.\n\n              the format characters and their meanings are:\ndiouxx\nthe\nargument\nis printed as a signed decimal (d\n                          or i), unsigned octal, unsigned decimal, or\n                          unsigned hexadecimal (x or x), respectively.\nf\nthe\nargument\nis printed in the style [-]ddd\n.\nddd\n                          where the number of d's after the decimal point\n                          is equal to the precision specification for the\n                          argument.  if the precision is missing, 6\n                          digits are given; if the precision is\n                          explicitly 0, no digits and no decimal point\n                          are printed.\nee\nthe\nargument\nis printed in the style\n                          [-]d\n.\nddd\ne\n\u00e2\u00b1dd where there is one digit before\n                          the decimal point and the number after is equal\n                          to the precision specification for the\n                          argument; when the precision is missing, 6\n                          digits are produced.  an upper-case e is used\n                          for an `e' format.\ngg\nthe\nargument\nis printed in style\nf\nor in style\ne\n(\ne\n) whichever gives full precision in minimum\n                          space.\nb\ncharacters from the string\nargument\nare printed\n                          with backslash-escape sequences expanded.\n                          the following additional backslash-escape\n                          sequences are supported:\n\\c\ncauses\ndash\nto ignore any remaining\n                                  characters in the string operand\n                                  containing it, any remaining string\n                                  operands, and any additional characters\n                                  in the format operand.\n\\0\nnum\nwrite an 8-bit character whose ascii\n                                  value is the 1-, 2-, or 3-digit octal\n                                  number\nnum\n.\nc\nthe first character of\nargument\nis printed.\ns\ncharacters from the string\nargument\nare printed\n                          until the end is reached or until the number of\n                          bytes indicated by the precision specification\n                          is reached; if the precision is omitted, all\n                          characters in the string are printed.\n%\nprint a `%'; no argument is used.\n\n              in no case does a non-existent or small field width cause\n              truncation of a field; padding takes place only if the\n              specified field width exceeds the actual width.\n\n       set [{\n-options\n|\n+options\n|\n-- }\n]\narg ...\nthe\nset\ncommand performs three different functions.\n\n              with no arguments, it lists the values of all shell\n              variables.\n\n              if options are given, it sets the specified option flags,\n              or clears them as described in the section called \u00e2\u0080\u009cargument\n              list processing\u00e2\u0080\u009d.  as a special case, if the option is -o\n              or +o and no argument is supplied, the shell prints the\n              settings of all its options.  if the option is -o, the\n              settings are printed in a human-readable format; if the\n              option is +o, the settings are printed in a format suitable\n              for reinput to the shell to affect the same option\n              settings.\n\n              in addition to the option names listed in the \u00e2\u0080\u009cargument\n              list processing\u00e2\u0080\u009d section, the following options may be\n              specified as arguments to -o or +o:\npipefail\nderive the exit status of a pipeline from the\n                        exit statuses of all of the commands in the\n                        pipeline, not just the last command, as described\n                        in the \u00e2\u0080\u009cpipelines\u00e2\u0080\u009d section.\n\n              the third use of the set command is to set the values of\n              the shell's positional parameters to the specified args.\n              to change the positional parameters without changing any\n              options, use \u00e2\u0080\u009c--\u00e2\u0080\u009d as the first argument to set.  if no args\n              are present, the set command will clear all the positional\n              parameters (equivalent to executing \u00e2\u0080\u009cshift $#\u00e2\u0080\u009d.)\n\n       shift [\nn\n]\n              shift the positional parameters n times.  a\nshift\nsets the\n              value of\n$1\nto the value of\n$2\n, the value of\n$2\nto the\n              value of\n$3\n, and so on, decreasing the value of\n$#\nby one.\n              if n is greater than the number of positional parameters,\nshift\nwill issue an error message, and exit with return\n              status 2.\n\n       test\nexpression\n[\nexpression\n]\nthe\ntest\nutility evaluates the expression and, if it\n              evaluates to true, returns a zero (true) exit status;\n              otherwise it returns 1 (false).  if there is no expression,\n              test also returns 1 (false).\n\n              all operators and flags are separate arguments to the\ntest\nutility.\n\n              the following primaries are used to construct expression:\n-b\nfile\ntrue if\nfile\nexists and is a block special\n                            file.\n-c\nfile\ntrue if\nfile\nexists and is a character\n                            special file.\n-d\nfile\ntrue if\nfile\nexists and is a directory.\n-e\nfile\ntrue if\nfile\nexists (regardless of type).\n-f\nfile\ntrue if\nfile\nexists and is a regular file.\n-g\nfile\ntrue if\nfile\nexists and its set group id flag\n                            is set.\n-h\nfile\ntrue if\nfile\nexists and is a symbolic link.\n-k\nfile\ntrue if\nfile\nexists and its sticky bit is\n                            set.\n-n\nstring\ntrue if the length of\nstring\nis nonzero.\n-p\nfile\ntrue if\nfile\nis a named pipe (fifo).\n-r\nfile\ntrue if\nfile\nexists and is readable.\n-s\nfile\ntrue if\nfile\nexists and has a size greater\n                            than zero.\n-t\nfile_descriptor\ntrue if the file whose file descriptor number\n                            is\nfile_descriptor\nis open and is associated\n                            with a terminal.\n-u\nfile\ntrue if\nfile\nexists and its set user id flag\n                            is set.\n-w\nfile\ntrue if\nfile\nexists and is writable.  true\n                            indicates only that the write flag is on.\n                            the file is not writable on a read-only file\n                            system even if this test indicates true.\n-x\nfile\ntrue if\nfile\nexists and is executable.  true\n                            indicates only that the execute flag is on.\n                            if\nfile\nis a directory, true indicates that\nfile\ncan be searched.\n-z\nstring\ntrue if the length of\nstring\nis zero.\n-l\nfile\ntrue if\nfile\nexists and is a symbolic link.\n                            this operator is retained for compatibility\n                            with previous versions of this program.  do\n                            not rely on its existence; use\n-h\ninstead.\n-o\nfile\ntrue if\nfile\nexists and its owner matches the\n                            effective user id of this process.\n-g\nfile\ntrue if\nfile\nexists and its group matches the\n                            effective group id of this process.\n-s\nfile\ntrue if\nfile\nexists and is a socket.\nfile1\n-nt\nfile2\ntrue if\nfile1\nand\nfile2\nexist and\nfile1\nis\n                            newer than\nfile2\n, or if\nfile1\nexists but\nfile2\ndoesn't.\nfile1\n-ot\nfile2\ntrue if\nfile1\nand\nfile2\nexist and\nfile1\nis\n                            older than\nfile2\n, or if\nfile2\nexists but\nfile1\ndoesn't.\nfile1\n-ef\nfile2\ntrue if\nfile1\nand\nfile2\nexist and refer to\n                            the same file.\nstring\ntrue if\nstring\nis not the null string.\ns1\n=\ns2\ntrue if the strings\ns1\nand\ns2\nare identical.\ns1\n!=\ns2\ntrue if the strings\ns1\nand\ns2\nare not\n                            identical.\ns1\n<\ns2\ntrue if string\ns1\ncomes before\ns2\nbased on\n                            the ascii value of their characters.\ns1\n>\ns2\ntrue if string\ns1\ncomes after\ns2\nbased on the\n                            ascii value of their characters.\nn1\n-eq\nn2\ntrue if the integers\nn1\nand\nn2\nare\n                            algebraically equal.\nn1\n-ne\nn2\ntrue if the integers\nn1\nand\nn2\nare not\n                            algebraically equal.\nn1\n-gt\nn2\ntrue if the integer\nn1\nis algebraically\n                            greater than the integer\nn2\n.\nn1\n-ge\nn2\ntrue if the integer\nn1\nis algebraically\n                            greater than or equal to the integer\nn2\n.\nn1\n-lt\nn2\ntrue if the integer\nn1\nis algebraically less\n                            than the integer\nn2\n.\nn1\n-le\nn2\ntrue if the integer\nn1\nis algebraically less\n                            than or equal to the integer\nn2\n.\n\n              these primaries can be combined with the following\n              operators:\n!\nexpression\ntrue if\nexpression\nis false.\nexpression1\n-a\nexpression2\ntrue if both\nexpression1\nand\nexpression2\nare\n                            true.\nexpression1\n-o\nexpression2\ntrue if either\nexpression1\nor\nexpression2\nare\n                            true.\n(\nexpression\n)\ntrue if expression is true.\n\n              the\n-a\noperator has higher precedence than the\n-o\noperator.\n\n       times  print the accumulated user and system times for the shell\n              and for processes run from the shell.  the return status is\n              0.\n\n       trap [\naction signal ...\n]\n              cause the shell to parse and execute action when any of the\n              specified signals are received.  the signals are specified\n              by signal number or as the name of the signal.  if\nsignal\nis\n0\nor\nexit\n, the action is executed when the shell exits\n              normally (that is not via an unhandled signal like sigint).\naction\nmay be empty (\n''\n), which causes the specified\n              signals to be ignored.  with\naction\nomitted or set to `-'\n              the specified signals are set to their default action.\n              when the shell forks off a subshell, it resets trapped (but\n              not ignored) signals to the default action.  the\ntrap\ncommand has no effect on signals that were ignored on entry\n              to the shell.\ntrap\nwithout any arguments cause it to write\n              a list of signals and their associated action to the\n              standard output in a format that is suitable as an input to\n              the shell that achieves the same trapping results.\n\n              examples:\ntrap\nlist trapped signals and their corresponding action\ntrap '' int quit tstp 30\nignore signals int quit tstp usr1\ntrap date int\nprint date upon receiving signal int\n\n       type [\nname ...\n]\n              interpret each name as a command and print the resolution\n              of the command search.  possible resolutions are: shell\n              keyword, alias, shell builtin, command, tracked alias and\n              not found.  for aliases the alias expansion is printed; for\n              commands and tracked aliases the complete pathname of the\n              command is printed.\n\n       ulimit [\n-h\n|\n-s\n] [\n-a\n|\n-tfdscmlpnvwr\n[\nvalue\n]]\n              inquire about or set the hard or soft limits on processes\n              or set new limits.  the choice between hard limit (which no\n              process is allowed to violate, and which may not be raised\n              once it has been lowered) and soft limit (which causes\n              processes to be signaled but not necessarily killed, and\n              which may be raised) is made with these flags:\n-h\nset or inquire about hard limits\n-s\nset or inquire about soft limits.  if neither\n-h\nnor\n-s\nis specified, the soft limit is\n                          displayed or both limits are set.  if both are\n                          specified, the last one wins.\n\n              the limit to be interrogated or set, then, is chosen by\n              specifying any one of these flags:\n-a\nshow all the current limits\n-t\nshow or set the limit on cpu time (in seconds)\n-f\nshow or set the limit on the largest file that\n                          can be created (in 512-byte blocks)\n-d\nshow or set the limit on the data segment size\n                          of a process (in kilobytes)\n-s\nshow or set the limit on the stack size of a\n                          process (in kilobytes)\n-c\nshow or set the limit on the largest core dump\n                          size that can be produced (in 512-byte blocks)\n-m\nshow or set the limit on the total physical\n                          memory that can be in use by a process (in\n                          kilobytes)\n-l\nshow or set the limit on how much memory a\n                          process can lock with\nmlock\n(2) (in kilobytes)\n-p\nshow or set the limit on the number of\n                          processes this user can have at one time\n-n\nshow or set the limit on the number files a\n                          process can have open at once\n-v\nshow or set the limit on the total virtual\n                          memory that can be in use by a process (in\n                          kilobytes)\n-w\nshow or set the limit on the total number of\n                          locks held by a process\n-r\nshow or set the limit on the real-time\n                          scheduling priority of a process\n\n              if none of these is specified, it is the limit on file size\n              that is shown or set.  if\nvalue\nis specified, the limit is\n              set to that number; otherwise the current limit is\n              displayed.  the special\nvalue\nunlimited\nrepresents the lack\n              of any limit.\n\n              limits of an arbitrary process can be displayed or set\n              using the\nsysctl\n(8) utility.\n\n       umask [\nmask\n]\n              set the value of umask (see\numask\n(2)) to the specified\n              octal value.  if the argument is omitted, the umask value\n              is printed.\n\n       unalias [\n-a\n] [\nname\n]\n              if\nname\nis specified, the shell removes that alias.  if\n-a\nis specified, all aliases are removed.\n\n       unset [\n-fv\n]\nname ...\nthe specified variables and functions are unset and\n              unexported.  if\n-f\nor\n-v\nis specified, the corresponding\n              function or variable is unset, respectively.  if a given\n              name corresponds to both a variable and a function, and no\n              options are given, only the variable is unset.\n\n       wait [\njob\n]\n              wait for the specified job to complete and return the exit\n              status of the last process in the job.  if the argument is\n              omitted, wait for all jobs to complete and return an exit\n              status of zero.\ncommand line editing\nwhen\ndash\nis being used interactively from a terminal, the current\n       command and the command history (see\nfc\nin \u00e2\u0080\u009cbuiltins\u00e2\u0080\u009d) can be\n       edited using vi-mode command-line editing.  this mode uses\n       commands, described below, similar to a subset of those described\n       in the vi man page.  the command \u00e2\u0080\u0098set -o vi\u00e2\u0080\u0099 enables vi-mode\n       editing and places sh into vi insert mode.  with vi-mode enabled,\n       sh can be switched between insert mode and command mode.  it is\n       similar to vi: typing \u00e2\u009f\u00a8esc\u00e2\u009f\u00a9 enters vi command mode.  hitting\n       \u00e2\u009f\u00a8return\u00e2\u009f\u00a9 while in command mode will pass the line to the shell.",
      "examples": "",
      "options": ""
    },
    {
      "command": "top",
      "description": "the\ntop\nprogram provides a dynamic real-time view of a running\n       system.  it can display\nsystem\nsummary information as well as a\n       list of\nprocesses\nor\nthreads\ncurrently being managed by the linux\n       kernel.  the types of system summary information shown and the\n       types, order and size of information displayed for processes are\n       all user configurable and that configuration can be made\n       persistent across restarts.\n\n       the program provides a limited interactive interface for process\n       manipulation as well as a much more extensive interface for\n       personal configuration  --  encompassing every aspect of its\n       operation.  and while\ntop\nis referred to throughout this document,\n       you are free to name the program anything you wish.  that new\n       name, possibly an alias, will then be reflected on top's display\n       and used when reading and writing a configuration file.",
      "examples": "",
      "options": ""
    }
  ],
  "context": "Retrieved commands:\n\nCommand: systemd-analyze\nDescription: systemd-analyze\nmay be used to determine system boot-up\n       performance statistics and retrieve other state and tracing\n       information from the system and service manager, and to verify the\n       correctness of unit files. it is also used to access special\n       functions useful for advanced system manager debugging.\n\n       if no command is passed,\nsystemd-analyze time\nis implied.\nsystemd-analyze time\nthis command prints the time spent in the kernel before userspace\n       has been reached, the time spent in the initrd before normal\n       system userspace has been reached, and the time normal system\n       userspace took to initialize. note that these measurements simply\n       measure the time passed up to the point where all system services\n       have been spawned, but not necessarily until they fully finished\n       initialization or the disk is idle.\nexample 1. show how long the boot took\n# in a container\n           $ systemd-analyze time\n           startup finished in 296ms (userspace)\n           multi-user.target reached after 275ms in userspace\n\n           # on a real machine\n           $ systemd-analyze time\n           startup finished in 2.584s (kernel) + 19.176s (initrd) + 47.847s (userspace) = 1min 9.608s\n           multi-user.target reached after 47.820s in userspace\nsystemd-analyze blame\nthis command prints a list of all running units, ordered by the\n       time they took to initialize. this information may be used to\n       optimize boot-up times. note that the output might be misleading\n       as the initialization of one service might be slow simply because\n       it waits for the initialization of another service to complete.\n       also note:\nsystemd-analyze blame\ndoes not display results for\n       services with\ntype=simple\n, because systemd considers such services\n       to be started immediately, hence no measurement of the\n       initialization delays can be done. also note that this command\n       only shows the time units took for starting up, it does not show\n       how long unit jobs spent in the execution queue. in particular it\n       shows the time units spent in \"activating\" state, which is not\n       defined for units such as device units that transition directly\n       from \"inactive\" to \"active\". this command hence gives an\n       impression of the performance of program code, but cannot\n       accurately reflect latency introduced by waiting for hardware and\n       similar events.\nexample 2. show which units took the most time during boot\n$ systemd-analyze blame\n                    32.875s pmlogger.service\n                    20.905s systemd-networkd-wait-online.service\n                    13.299s dev-vda1.device\n                    ...\n                       23ms sysroot.mount\n                       11ms initrd-udevadm-cleanup-db.service\n                        3ms sys-kernel-config.mount\nsystemd-analyze critical-chain [\nunit\n...]\n       this command prints a tree of the time-critical chain of units\n       (for each of the specified\nunit\ns or for the default target\n       otherwise). the time after the unit is active or started is\n       printed after the \"@\" character. the time the unit takes to start\n       is printed after the \"+\" character. note that the output might be\n       misleading as the initialization of services might depend on\n       socket activation and because of the parallel execution of units.\n       also, similarly to the\nblame\ncommand, this only takes into account\n       the time units spent in \"activating\" state, and hence does not\n       cover units that never went through an \"activating\" state (such as\n       device units that transition directly from \"inactive\" to\n       \"active\"). moreover, it does not show information on jobs (and in\n       particular not jobs that timed out).\nexample 3. systemd-analyze critical-chain\n$ systemd-analyze critical-chain\n           multi-user.target @47.820s\n           \u00e2\u0094\u0094\u00e2\u0094\u0080pmie.service @35.968s +548ms\n             \u00e2\u0094\u0094\u00e2\u0094\u0080pmcd.service @33.715s +2.247s\n               \u00e2\u0094\u0094\u00e2\u0094\u0080network-online.target @33.712s\n                 \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd-wait-online.service @12.804s +20.905s\n                   \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd.service @11.109s +1.690s\n                     \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-udevd.service @9.201s +1.904s\n                       \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-tmpfiles-setup-dev.service @7.306s +1.776s\n                         \u00e2\u0094\u0094\u00e2\u0094\u0080kmod-static-nodes.service @6.976s +177ms\n                           \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-journald.socket\n                             \u00e2\u0094\u0094\u00e2\u0094\u0080system.slice\n                               \u00e2\u0094\u0094\u00e2\u0094\u0080-.slice\nsystemd-analyze dump [\npattern\n...]\n       without any parameter, this command outputs a (usually very long)\n       human-readable serialization of the complete service manager\n       state. optional glob pattern may be specified, causing the output\n       to be limited to units whose names match one of the patterns. the\n       output format is subject to change without notice and should not\n       be parsed by applications. this command is rate limited for\n       unprivileged users.\nexample 4. show the internal state of user manager\n$ systemd-analyze --user dump\n           timestamp userspace: thu 2019-03-14 23:28:07 cet\n           timestamp finish: thu 2019-03-14 23:28:07 cet\n           timestamp generators-start: thu 2019-03-14 23:28:07 cet\n           timestamp generators-finish: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-start: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-finish: thu 2019-03-14 23:28:07 cet\n           -> unit proc-timer_list.mount:\n                   description: /proc/timer_list\n                   ...\n           -> unit default.target:\n                   description: main user target\n           ...\nsystemd-analyze malloc [\nd-bus service\n...]\n       this command can be used to request the output of the internal\n       memory state (as returned by\nmalloc_info(3)\n) of a d-bus service.\n       if no service is specified, the query will be sent to\n       org.freedesktop.systemd1 (the system or user service manager). the\n       output format is not guaranteed to be stable and should not be\n       parsed by applications.\n\n       the service must implement the org.freedesktop.memoryallocation1\n       interface. in the systemd suite, it is currently only implemented\n       by the manager.\nsystemd-analyze plot\nthis command prints either an svg graphic, detailing which system\n       services have been started at what time, highlighting the time\n       they spent on initialization, or the raw time data in json or\n       table format.\nexample 5. plot a bootchart\n$ systemd-analyze plot >bootup.svg\n           $ eog bootup.svg&\n\n       note that this plot is based on the most recent per-unit timing\n       data of loaded units. this means that if a unit gets started, then\n       stopped and then started again the information shown will cover\n       the most recent start cycle, not the first one. thus it is\n       recommended to consult this information only shortly after boot,\n       so that this distinction does not matter. moreover, units that are\n       not referenced by any other unit through a dependency might be\n       unloaded by the service manager once they terminate (and did not\n       fail). such units will not show up in the plot.\nsystemd-analyze dot [\npattern\n...]\n       this command generates textual dependency graph description in dot\n       format for further processing with the graphviz\ndot\n(1) tool. use a\n       command line like\nsystemd-analyze dot | dot -tsvg >systemd.svg\nto\n       generate a graphical dependency tree. unless\n--order\nor\n--require\nis passed, the generated graph will show both ordering and\n       requirement dependencies. optional pattern globbing style\n       specifications (e.g.  *.target) may be given at the end. a unit\n       dependency is included in the graph if any of these patterns match\n       either the origin or destination node.\nexample 6. plot all dependencies of any unit whose name starts\nwith \"avahi-daemon\"\n$ systemd-analyze dot 'avahi-daemon.*' | dot -tsvg >avahi.svg\n           $ eog avahi.svg\nexample 7. plot the dependencies between all known target units\n$ systemd-analyze dot --to-pattern='*.target' --from-pattern='*.target' \\\n                 | dot -tsvg >targets.svg\n           $ eog targets.svg\nsystemd-analyze unit-paths\nthis command outputs a list of all directories from which unit\n       files, .d overrides, and .wants, .requires symlinks may be loaded.\n       combine with\n--user\nto retrieve the list for the user manager\n       instance, and\n--global\nfor the global configuration of user\n       manager instances.\nexample 8. show all paths for generated units\n$ systemd-analyze unit-paths | grep '^/run'\n           /run/systemd/system.control\n           /run/systemd/transient\n           /run/systemd/generator.early\n           /run/systemd/system\n           /run/systemd/system.attached\n           /run/systemd/generator\n           /run/systemd/generator.late\n\n       note that this verb prints the list that is compiled into\nsystemd-analyze\nitself, and does not communicate with the running\n       manager. use\n\n           systemctl [--user] [--global] show -p unitpath --value\n\n       to retrieve the actual list that the manager uses, with any empty\n       directories omitted.\nsystemd-analyze exit-status [\nstatus\n...]\n       this command prints a list of exit statuses along with their\n       \"class\", i.e. the source of the definition (one of \"glibc\",\n       \"systemd\", \"lsb\", or \"bsd\"), see the process exit codes section in\nsystemd.exec(5)\n. if no additional arguments are specified, all\n       known statuses are shown. otherwise, only the definitions for the\n       specified codes are shown.\nexample 9. show some example exit status names\n$ systemd-analyze exit-status 0 1 {63..65}\n           name    status class\n           success 0      glibc\n           failure 1      glibc\n           -       63     -\n           usage   64     bsd\n           dataerr 65     bsd\nsystemd-analyze capability [\ncapability\n... | {-m | --mask}\nmask\n]\n       this command prints a list of linux capabilities along with their\n       numeric ids. see\ncapabilities(7)\nfor details. if no argument is\n       specified the full list of capabilities known to the service\n       manager and the kernel is shown. capabilities defined by the\n       kernel but not known to the service manager are shown as\n       \"cap_???\". optionally, if arguments are specified they may refer\n       to specific cabilities by name or numeric id, in which case only\n       the indicated capabilities are shown in the table.\n\n       alternatively, if\n--mask\nis passed, a single numeric argument must\n       be specified, which is interpreted as a hexadecimal capability\n       mask. in this case, only the capabilities present in the mask are\n       shown in the table. this mode is intended to aid in decoding\n       capability sets available via various debugging interfaces (e.g.\n       \"/proc/pid/status\").\nexample 10. show some example capability names\n$ systemd-analyze capability 0 1 {30..32}\n           name              number\n           cap_chown              0\n           cap_dac_override       1\n           cap_audit_control     30\n           cap_setfcap           31\n           cap_mac_override      32\nexample 11. decode a capability mask extracted from /proc\n$ systemd-analyze capability -m 0000000000003c00\n           name                 number\n           cap_net_bind_service     10\n           cap_net_broadcast        11\n           cap_net_admin            12\n           cap_net_raw              13\nsystemd-analyze condition\ncondition\n...\n       this command will evaluate\ncondition*=...\nand\nassert*=...\nassignments, and print their values, and the resulting value of\n       the combined condition set. see\nsystemd.unit(5)\nfor a list of\n       available conditions and asserts.\nexample 12. evaluate conditions that check kernel versions\n$ systemd-analyze condition 'conditionkernelversion = ! <4.0' \\\n                   'conditionkernelversion = >=5.1' \\\n                   'conditionacpower=|false' \\\n                   'conditionarchitecture=|!arm' \\\n                   'assertpathexists=/etc/os-release'\n           test.service: assertpathexists=/etc/os-release succeeded.\n           asserts succeeded.\n           test.service: conditionarchitecture=|!arm succeeded.\n           test.service: conditionacpower=|false failed.\n           test.service: conditionkernelversion=>=5.1 succeeded.\n           test.service: conditionkernelversion=!<4.0 succeeded.\n           conditions succeeded.\nsystemd-analyze syscall-filter [\nset\n...]\n       this command will list system calls contained in the specified\n       system call set\nset\n, or all known sets if no sets are specified.\n       argument\nset\nmust include the \"@\" prefix.\nsystemd-analyze filesystems [\nset\n...]\n       this command will list filesystems in the specified filesystem set\nset\n, or all known sets if no sets are specified. argument\nset\nmust\n       include the \"@\" prefix.\nsystemd-analyze calendar\nexpression\n...\n       this command will parse and normalize repetitive calendar time\n       events, and will calculate when they elapse next. this takes the\n       same input as the\noncalendar=\nsetting in\nsystemd.timer(5)\n,\n       following the syntax described in\nsystemd.time(7)\n. by default,\n       only the next time the calendar expression will elapse is shown;\n       use\n--iterations=\nto show the specified number of next times the\n       expression elapses. each time the expression elapses forms a\n       timestamp, see the\ntimestamp\nverb below.\nexample 13. show leap days in the near future\n$ systemd-analyze calendar --iterations=5 '*-2-29 0:0:0'\n             original form: *-2-29 0:0:0\n           normalized form: *-02-29 00:00:00\n               next elapse: sat 2020-02-29 00:00:00 utc\n                  from now: 11 months 15 days left\n                  iter. #2: thu 2024-02-29 00:00:00 utc\n                  from now: 4 years 11 months left\n                  iter. #3: tue 2028-02-29 00:00:00 utc\n                  from now: 8 years 11 months left\n                  iter. #4: sun 2032-02-29 00:00:00 utc\n                  from now: 12 years 11 months left\n                  iter. #5: fri 2036-02-29 00:00:00 utc\n                  from now: 16 years 11 months left\nsystemd-analyze timestamp\ntimestamp\n...\n       this command parses a timestamp (i.e. a single point in time) and\n       outputs the normalized form and the difference between this\n       timestamp and now. the timestamp should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing timestamps\".\nexample 14. show parsing of timestamps\n$ systemd-analyze timestamp yesterday now tomorrow\n             original form: yesterday\n           normalized form: mon 2019-05-20 00:00:00 cest\n                  (in utc): sun 2019-05-19 22:00:00 utc\n              unix seconds: @15583032000\n                  from now: 1 day 9h ago\n\n             original form: now\n           normalized form: tue 2019-05-21 09:48:39 cest\n                  (in utc): tue 2019-05-21 07:48:39 utc\n              unix seconds: @1558424919.659757\n                  from now: 43us ago\n\n             original form: tomorrow\n           normalized form: wed 2019-05-22 00:00:00 cest\n                  (in utc): tue 2019-05-21 22:00:00 utc\n              unix seconds: @15584760000\n                  from now: 14h left\nsystemd-analyze timespan\nexpression\n...\n       this command parses a time span (i.e. a difference between two\n       timestamps) and outputs the normalized form and the equivalent\n       value in microseconds. the time span should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing time spans\".\n       values without units are parsed as seconds.\nexample 15. show parsing of timespans\n$ systemd-analyze timespan 1s 300s '1year 0.000001s'\n           original: 1s\n                 \u00ee\u00bcs: 1000000\n              human: 1s\n\n           original: 300s\n                 \u00ee\u00bcs: 300000000\n              human: 5min\n\n           original: 1year 0.000001s\n                 \u00ee\u00bcs: 31557600000001\n              human: 1y 1us\nsystemd-analyze cat-config\nname\n|\npath\n...\n       this command is similar to\nsystemctl cat\n, but operates on config\n       files. it will copy the contents of a config file and any drop-ins\n       to standard output, using the usual systemd set of directories and\n       rules for precedence. each argument must be either an absolute\n       path including the prefix (such as /etc/systemd/logind.conf or\n       /usr/lib/systemd/logind.conf), or a name relative to the prefix\n       (such as systemd/logind.conf).\nexample 16. showing logind configuration\n$ systemd-analyze cat-config systemd/logind.conf\n           # /etc/systemd/logind.conf\n           ...\n           [login]\n           nautovts=8\n           ...\n\n           # /usr/lib/systemd/logind.conf.d/20-test.conf\n           ... some override from another package\n\n           # /etc/systemd/logind.conf.d/50-override.conf\n           ... some administrator override\nsystemd-analyze compare-versions\nversion1\n[\nop\n]\nversion2\nthis command has two distinct modes of operation, depending on\n       whether the operator\nop\nis specified.\n\n       in the first mode \u00e2\u0080\u0094 when\nop\nis not specified \u00e2\u0080\u0094, it will compare\n       the two version strings and print either \"\nversion1\n<\nversion2\n\", or\n       \"\nversion1\n==\nversion2\n\", or \"\nversion1\n>\nversion2\n\" as appropriate.\n\n       the exit status is\n0\nif the versions are equal,\n11\nif the version\n       of the right is smaller, and\n12\nif the version of the left is\n       smaller. (this matches the convention used by\nrpmdev-vercmp\n.)\n\n       in the second mode \u00e2\u0080\u0094 when\nop\nis specified \u00e2\u0080\u0094 it will compare the\n       two version strings using the operation\nop\nand return\n0\n(success)\n       if they condition is satisfied, and\n1\n(failure) otherwise.\nop\nmay\n       be\nlt\n,\nle\n,\neq\n,\nne\n,\nge\n,\ngt\n. in this mode, no output is printed.\n       (this matches the convention used by\ndpkg(1)\n--compare-versions\n.)\nexample 17. compare versions of a package\n$ systemd-analyze compare-versions systemd-250~rc1.fc36.aarch64 systemd-251.fc36.aarch64\n           systemd-250~rc1.fc36.aarch64 < systemd-251.fc36.aarch64\n           $ echo $?\n           12\n\n           $ systemd-analyze compare-versions 1 lt 2; echo $?\n           0\n           $ systemd-analyze compare-versions 1 ge 2; echo $?\n           1\nsystemd-analyze verify\nfile\n...\n       this command will load unit files and print warnings if any errors\n       are detected. files specified on the command line will be loaded,\n       but also any other units referenced by them. a unit's name on disk\n       can be overridden by specifying an alias after a colon; see below\n       for an example. the full unit search path is formed by combining\n       the directories for all command line arguments, and the usual unit\n       load paths. the variable\n$systemd_unit_path\nis supported, and may\n       be used to replace or augment the compiled in set of unit load\n       paths; see\nsystemd.unit(5)\n. all units files present in the\n       directories containing the command line arguments will be used in\n       preference to the other paths. if a template unit without an\n       instance name is specified (e.g.  foo@.service), \"test_instance\"\n       will be used as the instance name, which can be controlled by\n--instance=\noption.\n\n       the following errors are currently detected:\n\n       \u00e2\u0080\u00a2   unknown sections and directives,\n\n       \u00e2\u0080\u00a2   missing dependencies which are required to start the given\n           unit,\n\n       \u00e2\u0080\u00a2   man pages listed in\ndocumentation=\nwhich are not found in the\n           system,\n\n       \u00e2\u0080\u00a2   commands listed in\nexecstart=\nand similar which are not found\n           in the system or not executable.\nexample 18. misspelt directives\n$ cat ./user.slice\n           [unit]\n           whatisthis=11\n           documentation=man:nosuchfile(1)\n           requires=different.service\n\n           [service]\n           description=x\n\n           $ systemd-analyze verify ./user.slice\n           [./user.slice:9] unknown lvalue 'whatisthis' in section 'unit'\n           [./user.slice:13] unknown section 'service'. ignoring.\n           error: org.freedesktop.systemd1.loadfailed:\n              unit different.service failed to load:\n              no such file or directory.\n           failed to create user.slice/start: invalid argument\n           user.slice: man nosuchfile(1) command failed with code 16\nexample 19. missing service units\n$ tail ./a.socket ./b.socket\n           ==> ./a.socket <==\n           [socket]\n           listenstream=100\n\n           ==> ./b.socket <==\n           [socket]\n           listenstream=100\n           accept=yes\n\n           $ systemd-analyze verify ./a.socket ./b.socket\n           service a.service not loaded, a.socket cannot be started.\n           service b@0.service not loaded, b.socket cannot be started.\nexample 20. aliasing a unit\n$ cat /tmp/source\n           [unit]\n           description=hostname printer\n\n           [service]\n           type=simple\n           execstart=/usr/bin/echo %h\n           mysterykey=true\n\n           $ systemd-analyze verify /tmp/source\n           failed to prepare filename /tmp/source: invalid argument\n\n           $ systemd-analyze verify /tmp/source:alias.service\n           alias.service:7: unknown key name 'mysterykey' in section 'service', ignoring.\nsystemd-analyze security [\nunit\n...]\n       this command analyzes the security and sandboxing settings of one\n       or more specified service units. if at least one unit name is\n       specified the security settings of the specified service units are\n       inspected and a detailed analysis is shown. if no unit name is\n       specified, all currently loaded, long-running service units are\n       inspected and a terse table with results shown. the command checks\n       for various security-related service settings, assigning each a\n       numeric \"exposure level\" value, depending on how important a\n       setting is. it then calculates an overall exposure level for the\n       whole unit, which is an estimation in the range 0.0...10.0\n       indicating how exposed a service is security-wise. high exposure\n       levels indicate very little applied sandboxing. low exposure\n       levels indicate tight sandboxing and strongest security\n       restrictions. note that this only analyzes the per-service\n       security features systemd itself implements. this means that any\n       additional security mechanisms applied by the service code itself\n       are not accounted for. the exposure level determined this way\n       should not be misunderstood: a high exposure level neither means\n       that there is no effective sandboxing applied by the service code\n       itself, nor that the service is actually vulnerable to remote or\n       local attacks. high exposure levels do indicate however that most\n       likely the service might benefit from additional settings applied\n       to them.\n\n       please note that many of the security and sandboxing settings\n       individually can be circumvented \u00e2\u0080\u0094 unless combined with others.\n       for example, if a service retains the privilege to establish or\n       undo mount points many of the sandboxing options can be undone by\n       the service code itself. due to that is essential that each\n       service uses the most comprehensive and strict sandboxing and\n       security settings possible. the tool will take into account some\n       of these combinations and relationships between the settings, but\n       not all. also note that the security and sandboxing settings\n       analyzed here only apply to the operations executed by the service\n       code itself. if a service has access to an ipc system (such as\n       d-bus) it might request operations from other services that are\n       not subject to the same restrictions. any comprehensive security\n       and sandboxing analysis is hence incomplete if the ipc access\n       policy is not validated too.\nexample 21. analyze systemd-logind.service\n$ systemd-analyze security --no-pager systemd-logind.service\n             name                description                              exposure\n           \u00e2\u009c\u0097 privatenetwork=     service has access to the host's network      0.5\n           \u00e2\u009c\u0097 user=/dynamicuser=  service runs as root user                     0.4\n           \u00e2\u009c\u0097 deviceallow=        service has no device acl                     0.2\n           \u00e2\u009c\u0093 ipaddressdeny=      service blocks all ip address ranges\n           ...\n           \u00e2\u0086\u0092 overall exposure level for systemd-logind.service: 4.1 ok \u00f0\u009f\u0099\u0082\nsystemd-analyze inspect-elf\nfile\n...\n       this command will load the specified files, and if they are elf\n       objects (executables, libraries, core files, etc.) it will parse\n       the embedded packaging metadata, if any, and print it in a table\n       or json format. see the\npackage metadata for executable files\n[1]\n       document for more information.\nexample 22. print information about a core file as json\n$ systemd-analyze inspect-elf --json=pretty \\\n                   core.fsverity.1000.f77dac5dc161402aa44e15b7dd9dcf97.58561.1637106137000000\n           {\n                   \"elftype\" : \"coredump\",\n                   \"elfarchitecture\" : \"amd x86-64\",\n                   \"/home/bluca/git/fsverity-utils/fsverity\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"7c895ecd2a271f93e96268f479fdc3c64a2ec4ee\"\n                   },\n                   \"/home/bluca/git/fsverity-utils/libfsverity.so.0\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"b5e428254abf14237b0ae70ed85fffbb98a78f88\"\n                   }\n           }\nsystemd-analyze fdstore\nunit\n...\n       lists the current contents of the specified service unit's file\n       descriptor store. this shows names, inode types, device numbers,\n       inode numbers, paths and open modes of the open file descriptors.\n       the specified units must have\nfiledescriptorstoremax=\nenabled, see\nsystemd.service(5)\nfor details.\nexample 23. table output\n$ systemd-analyze fdstore systemd-journald.service\n           fdname type devno   inode rdevno path             flags\n           stored sock 0:8   4218620 -      socket:[4218620] ro\n           stored sock 0:8   4213198 -      socket:[4213198] ro\n           stored sock 0:8   4213190 -      socket:[4213190] ro\n           ...\n\n       note: the \"devno\" column refers to the major/minor numbers of the\n       device node backing the file system the file descriptor's inode is\n       on. the \"rdevno\" column refers to the major/minor numbers of the\n       device node itself if the file descriptor refers to one. compare\n       with corresponding\n.st_dev\nand\n.st_rdev\nfields in\nstruct stat\n(see\nstat(2)\nfor details). the listed inode numbers in the \"inode\"\n       column are on the file system indicated by \"devno\".\nsystemd-analyze image-policy\npolicy\n...\n       this command analyzes the specified image policy string, as per\nsystemd.image-policy(7)\n. the policy is normalized and simplified.\n       for each currently defined partition identifier (as per the\ndiscoverable partitions specification\n[2]) the effect of the image\n       policy string is shown in tabular form.\nexample 24. example output\n$ systemd-analyze image-policy swap=encrypted:usr=read-only-on+verity:root=encrypted\n           analyzing policy: root=encrypted:usr=verity+read-only-on:swap=encrypted\n                  long form: root=encrypted:usr=verity+read-only-on:swap=encrypted:=unused+absent\n\n           partition       mode        read-only growfs\n           root            encrypted   -         -\n           usr             verity      yes       -\n           home            ignore      -         -\n           srv             ignore      -         -\n           esp             ignore      -         -\n           xbootldr        ignore      -         -\n           swap            encrypted   -         -\n           root-verity     ignore      -         -\n           usr-verity      unprotected yes       -\n           root-verity-sig ignore      -         -\n           usr-verity-sig  ignore      -         -\n           tmp             ignore      -         -\n           var             ignore      -         -\n           default         ignore      -         -\nsystemd-analyze has-tpm2\nreports whether the system is equipped with a usable tpm2 device.\n       if a tpm2 device has been discovered, is supported, and is being\n       used by firmware, by the os kernel drivers and by userspace (i.e.\n       systemd) this prints \"yes\" and exits with exit status zero. if no\n       such device is discovered/supported/used, prints \"no\". otherwise,\n       prints \"partial\". in either of these two cases exits with non-zero\n       exit status. it also shows five lines indicating separately\n       whether firmware, drivers, the system, the kernel and libraries\n       discovered/support/use tpm2. currently, required libraries are\n       libtss2-esys.so.0, libtss2-rc.so.0, and libtss2-mu.so.0. the\n       requirement may be changed in the future release.\n\n       note, this checks for tpm 2.0 devices only, and does not consider\n       tpm 1.2 at all.\n\n       combine with\n--quiet\nto suppress the output.\nexample 25. example output\nyes\n           +firmware\n           +driver\n           +system\n           +subsystem\n           +libraries\n             +libtss2-esys.so.0\n             +libtss2-rc.so.0\n             +libtss2-mu.so.0\n\n       added in version 257.\nsystemd-analyze pcrs [\npcr\n...]\n       this command shows the known tpm2 pcrs along with their\n       identifying names and current values.\nexample 26. example output\n$ systemd-analyze pcrs\n           nr name                sha256\n            0 platform-code       bcd2eb527108bbb1f5528409bcbe310aa9b74f687854cc5857605993f3d9eb11\n            1 platform-config     b60622856eb7ce52637b80f30a520e6e87c347daa679f3335f4f1a600681bb01\n            2 external-code       1471262403e9a62f9c392941300b4807fbdb6f0bfdd50abfab752732087017dd\n            3 external-config     3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            4 boot-loader-code    939f7fa1458e1f7ce968874d908e524fc0debf890383d355e4ce347b7b78a95c\n            5 boot-loader-config  864c61c5ea5ecbdb6951e6cb6d9c1f4b4eac79772f7fe13b8bece569d83d3768\n            6 -                   3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            7 secure-boot-policy  9c905bd9b9891bfb889b90a54c4b537b889cfa817c4389cc25754823a9443255\n            8 -                   0000000000000000000000000000000000000000000000000000000000000000\n            9 kernel-initrd       9caa29b128113ef42aa53d421f03437be57211e5ebafc0fa8b5d4514ee37ff0c\n           10 ima                 5ea9e3dab53eb6b483b6ec9e3b2c712bea66bca1b155637841216e0094387400\n           11 kernel-boot         0000000000000000000000000000000000000000000000000000000000000000\n           12 kernel-config       627ffa4b405e911902fe1f1a8b0164693b31acab04f805f15bccfe2209c7eace\n           13 sysexts             0000000000000000000000000000000000000000000000000000000000000000\n           14 shim-policy         0000000000000000000000000000000000000000000000000000000000000000\n           15 system-identity     0000000000000000000000000000000000000000000000000000000000000000\n           16 debug               0000000000000000000000000000000000000000000000000000000000000000\n           17 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           18 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           19 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           20 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           21 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           22 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           23 application-support 0000000000000000000000000000000000000000000000000000000000000000\nsystemd-analyze srk [>\nfile\n]\n       this command reads the storage root key (srk) from the tpm2\n       device, and writes it in marshalled tpm2b_public format to stdout.\n       the output is non-printable data, so it should be redirected to a\n       file or into a pipe.\nexample 27. save the storage root key to srk.tpm2b_public\nsystemd-analyze srk >srk.tpm2b_public\nsystemd-analyze architectures [\nname\n...]\n       lists all known cpu architectures, and which ones are native. the\n       listed architecture names are those\nconditionarchitecture=\nsupports, see\nsystemd.unit(5)\nfor details. if architecture names\n       are specified only those specified are listed.\nexample 28. table output\n$ systemd-analyze architectures\n           name        support\n           alpha       foreign\n           arc         foreign\n           arc-be      foreign\n           arm         foreign\n           arm64       foreign\n           ...\n           sparc       foreign\n           sparc64     foreign\n           tilegx      foreign\n           x86         secondary\n           x86-64      native\nsystemd-analyze smbios11\nshows a list of smbios type #11 strings passed to the system. also\n       see\nsmbios-type-11(7)\n.\nexample 29. example output\n$ systemd-analyze smbios11\n           io.systemd.stub.kernel-cmdline-extra=console=ttys0\n           io.systemd.credential.binary:ssh.ephemeral-authorized_keys-all=c3nolwvkmju1mtkgqufbqumztnphqzfswkrjmu5urtvbqufbsurgd20xbfp4wlrgcljteg9zqlozotyzce1uyljcadmwm1mxvxhlsum2nmygbgvubmfydeb6zxrhcg==\n           io.systemd.credential:vmm.notify_socket=vsock-stream:2:254570042\n\n           3 smbios type #11 strings passed.\n\n       added in version 257.\nsystemd-analyze chid\nshows a list of computer hardware ids (chids) of the local system.\n       these ids identify the system's computer hardware, based on smbios\n       data. see\nusing computer hardware ids (chids)\n[3] for details about\n       chids.\nexample 30. example output\n$ systemd-analyze chid\n           type input  chid\n              3 mfpsmp 520537c0-3b59-504f-b062-9682ea236b21\n              4 mfps-- edf05dc8-a53d-5b2c-8023-630bca2a2463\n              5 mfp--- ebc6a4d9-ec48-537a-916b-c69fa4fdd814\n              6 m--smp 5ebe4bba-f598-5e90-9ff2-9fd0d3211465\n              7 m--s-- 1a3fb835-b42a-5f9c-a38c-eff5bfd5c41d\n              8 m-p-mp 2a831dce-8163-5bad-8406-435b8c752dd8\n              9 m-p--- 7c21c878-4a75-50f7-9816-21e811588da0\n             10 mf--mp 9a003537-bcc5-500e-b10a-8d8892e4fc64\n             11 mf---- bb9122bb-8a5c-50d2-a742-a85beb719909\n             13 m---mp bfc36935-5032-5987-a0a3-6311f01de33a\n\n           legend: m \u00e2\u0086\u0092 sys_vendor (lenovo) \u00e2\u0094\u0084 f \u00e2\u0086\u0092 product_family (thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 p \u00e2\u0086\u0092 product_name (20xw0055ge)\n                   s \u00e2\u0086\u0092 product_sku (lenovo_mt_20xw_bu_think_fm_thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 m \u00e2\u0086\u0092 board_vendor (lenovo)\n                   p \u00e2\u0086\u0092 board_name (20xw0055ge)\n\n       added in version 258.\nRelevant sections:\n- \n- \n\n---\n\nCommand: free\nDescription: free\ndisplays the total amount of free and used physical and swap\n       memory in the system, as well as the buffers and caches used by\n       the kernel. the information is gathered by parsing /proc/meminfo.\n       the displayed columns are:\ntotal\ntotal usable memory (memtotal and swaptotal in\n              /proc/meminfo). this includes the physical and swap memory\n              minus a few reserved bits and kernel binary code.\nused\nused or unavailable memory (calculated as\ntotal\n-\navailable\n)\nfree\nunused memory (memfree and swapfree in /proc/meminfo)\nshared\nmemory used (mostly) by tmpfs (shmem in /proc/meminfo)\nbuffers\nmemory used by kernel buffers (buffers in /proc/meminfo)\ncache\nmemory used by the page cache and slabs (cached and\n              sreclaimable in /proc/meminfo)\nbuff/cache\nsum of\nbuffers\nand\ncache\navailable\nestimation of how much memory is available for starting new\n              applications, without swapping. unlike the data provided by\n              the\ncache\nor\nfree\nfields, this field takes into account\n              page cache and also that not all reclaimable memory slabs\n              will be reclaimed due to items being in use (memavailable\n              in /proc/meminfo, available on kernels 3.14, emulated on\n              kernels 2.6.27+, otherwise the same as\nfree\n)\nRelevant sections:\n- \n- \n\n---\n\nCommand: webvis\nDescription: webvis\ndisplays an overview of system level web server performance\n       statistics collected from the performance co-pilot (pcp)\n       infrastructure.  the display is modulated by the values of the\n       performance metrics retrieved from the target\nhost\n(which is\n       running\npmcd(1)\nand the\npmdaweblog(1)\nperformance metrics domain\n       agent) or from the pcp archive log identified by\narchive\n.  the\n       display is updated every\ninterval\nseconds (default 2 seconds).\n\n       as in all\npmview(1)\nscenes, when the mouse is moved over one of\n       the bars, the current value and metric information for that bar\n       will be shown in the text box near the top of the display.\n\n       the height of the web request and network activity bars is\n       proportional to the performance metric values relative to the\n       maximum expected activity, as controlled by the\n-m\nand\n-r\noptions\n       (see below).  similarly the\n-b\nand\n-i\noptions control the scaling\n       for disk activity bars.\n\n       the bars in the\nwebvis\nscene represent the following information;\nrequests by size\nat the front of the scene, the \"requests by size\" row of bars\n           shows the rate of requests for different size requests (the\n           histograms are defined by the following byte counts: 0, 3\n           kbytes, 10 kbytes, 30 kbytes, 100 kbytes, 300 kbytes, 1 mbyte,\n           3 mbytes and larger than 3 mbytes).  notice that the size\n           divisions are not evenly distributed.  the \"size\" is the data\n           portion of the response to each web server request.  these\n           rates are aggregated across all monitored web servers.\nrequests by type\nthis row of bars shows the request rate for each type of http\n           request (get, post, head and other), aggregated across all\n           monitored web servers.  for a detailed display showing the\n           break down of requests\nper web server\n, see\nweblogvis(1)\n.\nnetwork\nfor every network interface there are two stacked bars.  one\n           of the bars shows the input traffic while the other bar shows\n           the output traffic.  the stacks are composed of the number of\n           errors (red), the number of drops (orange) and the number of\n           packets (green).  in general, if there are any \"dropped input\n           packets\" then the corresponding network interface is\n           saturated, or there are insufficient network resources\n           available in the kernel to adequately service the input\n           request load.  if this is the case then the\nalarm conditions\nrows (see below) may provide more detail into the source of\n           the problem.\nalarm conditions\nthe red row of bars shows an assortment of tcp error\n           conditions (aggregated for all network interfaces), the orange\n           bars show critical kernel buffer allocation problems, and the\n           yellow bar shows severe paging conditions.  if any of these\n           bars have a non-zero height then the system being monitored\n           may require kernel parameter tuning, software reconfiguration\n           or more hardware resources.  the performance metrics behind\n           the bars are:\nnetwork.tcp.drops\n- rate of dropped connections\nnetwork.tcp.conndrops\n- rate of embryonic connections dropped\nnetwork.tcp.timeoutdrop\n- rate of connections dropped by rexmit timeout\nnetwork.tcp.rcvbadsum\n- rate of packets discarded for bad checksums\nnetwork.tcp.rexmttimeo\n- rate of retransmit timeouts\nnetwork.tcp.sndrexmitpack\n- rate of data packets retransmitted\nswap.pagesout\n- page swap out rate (indicating insufficient memory)\nnetwork.mbuf.failed\n- rate of incidents where the kernel failed to find\n                  mbuf space\nnetwork.mbuf.waited\n- rate of incidents where the kernel waited to find\n                  mbuf space\ncpu\nthis column shows cpu utilization, aggregated over all cpus.\n           (cpu idle time is not included in the column).\ndisk\nthere are two cylinders showing disk metrics.  the first\n           cylinder shows the rate of read (yellow) and write (violet)\n           operations, aggregated over all disk spindles.  the second\n           cylinder shows the average (over all disks) percentage of time\n           for which a disk is busy or active.  this metric is not\n           available in pcp1.x versions, therefore if\nwebvis\nis being\n           used to monitor a host running pcp1.x this cylinder will not\n           be displayed.\n\n           to adjust the scaling of these objects, refer to the\n-b\nand\n-i\noptions described below.\nmem\nthere are two bars showing memory metrics.  the first bar\n           shows utilized memory, with different colors representing\n           different types of utilization (kernel, user, etc), while the\n           second bar shows the amount of free memory.  if\nwebvis\nis\n           being used to monitor a host running pcp1.x then only the bar\n           showing free memory will be displayed.\n\n       if any optional\ninterface\narguments are specified in the command\n       line, then just the network interfaces matching the\ninterface\narguments will appear in the\nnetwork\nsection.  by default,\nall\ninterfaces will be used.  the\ninterface\narguments are used as\n       patterns for\negrep\n(1) matching against the interface names, so\nec\nwould select all external ethernet interfaces for a challenge s.\nwebvis\nuses\npmview(1)\n, and so the user interface follows that\n       described for\npmview(1)\n, which in turn displays the scene within\n       an inventor examiner viewer.\nwebvis\npasses most command line options to\npmview(1)\n.  therefore,\n       the command line options\n-a\n,\n-a\n,\n-c\n,\n-h\n,\n-n\n,\n-o\n,\n-p\n,\n-s\n,\n-t\n,\n-t\n,\n-x\n,\n-z\nand\n-z\n, and the user interface are described in the\npmview(1)\nman page.\n\n       options specific to\nwebvis\nare:\n-b\nmaxbusy\ncontrols the maximum (normalization) value for the average\n              percentage of the time active over all disks.  the default\n              value is 30% active.\n-i\nmaxio\ncontrols the maximum (normalization) value for the sume of\n              the aggregate disk read and disk write rates.  the default\n              value is 100 i/os per second.\n-m\nmax\ncontrols the maximum (normalization) value for the packet\n              input and packet output rates.  the default value is 750\n              packets/second.\n-r\nmaxreq\ncontrols the maximum web request rate.  the default is 5%\n              of the maximum packet rate (i.e. 38 requests/second by\n              default).  the maximum web error rate is fixed at 20% of\n              the maximum web request rate (i.e. 7 errors/second by\n              default).\n-v\nthe derived configuration file for\npmview(1)\nis written on\n              standard output.  this may be saved and used directly with\npmview\nif the user wishes to customize the display, or\n              modify some of the normalization parameters.\nRelevant sections:\n- \n\n---\n\nCommand: dash\nDescription: dash\nis the standard command interpreter for the system.  the\n       current version of\ndash\nis in the process of being changed to\n       conform with the posix 1003.2 and 1003.2a specifications for the\n       shell.  this version has many features which make it appear\n       similar in some respects to the korn shell, but it is not a korn\n       shell clone (see\nksh\n(1)).  only features designated by posix, plus\n       a few berkeley extensions, are being incorporated into this shell.\n       this man page is not intended to be a tutorial or a complete\n       specification of the shell.\noverview\nthe shell is a command that reads lines from either a file or the\n       terminal, interprets them, and generally executes other commands.\n       it is the program that is running when a user logs into the system\n       (although a user can select a different shell with the\nchsh\n(1)\n       command).  the shell implements a language that has flow control\n       constructs, a macro facility that provides a variety of features\n       in addition to data storage, along with built in history and line\n       editing capabilities.  it incorporates many features to aid\n       interactive use and has the advantage that the interpretative\n       language is common to both interactive and non-interactive use\n       (shell scripts).  that is, commands can be typed directly to the\n       running shell or can be put into a file and the file can be\n       executed directly by the shell.\ninvocation\nif no args are present and if the standard input of the shell is\n       connected to a terminal (or if the\n-i\nflag is set), and the\n-c\noption is not present, the shell is considered an interactive\n       shell.  an interactive shell generally prompts before each command\n       and handles programming and command errors differently (as\n       described below).  when first starting, the shell inspects\n       argument 0, and if it begins with a dash \u00e2\u0080\u0098-\u00e2\u0080\u0099, the shell is also\n       considered a login shell.  this is normally done automatically by\n       the system when the user first logs in.  a login shell first reads\n       commands from the files\n/etc/profile\nand\n.profile\nif they exist.\n       if the environment variable env is set on entry to an interactive\n       shell, or is set in the\n.profile\nof a login shell, the shell next\n       reads commands from the file named in env.  therefore, a user\n       should place commands that are to be executed only at login time\n       in the\n.profile\nfile, and commands that are executed for every\n       interactive shell inside the env file.  to set the env variable to\n       some file, place the following line in your\n.profile\nof your home\n       directory\nenv=$home/.shinit; export env\nsubstituting for \u00e2\u0080\u009c.shinit\u00e2\u0080\u009d any filename you wish.\n\n       if command line arguments besides the options have been specified,\n       then the shell treats the first argument as the name of a file\n       from which to read commands (a shell script), and the remaining\n       arguments are set as the positional parameters of the shell ($1,\n       $2, etc).  otherwise, the shell reads commands from its standard\n       input.\nargument list processing\nall of the single letter options that have a corresponding name\n       can be used as an argument to the\n-o\noption.  the set\n-o\nname is\n       provided next to the single letter option in the description\n       below.  specifying a dash \u00e2\u0080\u009c-\u00e2\u0080\u009d turns the option on, while using a\n       plus \u00e2\u0080\u009c+\u00e2\u0080\u009d disables the option.  the following options can be set\n       from the command line or with the\nset\nbuiltin (described later).\n-a\nallexport\nexport all variables assigned to.\n-c\nread commands from the\ncommand_string\noperand instead of from the standard input.\n                              special parameter 0 will be set from the\ncommand_name\noperand and the positional\n                              parameters ($1, $2, etc.)  set from the\n                              remaining argument operands.\n-c\nnoclobber\ndon't overwrite existing files with \u00e2\u0080\u009c>\u00e2\u0080\u009d.\n-e\nerrexit\nif not interactive, exit immediately if any\n                              untested command fails.  the exit status of\n                              a command is considered to be explicitly\n                              tested if the command is used to control an\nif\n,\nelif\n,\nwhile\n, or\nuntil\n; or if the\n                              command is the left hand operand of an \u00e2\u0080\u009c&&\u00e2\u0080\u009d\n                              or \u00e2\u0080\u009c||\u00e2\u0080\u009d operator.\n-f\nnoglob\ndisable pathname expansion.\n-n\nnoexec\nif not interactive, read commands but do\n                              not execute them.  this is useful for\n                              checking the syntax of shell scripts.\n-u\nnounset\nwrite a message to standard error when\n                              attempting to expand a variable that is not\n                              set, and if the shell is not interactive,\n                              exit immediately.\n-v\nverbose\nthe shell writes its input to standard\n                              error as it is read.  useful for debugging.\n-x\nxtrace\nwrite each command to standard error\n                              (preceded by a \u00e2\u0080\u0098+ \u00e2\u0080\u0099) before it is executed.\n                              useful for debugging.\n-i\nignoreeof\nignore eof's from input when interactive.\n-i\ninteractive\nforce the shell to behave interactively.\n-l\nmake dash act as if it had been invoked as\n                              a login shell.\n-m\nmonitor\nturn on job control (set automatically when\n                              interactive).\n-s\nstdin\nread commands from standard input (set\n                              automatically if no file arguments are\n                              present).  this option has no effect when\n                              set after the shell has already started\n                              running (i.e. with\nset\n).\n-v\nvi\nenable the built-in\nvi\n(1) command line\n                              editor (disables\n-e\nif it has been set).\n-e\nemacs\nenable the built-in\nemacs\n(1) command line\n                              editor (disables\n-v\nif it has been set).\n-b\nnotify\nenable asynchronous notification of\n                              background job completion.  (unimplemented\n                              for 4.4alpha)\nlexical structure\nthe shell reads input in terms of lines from a file and breaks it\n       up into words at whitespace (blanks and tabs), and at certain\n       sequences of characters that are special to the shell called\n       \u00e2\u0080\u009coperators\u00e2\u0080\u009d.  there are two types of operators: control operators\n       and redirection operators (their meaning is discussed later).\n       following is a list of operators:\n\n             control operators:\n& && ( ) ; ;;\n|\n|| <newline>\nredirection operators:\n< > >| << >> <& >& <<- <>\nquoting\nquoting is used to remove the special meaning of certain\n       characters or words to the shell, such as operators, whitespace,\n       or keywords.  there are three types of quoting: matched single\n       quotes, matched double quotes, and backslash.\nbackslash\na backslash preserves the literal meaning of the following\n       character, with the exception of \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9.  a backslash preceding\n       a \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9 is treated as a line continuation.\nsingle quotes\nenclosing characters in single quotes preserves the literal\n       meaning of all the characters (except single quotes, making it\n       impossible to put single-quotes in a single-quoted string).\ndouble quotes\nenclosing characters within double quotes preserves the literal\n       meaning of all characters except dollarsign ($), backquote (`),\n       and backslash (\\).  the backslash inside double quotes is\n       historically weird, and serves to quote only the following\n       characters:\n$ ` \" \\ <newline>\n.\n       otherwise it remains literal.\nreserved words\nreserved words are words that have special meaning to the shell\n       and are recognized at the beginning of a line and after a control\n       operator.  the following are reserved words:\n\n             !       elif    fi      while   case\n             else    for     then    {       }\n             do      done    until   if      esac\n\n       their meaning is discussed later.\naliases\nan alias is a name and corresponding value set using the\nalias\n(1)\n       builtin command.  whenever a reserved word may occur (see above),\n       and after checking for reserved words, the shell checks the word\n       to see if it matches an alias.  if it does, it replaces it in the\n       input stream with its value.  for example, if there is an alias\n       called \u00e2\u0080\u009clf\u00e2\u0080\u009d with the value \u00e2\u0080\u009cls -f\u00e2\u0080\u009d, then the input:\nlf foobar\n\u00e2\u009f\u00a8return\u00e2\u009f\u00a9\n\n       would become\nls -f foobar\n\u00e2\u009f\u00a8return\u00e2\u009f\u00a9\n\n       aliases provide a convenient way for naive users to create\n       shorthands for commands without having to learn how to create\n       functions with arguments.  they can also be used to create\n       lexically obscure code.  this use is discouraged.\ncommands\nthe shell interprets the words it reads according to a language,\n       the specification of which is outside the scope of this man page\n       (refer to the bnf in the posix 1003.2 document).  essentially\n       though, a line is read and if the first word of the line (or after\n       a control operator) is not a reserved word, then the shell has\n       recognized a simple command.  otherwise, a complex command or some\n       other special construct may have been recognized.\nsimple commands\nif a simple command has been recognized, the shell performs the\n       following actions:\n\n             1.   leading words of the form \u00e2\u0080\u009cname=value\u00e2\u0080\u009d are stripped off\n                  and assigned to the environment of the simple command.\n                  redirection operators and their arguments (as described\n                  below) are stripped off and saved for processing.\n\n             2.   the remaining words are expanded as described in the\n                  section called \u00e2\u0080\u009cexpansions\u00e2\u0080\u009d, and the first remaining\n                  word is considered the command name and the command is\n                  located.  the remaining words are considered the\n                  arguments of the command.  if no command name resulted,\n                  then the \u00e2\u0080\u009cname=value\u00e2\u0080\u009d variable assignments recognized\n                  in item 1 affect the current shell.\n\n             3.   redirections are performed as described in the next\n                  section.\nredirections\nredirections are used to change where a command reads its input or\n       sends its output.  in general, redirections open, close, or\n       duplicate an existing reference to a file.  the overall format\n       used for redirection is:\n[n]\nredir-op file\nwhere\nredir-op\nis one of the redirection operators mentioned\n       previously.  following is a list of the possible redirections.\n       the [n] is an optional number between 0 and 9, as in \u00e2\u0080\u00983\u00e2\u0080\u0099 (not\n       \u00e2\u0080\u0098[3]\u00e2\u0080\u0099), that refers to a file descriptor.\n\n             [n]> file   redirect standard output (or n) to file.\n\n             [n]>| file  same, but override the\n-c\noption.\n\n             [n]>> file  append standard output (or n) to file.\n\n             [n]< file   redirect standard input (or n) from file.\n\n             [n1]<&n2    copy file descriptor n2 as stdin (or fd n1).\n\n             [n]<&-      close standard input (or n).\n\n             [n1]>&n2    copy file descriptor n2 as stdout (or fd n1).\n\n             [n]>&-      close standard output (or n).\n\n             [n]<> file  open file for reading and writing on standard\n                         input (or n).\n\n       the following redirection is often called a \u00e2\u0080\u009chere-document\u00e2\u0080\u009d.\n[n]<< delimiter\nhere-doc-text ...\ndelimiter\nall the text on successive lines up to the delimiter is saved away\n       and made available to the command on standard input, or file\n       descriptor n if it is specified.  if the delimiter as specified on\n       the initial line is quoted, then the here-doc-text is treated\n       literally, otherwise the text is subjected to parameter expansion,\n       command substitution, and arithmetic expansion (as described in\n       the section on \u00e2\u0080\u009cexpansions\u00e2\u0080\u009d).  if the operator is \u00e2\u0080\u009c<<-\u00e2\u0080\u009d instead of\n       \u00e2\u0080\u009c<<\u00e2\u0080\u009d, then leading tabs in the here-doc-text are stripped.\nsearch and execution\nthere are three types of commands: shell functions, builtin\n       commands, and normal programs \u00e2\u0080\u0093 and the command is searched for\n       (by name) in that order.  they each are executed in a different\n       way.\n\n       when a shell function is executed, all of the shell positional\n       parameters (except $0, which remains unchanged) are set to the\n       arguments of the shell function.  the variables which are\n       explicitly placed in the environment of the command (by placing\n       assignments to them before the function name) are made local to\n       the function and are set to the values given.  then the command\n       given in the function definition is executed.  the positional\n       parameters are restored to their original values when the command\n       completes.  this all occurs within the current shell.\n\n       shell builtins are executed internally to the shell, without\n       spawning a new process.\n\n       otherwise, if the command name doesn't match a function or\n       builtin, the command is searched for as a normal program in the\n       file system (as described in the next section).  when a normal\n       program is executed, the shell runs the program, passing the\n       arguments and the environment to the program.  if the program is\n       not a normal executable file (i.e., if it does not begin with the\n       \"magic number\" whose ascii representation is \"#!\", so\nexecve\n(2)\n       returns enoexec then) the shell will interpret the program in a\n       subshell.  the child shell will reinitialize itself in this case,\n       so that the effect will be as if a new shell had been invoked to\n       handle the ad-hoc shell script, except that the location of hashed\n       commands located in the parent shell will be remembered by the\n       child.\n\n       note that previous versions of this document and the source code\n       itself misleadingly and sporadically refer to a shell script\n       without a magic number as a \"shell procedure\".\npath search\nwhen locating a command, the shell first looks to see if it has a\n       shell function by that name.  then it looks for a builtin command\n       by that name.  if a builtin command is not found, one of two\n       things happen:\n\n       1.   command names containing a slash are simply executed without\n            performing any searches.\n\n       2.   the shell searches each entry in path in turn for the\n            command.  the value of the path variable should be a series\n            of entries separated by colons.  each entry consists of a\n            directory name.  the current directory may be indicated\n            implicitly by an empty directory name, or explicitly by a\n            single period.\ncommand exit status\neach command has an exit status that can influence the behaviour\n       of other shell commands.  the paradigm is that a command exits\n       with zero for normal or success, and non-zero for failure, error,\n       or a false indication.  the man page for each command should\n       indicate the various exit codes and what they mean.  additionally,\n       the builtin commands return exit codes, as does an executed shell\n       function.\n\n       if a command consists entirely of variable assignments then the\n       exit status of the command is that of the last command\n       substitution if any, otherwise 0.\ncomplex commands\ncomplex commands are combinations of simple commands with control\n       operators or reserved words, together creating a larger complex\n       command.  more generally, a command is one of the following:\n\u00e2\u0080\u00a2\nsimple command\n\u00e2\u0080\u00a2\npipeline\n\u00e2\u0080\u00a2\nlist or compound-list\n\u00e2\u0080\u00a2\ncompound command\n\u00e2\u0080\u00a2\nfunction definition\n\n       unless otherwise stated, the exit status of a command is that of\n       the last simple command executed by the command.\npipelines\na pipeline is a sequence of one or more commands separated by the\n       control operator |.  the standard output of all but the last\n       command is connected to the standard input of the next command.\n       the standard output of the last command is inherited from the\n       shell, as usual.\n\n       the format for a pipeline is:\n[!] command1\n[|\ncommand2 ...]\nthe standard output of command1 is connected to the standard input\n       of command2.  the standard input, standard output, or both of a\n       command is considered to be assigned by the pipeline before any\n       redirection specified by redirection operators that are part of\n       the command.\n\n       if the pipeline is not in the background (discussed later), the\n       shell waits for all commands to complete.\n\n       if the\npipefail\noption was enabled when the shell began execution\n       of the pipeline, the pipeline's exit status is the exit status of\n       the last command specified in the pipeline that exited with non-\n       zero status, or zero if all commands in the pipeline exited with a\n       status of zero. if the\npipefail\noption was not enabled, the\n       pipeline's exit status is the exit status of the last command\n       specified in the pipeline; the exit statuses of any other commands\n       are not used. if the reserved word ! precedes the pipeline, its\n       exit status is the logical not of the exit status described above.\n\n       because pipeline assignment of standard input or standard output\n       or both takes place before redirection, it can be modified by\n       redirection.  for example:\n$ command1 2>&1\n|\ncommand2\nsends both the standard output and standard error of command1 to\n       the standard input of command2.\n\n       a ; or \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9 terminator causes the preceding and-or-list\n       (described next) to be executed sequentially; a & causes\n       asynchronous execution of the preceding and-or-list.\n\n       note that unlike some other shells, each process in the pipeline\n       is a child of the invoking shell (unless it is a shell builtin, in\n       which case it executes in the current shell \u00e2\u0080\u0093 but any effect it\n       has on the environment is wiped).\nbackground commands \u00e2\u0080\u0093 &\nif a command is terminated by the control operator ampersand (&),\n       the shell executes the command asynchronously \u00e2\u0080\u0093 that is, the shell\n       does not wait for the command to finish before executing the next\n       command.\n\n       the format for running a command in background is:\ncommand1 & [command2 & ...]\nif the shell is not interactive, the standard input of an\n       asynchronous command is set to\n/dev/null\n.\nlists \u00e2\u0080\u0093 generally speaking\na list is a sequence of zero or more commands separated by\n       newlines, semicolons, or ampersands, and optionally terminated by\n       one of these three characters.  the commands in a list are\n       executed in the order they are written.  if command is followed by\n       an ampersand, the shell starts the command and immediately\n       proceeds onto the next command; otherwise it waits for the command\n       to terminate before proceeding to the next one.\nshort-circuit list operators\n\u00e2\u0080\u009c&&\u00e2\u0080\u009d and \u00e2\u0080\u009c||\u00e2\u0080\u009d are and-or list operators.  \u00e2\u0080\u009c&&\u00e2\u0080\u009d executes the first\n       command, and then executes the second command if and only if the\n       exit status of the first command is zero.  \u00e2\u0080\u009c||\u00e2\u0080\u009d is similar, but\n       executes the second command if and only if the exit status of the\n       first command is nonzero.  \u00e2\u0080\u009c&&\u00e2\u0080\u009d and \u00e2\u0080\u009c||\u00e2\u0080\u009d both have the same\n       priority.\nflow-control constructs \u00e2\u0080\u0093 if, while, for, case\nthe syntax of the if command is\n\n             if list\n             then list\n             [ elif list\n             then    list ] ...\n             [ else list ]\n             fi\n\n       the syntax of the while command is\n\n             while list\n             do   list\n             done\n\n       the two lists are executed repeatedly while the exit status of the\n       first list is zero.  the until command is similar, but has the\n       word until in place of while, which causes it to repeat until the\n       exit status of the first list is zero.\n\n       the syntax of the for command is\n\n             for variable [ in [ word ... ] ]\n             do   list\n             done\n\n       the words following\nin\nare expanded, and then the list is executed\n       repeatedly with the variable set to each word in turn.  omitting\n       in word ... is equivalent to in \"$@\".\n\n       the syntax of the break and continue command is\n\n             break [ num ]\n             continue [ num ]\n\n       break terminates the num innermost for or while loops.  continue\n       continues with the next iteration of the innermost loop.  these\n       are implemented as builtin commands.\n\n       the syntax of the case command is\n\n             case word in\n             [(]pattern) list ;;\n             ...\n             esac\n\n       the pattern can actually be one or more patterns (see \u00e2\u0080\u009cshell\n       patterns\u00e2\u0080\u009d described later), separated by \u00e2\u0080\u009c|\u00e2\u0080\u009d characters.  the \u00e2\u0080\u009c(\u00e2\u0080\u009d\n       character before the pattern is optional.\ngrouping commands together\ncommands may be grouped by writing either\n(list)\nor\n{ list; }\nthe first of these executes the commands in a subshell.  builtin\n       commands grouped into a (list) will not affect the current shell.\n       the second form does not fork another shell so is slightly more\n       efficient.  grouping commands together this way allows you to\n       redirect their output as though they were one program:\n\n             { printf \" hello \" ; printf \" world\\n\" ; } > greeting\n\n       note that \u00e2\u0080\u009c}\u00e2\u0080\u009d must follow a control operator (here, \u00e2\u0080\u009c;\u00e2\u0080\u009d) so that\n       it is recognized as a reserved word and not as another command\n       argument.\nfunctions\nthe syntax of a function definition is\nname\n()\ncommand\na function definition is an executable statement; when executed it\n       installs a function named name and returns an exit status of zero.\n       the command is normally a list enclosed between \u00e2\u0080\u009c{\u00e2\u0080\u009d and \u00e2\u0080\u009c}\u00e2\u0080\u009d.\n\n       variables may be declared to be local to a function by using a\n       local command.  this should appear as the first statement of a\n       function, and the syntax is\nlocal\n[\nvariable\n|\n-\n]\n...\nlocal is implemented as a builtin command.\n\n       when a variable is made local, it inherits the initial value and\n       exported and readonly flags from the variable with the same name\n       in the surrounding scope, if there is one.  otherwise, the\n       variable is initially unset.  the shell uses dynamic scoping, so\n       that if you make the variable x local to function f, which then\n       calls function g, references to the variable x made inside g will\n       refer to the variable x declared inside f, not to the global\n       variable named x.\n\n       the only special parameter that can be made local is \u00e2\u0080\u009c-\u00e2\u0080\u009d.  making\n       \u00e2\u0080\u009c-\u00e2\u0080\u009d local any shell options that are changed via the set command\n       inside the function to be restored to their original values when\n       the function returns.\n\n       the syntax of the return command is\nreturn\n[\nexitstatus\n]\n\n       it terminates the currently executing function.  return is\n       implemented as a builtin command.\nvariables and parameters\nthe shell maintains a set of parameters.  a parameter denoted by a\n       name is called a variable.  when starting up, the shell turns all\n       the environment variables into shell variables.  new variables can\n       be set using the form\nname=value\nvariables set by the user must have a name consisting solely of\n       alphabetics, numerics, and underscores - the first of which must\n       not be numeric.  a parameter can also be denoted by a number or a\n       special character as explained below.\npositional parameters\na positional parameter is a parameter denoted by a number (n > 0).\n       the shell sets these initially to the values of its command line\n       arguments that follow the name of the shell script.  the\nset\nbuiltin can also be used to set or reset them.\nspecial parameters\na special parameter is a parameter denoted by one of the following\n       special characters.  the value of the parameter is listed next to\n       its character.\n\n       *            expands to the positional parameters, starting from\n                    one.  when the expansion occurs within a double-\n                    quoted string it expands to a single field with the\n                    value of each parameter separated by the first\n                    character of the ifs variable, or by a \u00e2\u009f\u00a8space\u00e2\u009f\u00a9 if ifs\n                    is unset.\n\n       @            expands to the positional parameters, starting from\n                    one.  when the expansion occurs within double-quotes,\n                    each positional parameter expands as a separate\n                    argument.  if there are no positional parameters, the\n                    expansion of @ generates zero arguments, even when @\n                    is double-quoted.  what this basically means, for\n                    example, is if $1 is \u00e2\u0080\u009cabc\u00e2\u0080\u009d and $2 is \u00e2\u0080\u009cdef ghi\u00e2\u0080\u009d, then\n                    \"$@\" expands to the two arguments:\n\"abc\" \"def ghi\"\n#            expands to the number of positional parameters.\n\n       ?            expands to the exit status of the most recent\n                    pipeline.\n\n       - (hyphen.)  expands to the current option flags (the single-\n                    letter option names concatenated into a string) as\n                    specified on invocation, by the set builtin command,\n                    or implicitly by the shell.\n\n       $            expands to the process id of the invoked shell.  a\n                    subshell retains the same value of $ as its parent.\n\n       !            expands to the process id of the most recent\n                    background command executed from the current shell.\n                    for a pipeline, the process id is that of the last\n                    command in the pipeline.\n\n       0 (zero.)    expands to the name of the shell or shell script.\nword expansions\nthis clause describes the various expansions that are performed on\n       words.  not all expansions are performed on every word, as\n       explained later.\n\n       tilde expansions, parameter expansions, command substitutions,\n       arithmetic expansions, and quote removals that occur within a\n       single word expand to a single field.  it is only field splitting\n       or pathname expansion that can create multiple fields from a\n       single word.  the single exception to this rule is the expansion\n       of the special parameter @ within double-quotes, as was described\n       above.\n\n       the order of word expansion is:\n\n       1.   tilde expansion, parameter expansion, command substitution,\n            arithmetic expansion (these all occur at the same time).\n\n       2.   field splitting is performed on fields generated by step (1)\n            unless the ifs variable is null.\n\n       3.   pathname expansion (unless set\n-f\nis in effect).\n\n       4.   quote removal.\n\n       the $ character is used to introduce parameter expansion, command\n       substitution, or arithmetic evaluation.\ntilde expansion (substituting a user's home directory)\na word beginning with an unquoted tilde character (~) is subjected\n       to tilde expansion.  all the characters up to a slash (/) or the\n       end of the word are treated as a username and are replaced with\n       the user's home directory.  if the username is missing (as in\n~/foobar\n), the tilde is replaced with the value of the\nhome\nvariable (the current user's home directory).\nparameter expansion\nthe format for parameter expansion is as follows:\n${expression}\nwhere expression consists of all characters until the matching\n       \u00e2\u0080\u009c}\u00e2\u0080\u009d.  any \u00e2\u0080\u009c}\u00e2\u0080\u009d escaped by a backslash or within a quoted string,\n       and characters in embedded arithmetic expansions, command\n       substitutions, and variable expansions, are not examined in\n       determining the matching \u00e2\u0080\u009c}\u00e2\u0080\u009d.\n\n       the simplest form for parameter expansion is:\n${parameter}\nthe value, if any, of parameter is substituted.\n\n       the parameter name or symbol can be enclosed in braces, which are\n       optional except for positional parameters with more than one digit\n       or when parameter is followed by a character that could be\n       interpreted as part of the name.  if a parameter expansion occurs\n       inside double-quotes:\n\n       1.   pathname expansion is not performed on the results of the\n            expansion.\n\n       2.   field splitting is not performed on the results of the\n            expansion, with the exception of @.\n\n       in addition, a parameter expansion can be modified by using one of\n       the following formats.\n\n       ${parameter:-word}    use default values.  if parameter is unset\n                             or null, the expansion of word is\n                             substituted; otherwise, the value of\n                             parameter is substituted.\n\n       ${parameter:=word}    assign default values.  if parameter is\n                             unset or null, the expansion of word is\n                             assigned to parameter.  in all cases, the\n                             final value of parameter is substituted.\n                             only variables, not positional parameters or\n                             special parameters, can be assigned in this\n                             way.\n\n       ${parameter:?[word]}  indicate error if null or unset.  if\n                             parameter is unset or null, the expansion of\n                             word (or a message indicating it is unset if\n                             word is omitted) is written to standard\n                             error and the shell exits with a nonzero\n                             exit status.  otherwise, the value of\n                             parameter is substituted.  an interactive\n                             shell need not exit.\n\n       ${parameter:+word}    use alternative value.  if parameter is\n                             unset or null, null is substituted;\n                             otherwise, the expansion of word is\n                             substituted.\n\n       in the parameter expansions shown previously, use of the colon in\n       the format results in a test for a parameter that is unset or\n       null; omission of the colon results in a test for a parameter that\n       is only unset.\n\n       ${#parameter}         string length.  the length in characters of\n                             the value of parameter.\n\n       the following four varieties of parameter expansion provide for\n       substring processing.  in each case, pattern matching notation\n       (see \u00e2\u0080\u009cshell patterns\u00e2\u0080\u009d), rather than regular expression notation,\n       is used to evaluate the patterns.  if parameter is * or @, the\n       result of the expansion is unspecified.  enclosing the full\n       parameter expansion string in double-quotes does not cause the\n       following four varieties of pattern characters to be quoted,\n       whereas quoting characters within the braces has this effect.\n\n       ${parameter%word}     remove smallest suffix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the smallest portion of the\n                             suffix matched by the pattern deleted.\n\n       ${parameter%%word}    remove largest suffix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the largest portion of the\n                             suffix matched by the pattern deleted.\n\n       ${parameter#word}     remove smallest prefix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the smallest portion of the\n                             prefix matched by the pattern deleted.\n\n       ${parameter##word}    remove largest prefix pattern.  the word is\n                             expanded to produce a pattern.  the\n                             parameter expansion then results in\n                             parameter, with the largest portion of the\n                             prefix matched by the pattern deleted.\ncommand substitution\ncommand substitution allows the output of a command to be\n       substituted in place of the command name itself.  command\n       substitution occurs when the command is enclosed as follows:\n$(command)\nor (\u00e2\u0080\u009cbackquoted\u00e2\u0080\u009d version):\n`command`\nthe shell expands the command substitution by executing command in\n       a subshell environment and replacing the command substitution with\n       the standard output of the command, removing sequences of one or\n       more \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9s at the end of the substitution.  (embedded\n       \u00e2\u009f\u00a8newline\u00e2\u009f\u00a9s before the end of the output are not removed; however,\n       during field splitting, they may be translated into \u00e2\u009f\u00a8space\u00e2\u009f\u00a9s,\n       depending on the value of ifs and quoting that is in effect.)\narithmetic expansion\narithmetic expansion provides a mechanism for evaluating an\n       arithmetic expression and substituting its value.  the format for\n       arithmetic expansion is as follows:\n$((expression))\nthe expression is treated as if it were in double-quotes, except\n       that a double-quote inside the expression is not treated\n       specially.  the shell expands all tokens in the expression for\n       parameter expansion, command substitution, and quote removal.\n\n       next, the shell treats this as an arithmetic expression and\n       substitutes the value of the expression.\nwhite space splitting (field splitting)\nafter parameter expansion, command substitution, and arithmetic\n       expansion the shell scans the results of expansions and\n       substitutions that did not occur in double-quotes for field\n       splitting and multiple fields can result.\n\n       the shell treats each character of the ifs as a delimiter and uses\n       the delimiters to split the results of parameter expansion and\n       command substitution into fields.\n\n       if ifs is empty, field splitting yields no fields if the input\n       string was empty, and one string with the unchanged value of the\n       input otherwise.  for example, with the default ifs, \u00e2\u0080\u009c\nread -r\nl\u00e2\u0080\u009d\n       will remove any initial whitespace, but \u00e2\u0080\u009cifs=\nread -r\nl\u00e2\u0080\u009d will\n       leave the entire line in l.\npathname expansion (file name generation)\nunless the\n-f\nflag is set, file name generation is performed after\n       word splitting is complete.  each word is viewed as a series of\n       patterns, separated by slashes.  the process of expansion replaces\n       the word with the names of all existing files whose names can be\n       formed by replacing each pattern with a string that matches the\n       specified pattern.  there are two restrictions on this: first, a\n       pattern cannot match a string containing a slash, and second, a\n       pattern cannot match a string starting with a period unless the\n       first character of the pattern is a period.  the next section\n       describes the patterns used for both pathname expansion and the\ncase\ncommand.\nshell patterns\na pattern consists of normal characters, which match themselves,\n       and meta-characters.  the meta-characters are \u00e2\u0080\u009c!\u00e2\u0080\u009d, \u00e2\u0080\u009c*\u00e2\u0080\u009d, \u00e2\u0080\u009c?\u00e2\u0080\u009d, and\n       \u00e2\u0080\u009c[\u00e2\u0080\u009d.  these characters lose their special meanings if they are\n       quoted.  when command or variable substitution is performed and\n       the dollar sign or back quotes are not double quoted, the value of\n       the variable or the output of the command is scanned for these\n       characters and they are turned into meta-characters.\n\n       an asterisk (\u00e2\u0080\u009c*\u00e2\u0080\u009d) matches any string of characters.  a question\n       mark matches any single character.  a left bracket (\u00e2\u0080\u009c[\u00e2\u0080\u009d)\n       introduces a character class.  the end of the character class is\n       indicated by a (\u00e2\u0080\u009c]\u00e2\u0080\u009d); if the \u00e2\u0080\u009c]\u00e2\u0080\u009d is missing then the \u00e2\u0080\u009c[\u00e2\u0080\u009d matches a\n       \u00e2\u0080\u009c[\u00e2\u0080\u009d rather than introducing a character class.  a character class\n       matches any of the characters between the square brackets.  a\n       range of characters may be specified using a minus sign.  the\n       character class may be complemented by making an exclamation point\n       the first character of the character class.\n\n       to include a \u00e2\u0080\u009c]\u00e2\u0080\u009d in a character class, make it the first character\n       listed (after the \u00e2\u0080\u009c!\u00e2\u0080\u009d, if any).  to include a minus sign, make it\n       the first or last character listed.\nbuiltins\nthis section lists the builtin commands which are builtin because\n       they need to perform some operation that can't be performed by a\n       separate process.  in addition to these, there are several other\n       commands that may be builtin for efficiency (e.g.\nprintf\n(1),\necho\n(1),\ntest\n(1), etc).\n\n       :\n\n       true   a null command that returns a 0 (true) exit value.\n\n       false  a null command that returns a 1 (false) exit value.\n\n       . file\n              the commands in the specified file are read and executed by\n              the shell.\n\n       alias [\nname\n[\n=string ...\n]]\n              if\nname=string\nis specified, the shell defines the alias\nname\nwith value\nstring\n.  if just\nname\nis specified, the\n              value of the alias\nname\nis printed.  with no arguments, the\nalias\nbuiltin prints the names and values of all defined\n              aliases (see\nunalias\n).\n\n       bg [\njob\n]\n...\ncontinue the specified jobs (or the current job if no jobs\n              are given) in the background.\n\n       command [\n-p\n] [\n-v\n] [\n-v\n]\ncommand\n[\narg ...\n]\n              execute the specified command but ignore shell functions\n              when searching for it.  (this is useful when you have a\n              shell function with the same name as a builtin command.)\n-p\nsearch for command using a path that guarantees to\n                     find all the standard utilities.\n-v\ndo not execute the command but search for the\n                     command and print the resolution of the command\n                     search.  this is the same as the type builtin.\n-v\ndo not execute the command but search for the\n                     command and print the absolute pathname of\n                     utilities, the name for builtins or the expansion of\n                     aliases.\n\n       cd|chdir\n-\ncd|chdir [\n-lp\n] [\ndirectory\n]\n              switch to the specified directory (default home).  if an\n              entry for cdpath appears in the environment of the\ncd\ncommand or the shell variable cdpath is set and the\n              directory name does not begin with a slash, then the\n              directories listed in cdpath will be searched for the\n              specified directory.  the format of cdpath is the same as\n              that of path.  if a single dash is specified as the\n              argument, it will be replaced by the value of oldpwd.  the\ncd\ncommand will print out the name of the directory that it\n              actually switched to if this is different from the name\n              that the user gave.  these may be different either because\n              the cdpath mechanism was used or because the argument is a\n              single dash.  the\n-p\noption causes the physical directory\n              structure to be used, that is, all symbolic links are\n              resolved to their respective values.  the\n-l\noption turns\n              off the effect of any preceding\n-p\noptions.\n\n       echo [\n-n\n]\nargs...\nprint the arguments on the standard output, separated by\n              spaces.  unless the\n-n\noption is present, a newline is\n              output following the arguments.\n\n              if any of the following sequences of characters is\n              encountered during output, the sequence is not output.\n              instead, the specified action is performed:\n\\b\na backspace character is output.\n\\c\nsubsequent output is suppressed.  this is normally\n                      used at the end of the last argument to suppress\n                      the trailing newline that\necho\nwould otherwise\n                      output.\n\\f\noutput a form feed.\n\\n\noutput a newline character.\n\\r\noutput a carriage return.\n\\t\noutput a (horizontal) tab character.\n\\v\noutput a vertical tab.\n\\0\ndigits\noutput the character whose value is given by zero\n                      to three octal digits.  if there are zero digits, a\n                      nul character is output.\n\\\\\noutput a backslash.\n\n              all other backslash sequences elicit undefined behaviour.\n\n       eval\nstring ...\nconcatenate all the arguments with spaces.  then re-parse\n              and execute the command.\n\n       exec [\ncommand arg ...\n]\n              unless command is omitted, the shell process is replaced\n              with the specified program (which must be a real program,\n              not a shell builtin or function).  any redirections on the\nexec\ncommand are marked as permanent, so that they are not\n              undone when the\nexec\ncommand finishes.\n\n       exit [\nexitstatus\n]\n              terminate the shell process.  if\nexitstatus\nis given it is\n              used as the exit status of the shell; otherwise the exit\n              status of the preceding command is used.\n\n       export\nname ...\nexport\n-p\nthe specified names are exported so that they will appear\n              in the environment of subsequent commands.  the only way to\n              un-export a variable is to unset it.  the shell allows the\n              value of a variable to be set at the same time it is\n              exported by writing\nexport name=value\nwith no arguments the export command lists the names of all\n              exported variables.  with the\n-p\noption specified the\n              output will be formatted suitably for non-interactive use.\n\n       fc [\n-e\neditor\n] [\nfirst\n[\nlast\n]]\n\n       fc\n-l\n[\n-nr\n] [\nfirst\n[\nlast\n]]\n\n       fc\n-s\n[\nold=new\n] [\nfirst\n]\n              the\nfc\nbuiltin lists, or edits and re-executes, commands\n              previously entered to an interactive shell.\n-e\neditor\n                     use the editor named by editor to edit the commands.\n                     the editor string is a command name, subject to\n                     search via the path variable.  the value in the\n                     fcedit variable is used as a default when\n-e\nis not\n                     specified.  if fcedit is null or unset, the value of\n                     the editor variable is used.  if editor is null or\n                     unset,\ned\n(1) is used as the editor.\n-l\n(ell)\n                     list the commands rather than invoking an editor on\n                     them.  the commands are written in the sequence\n                     indicated by the first and last operands, as\n                     affected by\n-r\n, with each command preceded by the\n                     command number.\n-n\nsuppress command numbers when listing with -l.\n-r\nreverse the order of the commands listed (with\n-l\n)\n                     or edited (with neither\n-l\nnor\n-s\n).\n-s\nre-execute the command without invoking an editor.\n\n              first\n\n              last   select the commands to list or edit.  the number of\n                     previous commands that can be accessed are\n                     determined by the value of the histsize variable.\n                     the value of first or last or both are one of the\n                     following:\n\n                     [+]number\n                            a positive number representing a command\n                            number; command numbers can be displayed with\n                            the\n-l\noption.\n-number\na negative decimal number representing the\n                            command that was executed number of commands\n                            previously.  for example, -1 is the\n                            immediately previous command.\n\n              string\n                     a string indicating the most recently entered\n                     command that begins with that string.  if the\n                     old=new operand is not also specified with\n-s\n, the\n                     string form of the first operand cannot contain an\n                     embedded equal sign.\n\n              the following environment variables affect the execution of\n              fc:\n\n              fcedit    name of the editor to use.\n\n              histsize  the number of previous commands that are\n                        accessible.\n\n       fg [\njob\n]\n              move the specified job or the current job to the\n              foreground.\n\n       getopts\noptstring var\n[\narg ...\n]\n              the posix\ngetopts\ncommand, not to be confused with the\nbell\nlabs\n-derived\ngetopt\n(1).\n\n              the first argument should be a series of letters, each of\n              which may be optionally followed by a colon to indicate\n              that the option requires an argument.  the variable\n              specified is set to the parsed option.\n\n              the\ngetopts\ncommand deprecates the older\ngetopt\n(1) utility\n              due to its handling of arguments containing whitespace.\n\n              the\ngetopts\nbuiltin may be used to obtain options and their\n              arguments from a list of parameters.  when invoked,\ngetopts\nplaces the value of the next option from the option string\n              in the list in the shell variable specified by\nvar\nand its\n              index in the shell variable optind.  when the shell is\n              invoked, optind is initialized to 1.  for each option that\n              requires an argument, the\ngetopts\nbuiltin will place it in\n              the shell variable optarg.  if an option is not allowed for\n              in the\noptstring\n, then optarg will be unset.\n\n              by default, the variables\n$1\n,\n...\n,\n$n\nare inspected; if\narg\ns are specified, they'll be parsed instead.\noptstring\nis a string of recognized option letters (see\ngetopt\n(3)).  if a letter is followed by a colon, the option\n              is expected to have an argument which may or may not be\n              separated from it by white space.  if an option character\n              is not found where expected,\ngetopts\nwill set the variable\nvar\nto a \u00e2\u0080\u009c?\u00e2\u0080\u009d;\ngetopts\nwill then unset optarg and write\n              output to standard error.  by specifying a colon as the\n              first character of\noptstring\nall errors will be ignored.\n\n              after the last option\ngetopts\nwill return a non-zero value\n              and set\nvar\nto \u00e2\u0080\u009c?\u00e2\u0080\u009d.\n\n              the following code fragment shows how one might process the\n              arguments for a command that can take the options [a] and\n              [b], and the option [c], which requires an argument.\n\n                    while getopts abc: f\n                    do\n                            case $f in\n                            a | b)  flag=$f;;\n                            c)      carg=$optarg;;\n                            \\?)     echo $usage; exit 1;;\n                            esac\n                    done\n                    shift $((optind - 1))\n\n              this code will accept any of the following as equivalent:\n\n                    cmd -acarg file file\n                    cmd -a -c arg file file\n                    cmd -carg -a file file\n                    cmd -a -carg -- file file\n\n       hash [\ncommand ...\n]\n\n       hash\n-r\nthe shell maintains a hash table which remembers the\n              locations of commands.  with no arguments whatsoever, the\nhash\ncommand prints out the contents of this table.\n              entries which have not been looked at since the last\ncd\ncommand are marked with an asterisk; it is possible for\n              these entries to be invalid.\n\n              with arguments, the\nhash\ncommand removes the specified\n              commands from the hash table (unless they are functions)\n              and then locates them.  the\n-r\noption causes the hash\n              command to delete all the entries in the hash table except\n              for functions.\n\n       jobs [\n-lp\n] [\njob ...\n]\n              display the status of all, or just the specified,\njob\ns:\n                   by default  display the job number, currency (\n+-\n)\n                               status, if any, the job state, and its\n                               shell command.\n-l\nalso output the pid of the group leader,\n                               and just the pid and shell commands of\n                               other members of the job.\n-p\ndisplay only leader pids, one per line.\n\n       kill [\n-s\nsigspec\n|\n-\nsignum\n|\n-\nsigspec\n] [\npid\n|\njob ...\n]\n              equivalent to\nkill\n(1), but a\njob\nspec may also be\n              specified.  signals can be either case-insensitive names\n              without sig prefixes or decimal numbers; the default is\n              term.\n\n       kill\n-l\n[\nsignum\n|\nexitstatus\n]\n              list available signal names without the sig prefix\n              (\nsigspec\ns).  if\nsignum\nspecified, display just the\nsigspec\nfor that signal.  if\nexitstatus\nspecified (>\n128\n), display\n              just the\nsigspec\nthat caused it.\n\n       pwd [\n-lp\n]\n              builtin command remembers what the current directory is\n              rather than recomputing it each time.  this makes it\n              faster.  however, if the current directory is renamed, the\n              builtin version of\npwd\nwill continue to print the old name\n              for the directory.  the\n-p\noption causes the physical value\n              of the current working directory to be shown, that is, all\n              symbolic links are resolved to their respective values.\n              the\n-l\noption turns off the effect of any preceding\n-p\noptions.\n\n       read [\n-p\nprompt\n] [\n-r\n]\nvariable\n[\n...\n]\n              the prompt is printed if the\n-p\noption is specified and the\n              standard input is a terminal.  then a line is read from the\n              standard input.  the trailing newline is deleted from the\n              line and the line is split as described in the section on\n              word splitting above, and the pieces are assigned to the\n              variables in order.  at least one variable must be\n              specified.  if there are more pieces than variables, the\n              remaining pieces (along with the characters in ifs that\n              separated them) are assigned to the last variable.  if\n              there are more variables than pieces, the remaining\n              variables are assigned the null string.  the\nread\nbuiltin\n              will indicate success unless eof is encountered on input,\n              in which case failure is returned.\n\n              by default, unless the\n-r\noption is specified, the\n              backslash \u00e2\u0080\u009c\\\u00e2\u0080\u009d acts as an escape character, causing the\n              following character to be treated literally.  if a\n              backslash is followed by a newline, the backslash and the\n              newline will be deleted.\n\n       readonly\nname ...\nreadonly\n-p\nthe specified names are marked as read only, so that they\n              cannot be subsequently modified or unset.  the shell allows\n              the value of a variable to be set at the same time it is\n              marked read only by writing\nreadonly name=value\nwith no arguments the readonly command lists the names of\n              all read only variables.  with the\n-p\noption specified the\n              output will be formatted suitably for non-interactive use.\n\n       printf\nformat\n[\nvalue\n]...\nprintf\nformats and prints its arguments according to\nformat\n, a character string which contains three types of\n              objects: plain characters, which are simply copied to\n              standard output, character escape sequences which are\n              converted and copied to the standard output, and format\n              specifications, each of which causes printing of the next\n              successive\nvalue\n.\n\n              each\nvalue\nis treated as a string if the corresponding\n              format specification is either\nb\n,\nc\n, or\ns\n; otherwise it is\n              evaluated as a c constant, with the following additions:\n\u00e2\u0080\u00a2\na leading plus or minus sign is allowed.\n\u00e2\u0080\u00a2\nif the leading character is a single or double\n                        quote, the value of the next byte.\n\n              the format string is reused as often as necessary until all\nvalue\ns are consumed.  any extra format specifications are\n              evaluated with zero or the null string.\n\n              character escape sequences are in backslash notation as\n              defined in ansi x3.159-1989 (\u00e2\u0080\u009cansi c89\u00e2\u0080\u009d).  the characters\n              and their meanings are as follows:\n\\a\nwrite a <bell> character.\n\\b\nwrite a <backspace> character.\n\\f\nwrite a <form-feed> character.\n\\n\nwrite a <new-line> character.\n\\r\nwrite a <carriage return> character.\n\\t\nwrite a <tab> character.\n\\v\nwrite a <vertical tab> character.\n\\\\\nwrite a backslash character.\n\\\nnum\nwrite an 8-bit character whose ascii value is\n                            the 1-, 2-, or 3-digit octal number\nnum\n.\n\n              each format specification is introduced by the percent\n              character (``%'').  the remainder of the format\n              specification includes, in the following order:\n\n              zero or more of the following flags:\n#\na `#' character specifying that the value\n                              should be printed in an ``alternative\n                              form''.  for\nb\n,\nc\n,\nd\n, and\ns\nformats, this\n                              option has no effect.  for the\no\nformat the\n                              precision of the number is increased to\n                              force the first character of the output\n                              string to a zero.  for the\nx\n(\nx\n) format, a\n                              non-zero result has the string\n0x\n(\n0x\n)\n                              prepended to it.  for\ne\n,\ne\n,\nf\n,\ng\n, and\ng\nformats, the result will always contain a\n                              decimal point, even if no digits follow the\n                              point (normally, a decimal point only\n                              appears in the results of those formats if\n                              a digit follows the decimal point).  for\ng\nand\ng\nformats, trailing zeros are not\n                              removed from the result as they would\n                              otherwise be.\n-\na minus sign `-' which specifies\nleft\nadjustment\nof the output in the indicated\n                              field;\n+\na `+' character specifying that there\n                              should always be a sign placed before the\n                              number when using signed formats.\n\n                      \u00e2\u0080\u0098 \u00e2\u0080\u0099     a space specifying that a blank should be\n                              left before a positive number for a signed\n                              format.  a `+' overrides a space if both\n                              are used;\n0\na zero `0' character indicating that zero-\n                              padding should be used rather than blank-\n                              padding.  a `-' overrides a `0' if both are\n                              used;\n\n              field width:\n                      an optional digit string specifying a\nfield width\n;\n                      if the output string has fewer characters than the\n                      field width it will be blank-padded on the left (or\n                      right, if the left-adjustment indicator has been\n                      given) to make up the field width (note that a\n                      leading zero is a flag, but an embedded zero is\n                      part of a field width);\n\n              precision:\n                      an optional period, \u00e2\u0080\u0098\n.\n\u00e2\u0080\u0099, followed by an optional\n                      digit string giving a\nprecision\nwhich specifies the\n                      number of digits to appear after the decimal point,\n                      for\ne\nand\nf\nformats, or the maximum number of bytes\n                      to be printed from a string (\nb\nand\ns\nformats); if\n                      the digit string is missing, the precision is\n                      treated as zero;\n\n              format:\n                      a character which indicates the type of format to\n                      use (one of\ndiouxxfweggbcs\n).\n\n              a field width or precision may be \u00e2\u0080\u0098\n*\n\u00e2\u0080\u0099 instead of a digit\n              string.  in this case an\nargument\nsupplies the field width\n              or precision.\n\n              the format characters and their meanings are:\ndiouxx\nthe\nargument\nis printed as a signed decimal (d\n                          or i), unsigned octal, unsigned decimal, or\n                          unsigned hexadecimal (x or x), respectively.\nf\nthe\nargument\nis printed in the style [-]ddd\n.\nddd\n                          where the number of d's after the decimal point\n                          is equal to the precision specification for the\n                          argument.  if the precision is missing, 6\n                          digits are given; if the precision is\n                          explicitly 0, no digits and no decimal point\n                          are printed.\nee\nthe\nargument\nis printed in the style\n                          [-]d\n.\nddd\ne\n\u00e2\u00b1dd where there is one digit before\n                          the decimal point and the number after is equal\n                          to the precision specification for the\n                          argument; when the precision is missing, 6\n                          digits are produced.  an upper-case e is used\n                          for an `e' format.\ngg\nthe\nargument\nis printed in style\nf\nor in style\ne\n(\ne\n) whichever gives full precision in minimum\n                          space.\nb\ncharacters from the string\nargument\nare printed\n                          with backslash-escape sequences expanded.\n                          the following additional backslash-escape\n                          sequences are supported:\n\\c\ncauses\ndash\nto ignore any remaining\n                                  characters in the string operand\n                                  containing it, any remaining string\n                                  operands, and any additional characters\n                                  in the format operand.\n\\0\nnum\nwrite an 8-bit character whose ascii\n                                  value is the 1-, 2-, or 3-digit octal\n                                  number\nnum\n.\nc\nthe first character of\nargument\nis printed.\ns\ncharacters from the string\nargument\nare printed\n                          until the end is reached or until the number of\n                          bytes indicated by the precision specification\n                          is reached; if the precision is omitted, all\n                          characters in the string are printed.\n%\nprint a `%'; no argument is used.\n\n              in no case does a non-existent or small field width cause\n              truncation of a field; padding takes place only if the\n              specified field width exceeds the actual width.\n\n       set [{\n-options\n|\n+options\n|\n-- }\n]\narg ...\nthe\nset\ncommand performs three different functions.\n\n              with no arguments, it lists the values of all shell\n              variables.\n\n              if options are given, it sets the specified option flags,\n              or clears them as described in the section called \u00e2\u0080\u009cargument\n              list processing\u00e2\u0080\u009d.  as a special case, if the option is -o\n              or +o and no argument is supplied, the shell prints the\n              settings of all its options.  if the option is -o, the\n              settings are printed in a human-readable format; if the\n              option is +o, the settings are printed in a format suitable\n              for reinput to the shell to affect the same option\n              settings.\n\n              in addition to the option names listed in the \u00e2\u0080\u009cargument\n              list processing\u00e2\u0080\u009d section, the following options may be\n              specified as arguments to -o or +o:\npipefail\nderive the exit status of a pipeline from the\n                        exit statuses of all of the commands in the\n                        pipeline, not just the last command, as described\n                        in the \u00e2\u0080\u009cpipelines\u00e2\u0080\u009d section.\n\n              the third use of the set command is to set the values of\n              the shell's positional parameters to the specified args.\n              to change the positional parameters without changing any\n              options, use \u00e2\u0080\u009c--\u00e2\u0080\u009d as the first argument to set.  if no args\n              are present, the set command will clear all the positional\n              parameters (equivalent to executing \u00e2\u0080\u009cshift $#\u00e2\u0080\u009d.)\n\n       shift [\nn\n]\n              shift the positional parameters n times.  a\nshift\nsets the\n              value of\n$1\nto the value of\n$2\n, the value of\n$2\nto the\n              value of\n$3\n, and so on, decreasing the value of\n$#\nby one.\n              if n is greater than the number of positional parameters,\nshift\nwill issue an error message, and exit with return\n              status 2.\n\n       test\nexpression\n[\nexpression\n]\nthe\ntest\nutility evaluates the expression and, if it\n              evaluates to true, returns a zero (true) exit status;\n              otherwise it returns 1 (false).  if there is no expression,\n              test also returns 1 (false).\n\n              all operators and flags are separate arguments to the\ntest\nutility.\n\n              the following primaries are used to construct expression:\n-b\nfile\ntrue if\nfile\nexists and is a block special\n                            file.\n-c\nfile\ntrue if\nfile\nexists and is a character\n                            special file.\n-d\nfile\ntrue if\nfile\nexists and is a directory.\n-e\nfile\ntrue if\nfile\nexists (regardless of type).\n-f\nfile\ntrue if\nfile\nexists and is a regular file.\n-g\nfile\ntrue if\nfile\nexists and its set group id flag\n                            is set.\n-h\nfile\ntrue if\nfile\nexists and is a symbolic link.\n-k\nfile\ntrue if\nfile\nexists and its sticky bit is\n                            set.\n-n\nstring\ntrue if the length of\nstring\nis nonzero.\n-p\nfile\ntrue if\nfile\nis a named pipe (fifo).\n-r\nfile\ntrue if\nfile\nexists and is readable.\n-s\nfile\ntrue if\nfile\nexists and has a size greater\n                            than zero.\n-t\nfile_descriptor\ntrue if the file whose file descriptor number\n                            is\nfile_descriptor\nis open and is associated\n                            with a terminal.\n-u\nfile\ntrue if\nfile\nexists and its set user id flag\n                            is set.\n-w\nfile\ntrue if\nfile\nexists and is writable.  true\n                            indicates only that the write flag is on.\n                            the file is not writable on a read-only file\n                            system even if this test indicates true.\n-x\nfile\ntrue if\nfile\nexists and is executable.  true\n                            indicates only that the execute flag is on.\n                            if\nfile\nis a directory, true indicates that\nfile\ncan be searched.\n-z\nstring\ntrue if the length of\nstring\nis zero.\n-l\nfile\ntrue if\nfile\nexists and is a symbolic link.\n                            this operator is retained for compatibility\n                            with previous versions of this program.  do\n                            not rely on its existence; use\n-h\ninstead.\n-o\nfile\ntrue if\nfile\nexists and its owner matches the\n                            effective user id of this process.\n-g\nfile\ntrue if\nfile\nexists and its group matches the\n                            effective group id of this process.\n-s\nfile\ntrue if\nfile\nexists and is a socket.\nfile1\n-nt\nfile2\ntrue if\nfile1\nand\nfile2\nexist and\nfile1\nis\n                            newer than\nfile2\n, or if\nfile1\nexists but\nfile2\ndoesn't.\nfile1\n-ot\nfile2\ntrue if\nfile1\nand\nfile2\nexist and\nfile1\nis\n                            older than\nfile2\n, or if\nfile2\nexists but\nfile1\ndoesn't.\nfile1\n-ef\nfile2\ntrue if\nfile1\nand\nfile2\nexist and refer to\n                            the same file.\nstring\ntrue if\nstring\nis not the null string.\ns1\n=\ns2\ntrue if the strings\ns1\nand\ns2\nare identical.\ns1\n!=\ns2\ntrue if the strings\ns1\nand\ns2\nare not\n                            identical.\ns1\n<\ns2\ntrue if string\ns1\ncomes before\ns2\nbased on\n                            the ascii value of their characters.\ns1\n>\ns2\ntrue if string\ns1\ncomes after\ns2\nbased on the\n                            ascii value of their characters.\nn1\n-eq\nn2\ntrue if the integers\nn1\nand\nn2\nare\n                            algebraically equal.\nn1\n-ne\nn2\ntrue if the integers\nn1\nand\nn2\nare not\n                            algebraically equal.\nn1\n-gt\nn2\ntrue if the integer\nn1\nis algebraically\n                            greater than the integer\nn2\n.\nn1\n-ge\nn2\ntrue if the integer\nn1\nis algebraically\n                            greater than or equal to the integer\nn2\n.\nn1\n-lt\nn2\ntrue if the integer\nn1\nis algebraically less\n                            than the integer\nn2\n.\nn1\n-le\nn2\ntrue if the integer\nn1\nis algebraically less\n                            than or equal to the integer\nn2\n.\n\n              these primaries can be combined with the following\n              operators:\n!\nexpression\ntrue if\nexpression\nis false.\nexpression1\n-a\nexpression2\ntrue if both\nexpression1\nand\nexpression2\nare\n                            true.\nexpression1\n-o\nexpression2\ntrue if either\nexpression1\nor\nexpression2\nare\n                            true.\n(\nexpression\n)\ntrue if expression is true.\n\n              the\n-a\noperator has higher precedence than the\n-o\noperator.\n\n       times  print the accumulated user and system times for the shell\n              and for processes run from the shell.  the return status is\n              0.\n\n       trap [\naction signal ...\n]\n              cause the shell to parse and execute action when any of the\n              specified signals are received.  the signals are specified\n              by signal number or as the name of the signal.  if\nsignal\nis\n0\nor\nexit\n, the action is executed when the shell exits\n              normally (that is not via an unhandled signal like sigint).\naction\nmay be empty (\n''\n), which causes the specified\n              signals to be ignored.  with\naction\nomitted or set to `-'\n              the specified signals are set to their default action.\n              when the shell forks off a subshell, it resets trapped (but\n              not ignored) signals to the default action.  the\ntrap\ncommand has no effect on signals that were ignored on entry\n              to the shell.\ntrap\nwithout any arguments cause it to write\n              a list of signals and their associated action to the\n              standard output in a format that is suitable as an input to\n              the shell that achieves the same trapping results.\n\n              examples:\ntrap\nlist trapped signals and their corresponding action\ntrap '' int quit tstp 30\nignore signals int quit tstp usr1\ntrap date int\nprint date upon receiving signal int\n\n       type [\nname ...\n]\n              interpret each name as a command and print the resolution\n              of the command search.  possible resolutions are: shell\n              keyword, alias, shell builtin, command, tracked alias and\n              not found.  for aliases the alias expansion is printed; for\n              commands and tracked aliases the complete pathname of the\n              command is printed.\n\n       ulimit [\n-h\n|\n-s\n] [\n-a\n|\n-tfdscmlpnvwr\n[\nvalue\n]]\n              inquire about or set the hard or soft limits on processes\n              or set new limits.  the choice between hard limit (which no\n              process is allowed to violate, and which may not be raised\n              once it has been lowered) and soft limit (which causes\n              processes to be signaled but not necessarily killed, and\n              which may be raised) is made with these flags:\n-h\nset or inquire about hard limits\n-s\nset or inquire about soft limits.  if neither\n-h\nnor\n-s\nis specified, the soft limit is\n                          displayed or both limits are set.  if both are\n                          specified, the last one wins.\n\n              the limit to be interrogated or set, then, is chosen by\n              specifying any one of these flags:\n-a\nshow all the current limits\n-t\nshow or set the limit on cpu time (in seconds)\n-f\nshow or set the limit on the largest file that\n                          can be created (in 512-byte blocks)\n-d\nshow or set the limit on the data segment size\n                          of a process (in kilobytes)\n-s\nshow or set the limit on the stack size of a\n                          process (in kilobytes)\n-c\nshow or set the limit on the largest core dump\n                          size that can be produced (in 512-byte blocks)\n-m\nshow or set the limit on the total physical\n                          memory that can be in use by a process (in\n                          kilobytes)\n-l\nshow or set the limit on how much memory a\n                          process can lock with\nmlock\n(2) (in kilobytes)\n-p\nshow or set the limit on the number of\n                          processes this user can have at one time\n-n\nshow or set the limit on the number files a\n                          process can have open at once\n-v\nshow or set the limit on the total virtual\n                          memory that can be in use by a process (in\n                          kilobytes)\n-w\nshow or set the limit on the total number of\n                          locks held by a process\n-r\nshow or set the limit on the real-time\n                          scheduling priority of a process\n\n              if none of these is specified, it is the limit on file size\n              that is shown or set.  if\nvalue\nis specified, the limit is\n              set to that number; otherwise the current limit is\n              displayed.  the special\nvalue\nunlimited\nrepresents the lack\n              of any limit.\n\n              limits of an arbitrary process can be displayed or set\n              using the\nsysctl\n(8) utility.\n\n       umask [\nmask\n]\n              set the value of umask (see\numask\n(2)) to the specified\n              octal value.  if the argument is omitted, the umask value\n              is printed.\n\n       unalias [\n-a\n] [\nname\n]\n              if\nname\nis specified, the shell removes that alias.  if\n-a\nis specified, all aliases are removed.\n\n       unset [\n-fv\n]\nname ...\nthe specified variables and functions are unset and\n              unexported.  if\n-f\nor\n-v\nis specified, the corresponding\n              function or variable is unset, respectively.  if a given\n              name corresponds to both a variable and a function, and no\n              options are given, only the variable is unset.\n\n       wait [\njob\n]\n              wait for the specified job to complete and return the exit\n              status of the last process in the job.  if the argument is\n              omitted, wait for all jobs to complete and return an exit\n              status of zero.\ncommand line editing\nwhen\ndash\nis being used interactively from a terminal, the current\n       command and the command history (see\nfc\nin \u00e2\u0080\u009cbuiltins\u00e2\u0080\u009d) can be\n       edited using vi-mode command-line editing.  this mode uses\n       commands, described below, similar to a subset of those described\n       in the vi man page.  the command \u00e2\u0080\u0098set -o vi\u00e2\u0080\u0099 enables vi-mode\n       editing and places sh into vi insert mode.  with vi-mode enabled,\n       sh can be switched between insert mode and command mode.  it is\n       similar to vi: typing \u00e2\u009f\u00a8esc\u00e2\u009f\u00a9 enters vi command mode.  hitting\n       \u00e2\u009f\u00a8return\u00e2\u009f\u00a9 while in command mode will pass the line to the shell.\nRelevant sections:\n- \n\n---\n\nCommand: top\nDescription: the\ntop\nprogram provides a dynamic real-time view of a running\n       system.  it can display\nsystem\nsummary information as well as a\n       list of\nprocesses\nor\nthreads\ncurrently being managed by the linux\n       kernel.  the types of system summary information shown and the\n       types, order and size of information displayed for processes are\n       all user configurable and that configuration can be made\n       persistent across restarts.\n\n       the program provides a limited interactive interface for process\n       manipulation as well as a much more extensive interface for\n       personal configuration  --  encompassing every aspect of its\n       operation.  and while\ntop\nis referred to throughout this document,\n       you are free to name the program anything you wish.  that new\n       name, possibly an alias, will then be reflected on top's display\n       and used when reading and writing a configuration file.\nRelevant sections:\n- \n- \n\n---\n\n",
  "response": "Here's how to display your system's memory usage:\n\n### Command\n`free` -  Displays the total amount of free and used physical and swap memory in the system.\n\n### How it works\nThe `free` command parses `/proc/meminfo` to gather memory statistics. By default, it shows memory in kilobytes.\n\n### Examples\n\n1.  Display memory usage in a human-readable format (megabytes):\n    ```\n    free -m\n    ```\n\n2.  Continuously display memory usage, updating every 3 seconds:\n    ```\n    free -w -s 3\n    ```\n\n### Key Options\n\n*   `-m`: Displays memory in megabytes.\n*   `-g`: Displays memory in gigabytes.\n*   `-h`: Shows output in human-readable format (automatically scales to KB, MB, or GB).  This is often the most convenient.\n*   `-s <seconds>`:  Continuously updates the display every `<seconds>` seconds.\n*   `-w`: Provides a wide output format, including the `buffers/cache` column, clarifying memory usage.\n",
  "analysis": {
    "query_analysis": {
      "intent": "To check and display the current memory usage statistics of the system.",
      "keywords": [
        "memory usage",
        "system",
        "display",
        "RAM",
        "available memory",
        "used memory"
      ],
      "reformulated_query": "How can I display the current memory usage of the system, including total, used, available, and cached memory in a human-readable format on a Unix-like operating system?",
      "original_query": "Display the system\u2019s memory usage.",
      "optimized_query": "Display the system\u2019s memory usage.",
      "optimization_metrics": {
        "precision": 1.0,
        "recall": 0,
        "f1_score": 0,
        "retrieval_time": 0.46231770515441895,
        "command_count": 5,
        "diverse_categories": 1,
        "query_specificity": 0.55,
        "overall_score": 0.6635507814089457
      }
    },
    "command_relevance": [
      {
        "command": "systemd-analyze",
        "relevance_score": 0.6000000000000001
      },
      {
        "command": "free",
        "relevance_score": 0.33333333333333337
      },
      {
        "command": "webvis",
        "relevance_score": 0.30000000000000004
      },
      {
        "command": "dash",
        "relevance_score": 0.30000000000000004
      },
      {
        "command": "top",
        "relevance_score": 0.30000000000000004
      }
    ]
  },
  "command_chains": {
    "next_commands": [
      "dash",
      "mariadb-admin",
      "mariadb-check",
      "mariadb-binlog",
      "mariadb-dump"
    ],
    "command_chains": [
      ""
    ]
  }
}
{
  "metadata": {
    "timestamp": "2025-04-18_17-35-54",
    "query_id": "query_2025-04-18_17-35-54",
    "original_query": "how to find the ip",
    "optimized_query": "How can I find or display the IP address of my system or a specific network interface using command-line tools in a Unix-like environment?",
    "query_intent": "To find the IP address of a system or network interface.",
    "keywords": [
      "IP address",
      "find",
      "display",
      "show",
      "network interface",
      "system"
    ],
    "optimization_metrics": {
      "precision": 1.0,
      "recall": 0,
      "f1_score": 0,
      "retrieval_time": 0.01950979232788086,
      "command_count": 5,
      "diverse_categories": 0,
      "query_specificity": 0.55,
      "overall_score": 0.619024510383606
    }
  },
  "retrieved_commands": [
    {
      "command": "systemd-analyze",
      "description": "systemd-analyze\nmay be used to determine system boot-up\n       performance statistics and retrieve other state and tracing\n       information from the system and service manager, and to verify the\n       correctness of unit files. it is also used to access special\n       functions useful for advanced system manager debugging.\n\n       if no command is passed,\nsystemd-analyze time\nis implied.\nsystemd-analyze time\nthis command prints the time spent in the kernel before userspace\n       has been reached, the time spent in the initrd before normal\n       system userspace has been reached, and the time normal system\n       userspace took to initialize. note that these measurements simply\n       measure the time passed up to the point where all system services\n       have been spawned, but not necessarily until they fully finished\n       initialization or the disk is idle.\nexample 1. show how long the boot took\n# in a container\n           $ systemd-analyze time\n           startup finished in 296ms (userspace)\n           multi-user.target reached after 275ms in userspace\n\n           # on a real machine\n           $ systemd-analyze time\n           startup finished in 2.584s (kernel) + 19.176s (initrd) + 47.847s (userspace) = 1min 9.608s\n           multi-user.target reached after 47.820s in userspace\nsystemd-analyze blame\nthis command prints a list of all running units, ordered by the\n       time they took to initialize. this information may be used to\n       optimize boot-up times. note that the output might be misleading\n       as the initialization of one service might be slow simply because\n       it waits for the initialization of another service to complete.\n       also note:\nsystemd-analyze blame\ndoes not display results for\n       services with\ntype=simple\n, because systemd considers such services\n       to be started immediately, hence no measurement of the\n       initialization delays can be done. also note that this command\n       only shows the time units took for starting up, it does not show\n       how long unit jobs spent in the execution queue. in particular it\n       shows the time units spent in \"activating\" state, which is not\n       defined for units such as device units that transition directly\n       from \"inactive\" to \"active\". this command hence gives an\n       impression of the performance of program code, but cannot\n       accurately reflect latency introduced by waiting for hardware and\n       similar events.\nexample 2. show which units took the most time during boot\n$ systemd-analyze blame\n                    32.875s pmlogger.service\n                    20.905s systemd-networkd-wait-online.service\n                    13.299s dev-vda1.device\n                    ...\n                       23ms sysroot.mount\n                       11ms initrd-udevadm-cleanup-db.service\n                        3ms sys-kernel-config.mount\nsystemd-analyze critical-chain [\nunit\n...]\n       this command prints a tree of the time-critical chain of units\n       (for each of the specified\nunit\ns or for the default target\n       otherwise). the time after the unit is active or started is\n       printed after the \"@\" character. the time the unit takes to start\n       is printed after the \"+\" character. note that the output might be\n       misleading as the initialization of services might depend on\n       socket activation and because of the parallel execution of units.\n       also, similarly to the\nblame\ncommand, this only takes into account\n       the time units spent in \"activating\" state, and hence does not\n       cover units that never went through an \"activating\" state (such as\n       device units that transition directly from \"inactive\" to\n       \"active\"). moreover, it does not show information on jobs (and in\n       particular not jobs that timed out).\nexample 3. systemd-analyze critical-chain\n$ systemd-analyze critical-chain\n           multi-user.target @47.820s\n           \u00e2\u0094\u0094\u00e2\u0094\u0080pmie.service @35.968s +548ms\n             \u00e2\u0094\u0094\u00e2\u0094\u0080pmcd.service @33.715s +2.247s\n               \u00e2\u0094\u0094\u00e2\u0094\u0080network-online.target @33.712s\n                 \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd-wait-online.service @12.804s +20.905s\n                   \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd.service @11.109s +1.690s\n                     \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-udevd.service @9.201s +1.904s\n                       \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-tmpfiles-setup-dev.service @7.306s +1.776s\n                         \u00e2\u0094\u0094\u00e2\u0094\u0080kmod-static-nodes.service @6.976s +177ms\n                           \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-journald.socket\n                             \u00e2\u0094\u0094\u00e2\u0094\u0080system.slice\n                               \u00e2\u0094\u0094\u00e2\u0094\u0080-.slice\nsystemd-analyze dump [\npattern\n...]\n       without any parameter, this command outputs a (usually very long)\n       human-readable serialization of the complete service manager\n       state. optional glob pattern may be specified, causing the output\n       to be limited to units whose names match one of the patterns. the\n       output format is subject to change without notice and should not\n       be parsed by applications. this command is rate limited for\n       unprivileged users.\nexample 4. show the internal state of user manager\n$ systemd-analyze --user dump\n           timestamp userspace: thu 2019-03-14 23:28:07 cet\n           timestamp finish: thu 2019-03-14 23:28:07 cet\n           timestamp generators-start: thu 2019-03-14 23:28:07 cet\n           timestamp generators-finish: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-start: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-finish: thu 2019-03-14 23:28:07 cet\n           -> unit proc-timer_list.mount:\n                   description: /proc/timer_list\n                   ...\n           -> unit default.target:\n                   description: main user target\n           ...\nsystemd-analyze malloc [\nd-bus service\n...]\n       this command can be used to request the output of the internal\n       memory state (as returned by\nmalloc_info(3)\n) of a d-bus service.\n       if no service is specified, the query will be sent to\n       org.freedesktop.systemd1 (the system or user service manager). the\n       output format is not guaranteed to be stable and should not be\n       parsed by applications.\n\n       the service must implement the org.freedesktop.memoryallocation1\n       interface. in the systemd suite, it is currently only implemented\n       by the manager.\nsystemd-analyze plot\nthis command prints either an svg graphic, detailing which system\n       services have been started at what time, highlighting the time\n       they spent on initialization, or the raw time data in json or\n       table format.\nexample 5. plot a bootchart\n$ systemd-analyze plot >bootup.svg\n           $ eog bootup.svg&\n\n       note that this plot is based on the most recent per-unit timing\n       data of loaded units. this means that if a unit gets started, then\n       stopped and then started again the information shown will cover\n       the most recent start cycle, not the first one. thus it is\n       recommended to consult this information only shortly after boot,\n       so that this distinction does not matter. moreover, units that are\n       not referenced by any other unit through a dependency might be\n       unloaded by the service manager once they terminate (and did not\n       fail). such units will not show up in the plot.\nsystemd-analyze dot [\npattern\n...]\n       this command generates textual dependency graph description in dot\n       format for further processing with the graphviz\ndot\n(1) tool. use a\n       command line like\nsystemd-analyze dot | dot -tsvg >systemd.svg\nto\n       generate a graphical dependency tree. unless\n--order\nor\n--require\nis passed, the generated graph will show both ordering and\n       requirement dependencies. optional pattern globbing style\n       specifications (e.g.  *.target) may be given at the end. a unit\n       dependency is included in the graph if any of these patterns match\n       either the origin or destination node.\nexample 6. plot all dependencies of any unit whose name starts\nwith \"avahi-daemon\"\n$ systemd-analyze dot 'avahi-daemon.*' | dot -tsvg >avahi.svg\n           $ eog avahi.svg\nexample 7. plot the dependencies between all known target units\n$ systemd-analyze dot --to-pattern='*.target' --from-pattern='*.target' \\\n                 | dot -tsvg >targets.svg\n           $ eog targets.svg\nsystemd-analyze unit-paths\nthis command outputs a list of all directories from which unit\n       files, .d overrides, and .wants, .requires symlinks may be loaded.\n       combine with\n--user\nto retrieve the list for the user manager\n       instance, and\n--global\nfor the global configuration of user\n       manager instances.\nexample 8. show all paths for generated units\n$ systemd-analyze unit-paths | grep '^/run'\n           /run/systemd/system.control\n           /run/systemd/transient\n           /run/systemd/generator.early\n           /run/systemd/system\n           /run/systemd/system.attached\n           /run/systemd/generator\n           /run/systemd/generator.late\n\n       note that this verb prints the list that is compiled into\nsystemd-analyze\nitself, and does not communicate with the running\n       manager. use\n\n           systemctl [--user] [--global] show -p unitpath --value\n\n       to retrieve the actual list that the manager uses, with any empty\n       directories omitted.\nsystemd-analyze exit-status [\nstatus\n...]\n       this command prints a list of exit statuses along with their\n       \"class\", i.e. the source of the definition (one of \"glibc\",\n       \"systemd\", \"lsb\", or \"bsd\"), see the process exit codes section in\nsystemd.exec(5)\n. if no additional arguments are specified, all\n       known statuses are shown. otherwise, only the definitions for the\n       specified codes are shown.\nexample 9. show some example exit status names\n$ systemd-analyze exit-status 0 1 {63..65}\n           name    status class\n           success 0      glibc\n           failure 1      glibc\n           -       63     -\n           usage   64     bsd\n           dataerr 65     bsd\nsystemd-analyze capability [\ncapability\n... | {-m | --mask}\nmask\n]\n       this command prints a list of linux capabilities along with their\n       numeric ids. see\ncapabilities(7)\nfor details. if no argument is\n       specified the full list of capabilities known to the service\n       manager and the kernel is shown. capabilities defined by the\n       kernel but not known to the service manager are shown as\n       \"cap_???\". optionally, if arguments are specified they may refer\n       to specific cabilities by name or numeric id, in which case only\n       the indicated capabilities are shown in the table.\n\n       alternatively, if\n--mask\nis passed, a single numeric argument must\n       be specified, which is interpreted as a hexadecimal capability\n       mask. in this case, only the capabilities present in the mask are\n       shown in the table. this mode is intended to aid in decoding\n       capability sets available via various debugging interfaces (e.g.\n       \"/proc/pid/status\").\nexample 10. show some example capability names\n$ systemd-analyze capability 0 1 {30..32}\n           name              number\n           cap_chown              0\n           cap_dac_override       1\n           cap_audit_control     30\n           cap_setfcap           31\n           cap_mac_override      32\nexample 11. decode a capability mask extracted from /proc\n$ systemd-analyze capability -m 0000000000003c00\n           name                 number\n           cap_net_bind_service     10\n           cap_net_broadcast        11\n           cap_net_admin            12\n           cap_net_raw              13\nsystemd-analyze condition\ncondition\n...\n       this command will evaluate\ncondition*=...\nand\nassert*=...\nassignments, and print their values, and the resulting value of\n       the combined condition set. see\nsystemd.unit(5)\nfor a list of\n       available conditions and asserts.\nexample 12. evaluate conditions that check kernel versions\n$ systemd-analyze condition 'conditionkernelversion = ! <4.0' \\\n                   'conditionkernelversion = >=5.1' \\\n                   'conditionacpower=|false' \\\n                   'conditionarchitecture=|!arm' \\\n                   'assertpathexists=/etc/os-release'\n           test.service: assertpathexists=/etc/os-release succeeded.\n           asserts succeeded.\n           test.service: conditionarchitecture=|!arm succeeded.\n           test.service: conditionacpower=|false failed.\n           test.service: conditionkernelversion=>=5.1 succeeded.\n           test.service: conditionkernelversion=!<4.0 succeeded.\n           conditions succeeded.\nsystemd-analyze syscall-filter [\nset\n...]\n       this command will list system calls contained in the specified\n       system call set\nset\n, or all known sets if no sets are specified.\n       argument\nset\nmust include the \"@\" prefix.\nsystemd-analyze filesystems [\nset\n...]\n       this command will list filesystems in the specified filesystem set\nset\n, or all known sets if no sets are specified. argument\nset\nmust\n       include the \"@\" prefix.\nsystemd-analyze calendar\nexpression\n...\n       this command will parse and normalize repetitive calendar time\n       events, and will calculate when they elapse next. this takes the\n       same input as the\noncalendar=\nsetting in\nsystemd.timer(5)\n,\n       following the syntax described in\nsystemd.time(7)\n. by default,\n       only the next time the calendar expression will elapse is shown;\n       use\n--iterations=\nto show the specified number of next times the\n       expression elapses. each time the expression elapses forms a\n       timestamp, see the\ntimestamp\nverb below.\nexample 13. show leap days in the near future\n$ systemd-analyze calendar --iterations=5 '*-2-29 0:0:0'\n             original form: *-2-29 0:0:0\n           normalized form: *-02-29 00:00:00\n               next elapse: sat 2020-02-29 00:00:00 utc\n                  from now: 11 months 15 days left\n                  iter. #2: thu 2024-02-29 00:00:00 utc\n                  from now: 4 years 11 months left\n                  iter. #3: tue 2028-02-29 00:00:00 utc\n                  from now: 8 years 11 months left\n                  iter. #4: sun 2032-02-29 00:00:00 utc\n                  from now: 12 years 11 months left\n                  iter. #5: fri 2036-02-29 00:00:00 utc\n                  from now: 16 years 11 months left\nsystemd-analyze timestamp\ntimestamp\n...\n       this command parses a timestamp (i.e. a single point in time) and\n       outputs the normalized form and the difference between this\n       timestamp and now. the timestamp should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing timestamps\".\nexample 14. show parsing of timestamps\n$ systemd-analyze timestamp yesterday now tomorrow\n             original form: yesterday\n           normalized form: mon 2019-05-20 00:00:00 cest\n                  (in utc): sun 2019-05-19 22:00:00 utc\n              unix seconds: @15583032000\n                  from now: 1 day 9h ago\n\n             original form: now\n           normalized form: tue 2019-05-21 09:48:39 cest\n                  (in utc): tue 2019-05-21 07:48:39 utc\n              unix seconds: @1558424919.659757\n                  from now: 43us ago\n\n             original form: tomorrow\n           normalized form: wed 2019-05-22 00:00:00 cest\n                  (in utc): tue 2019-05-21 22:00:00 utc\n              unix seconds: @15584760000\n                  from now: 14h left\nsystemd-analyze timespan\nexpression\n...\n       this command parses a time span (i.e. a difference between two\n       timestamps) and outputs the normalized form and the equivalent\n       value in microseconds. the time span should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing time spans\".\n       values without units are parsed as seconds.\nexample 15. show parsing of timespans\n$ systemd-analyze timespan 1s 300s '1year 0.000001s'\n           original: 1s\n                 \u00ee\u00bcs: 1000000\n              human: 1s\n\n           original: 300s\n                 \u00ee\u00bcs: 300000000\n              human: 5min\n\n           original: 1year 0.000001s\n                 \u00ee\u00bcs: 31557600000001\n              human: 1y 1us\nsystemd-analyze cat-config\nname\n|\npath\n...\n       this command is similar to\nsystemctl cat\n, but operates on config\n       files. it will copy the contents of a config file and any drop-ins\n       to standard output, using the usual systemd set of directories and\n       rules for precedence. each argument must be either an absolute\n       path including the prefix (such as /etc/systemd/logind.conf or\n       /usr/lib/systemd/logind.conf), or a name relative to the prefix\n       (such as systemd/logind.conf).\nexample 16. showing logind configuration\n$ systemd-analyze cat-config systemd/logind.conf\n           # /etc/systemd/logind.conf\n           ...\n           [login]\n           nautovts=8\n           ...\n\n           # /usr/lib/systemd/logind.conf.d/20-test.conf\n           ... some override from another package\n\n           # /etc/systemd/logind.conf.d/50-override.conf\n           ... some administrator override\nsystemd-analyze compare-versions\nversion1\n[\nop\n]\nversion2\nthis command has two distinct modes of operation, depending on\n       whether the operator\nop\nis specified.\n\n       in the first mode \u00e2\u0080\u0094 when\nop\nis not specified \u00e2\u0080\u0094, it will compare\n       the two version strings and print either \"\nversion1\n<\nversion2\n\", or\n       \"\nversion1\n==\nversion2\n\", or \"\nversion1\n>\nversion2\n\" as appropriate.\n\n       the exit status is\n0\nif the versions are equal,\n11\nif the version\n       of the right is smaller, and\n12\nif the version of the left is\n       smaller. (this matches the convention used by\nrpmdev-vercmp\n.)\n\n       in the second mode \u00e2\u0080\u0094 when\nop\nis specified \u00e2\u0080\u0094 it will compare the\n       two version strings using the operation\nop\nand return\n0\n(success)\n       if they condition is satisfied, and\n1\n(failure) otherwise.\nop\nmay\n       be\nlt\n,\nle\n,\neq\n,\nne\n,\nge\n,\ngt\n. in this mode, no output is printed.\n       (this matches the convention used by\ndpkg(1)\n--compare-versions\n.)\nexample 17. compare versions of a package\n$ systemd-analyze compare-versions systemd-250~rc1.fc36.aarch64 systemd-251.fc36.aarch64\n           systemd-250~rc1.fc36.aarch64 < systemd-251.fc36.aarch64\n           $ echo $?\n           12\n\n           $ systemd-analyze compare-versions 1 lt 2; echo $?\n           0\n           $ systemd-analyze compare-versions 1 ge 2; echo $?\n           1\nsystemd-analyze verify\nfile\n...\n       this command will load unit files and print warnings if any errors\n       are detected. files specified on the command line will be loaded,\n       but also any other units referenced by them. a unit's name on disk\n       can be overridden by specifying an alias after a colon; see below\n       for an example. the full unit search path is formed by combining\n       the directories for all command line arguments, and the usual unit\n       load paths. the variable\n$systemd_unit_path\nis supported, and may\n       be used to replace or augment the compiled in set of unit load\n       paths; see\nsystemd.unit(5)\n. all units files present in the\n       directories containing the command line arguments will be used in\n       preference to the other paths. if a template unit without an\n       instance name is specified (e.g.  foo@.service), \"test_instance\"\n       will be used as the instance name, which can be controlled by\n--instance=\noption.\n\n       the following errors are currently detected:\n\n       \u00e2\u0080\u00a2   unknown sections and directives,\n\n       \u00e2\u0080\u00a2   missing dependencies which are required to start the given\n           unit,\n\n       \u00e2\u0080\u00a2   man pages listed in\ndocumentation=\nwhich are not found in the\n           system,\n\n       \u00e2\u0080\u00a2   commands listed in\nexecstart=\nand similar which are not found\n           in the system or not executable.\nexample 18. misspelt directives\n$ cat ./user.slice\n           [unit]\n           whatisthis=11\n           documentation=man:nosuchfile(1)\n           requires=different.service\n\n           [service]\n           description=x\n\n           $ systemd-analyze verify ./user.slice\n           [./user.slice:9] unknown lvalue 'whatisthis' in section 'unit'\n           [./user.slice:13] unknown section 'service'. ignoring.\n           error: org.freedesktop.systemd1.loadfailed:\n              unit different.service failed to load:\n              no such file or directory.\n           failed to create user.slice/start: invalid argument\n           user.slice: man nosuchfile(1) command failed with code 16\nexample 19. missing service units\n$ tail ./a.socket ./b.socket\n           ==> ./a.socket <==\n           [socket]\n           listenstream=100\n\n           ==> ./b.socket <==\n           [socket]\n           listenstream=100\n           accept=yes\n\n           $ systemd-analyze verify ./a.socket ./b.socket\n           service a.service not loaded, a.socket cannot be started.\n           service b@0.service not loaded, b.socket cannot be started.\nexample 20. aliasing a unit\n$ cat /tmp/source\n           [unit]\n           description=hostname printer\n\n           [service]\n           type=simple\n           execstart=/usr/bin/echo %h\n           mysterykey=true\n\n           $ systemd-analyze verify /tmp/source\n           failed to prepare filename /tmp/source: invalid argument\n\n           $ systemd-analyze verify /tmp/source:alias.service\n           alias.service:7: unknown key name 'mysterykey' in section 'service', ignoring.\nsystemd-analyze security [\nunit\n...]\n       this command analyzes the security and sandboxing settings of one\n       or more specified service units. if at least one unit name is\n       specified the security settings of the specified service units are\n       inspected and a detailed analysis is shown. if no unit name is\n       specified, all currently loaded, long-running service units are\n       inspected and a terse table with results shown. the command checks\n       for various security-related service settings, assigning each a\n       numeric \"exposure level\" value, depending on how important a\n       setting is. it then calculates an overall exposure level for the\n       whole unit, which is an estimation in the range 0.0...10.0\n       indicating how exposed a service is security-wise. high exposure\n       levels indicate very little applied sandboxing. low exposure\n       levels indicate tight sandboxing and strongest security\n       restrictions. note that this only analyzes the per-service\n       security features systemd itself implements. this means that any\n       additional security mechanisms applied by the service code itself\n       are not accounted for. the exposure level determined this way\n       should not be misunderstood: a high exposure level neither means\n       that there is no effective sandboxing applied by the service code\n       itself, nor that the service is actually vulnerable to remote or\n       local attacks. high exposure levels do indicate however that most\n       likely the service might benefit from additional settings applied\n       to them.\n\n       please note that many of the security and sandboxing settings\n       individually can be circumvented \u00e2\u0080\u0094 unless combined with others.\n       for example, if a service retains the privilege to establish or\n       undo mount points many of the sandboxing options can be undone by\n       the service code itself. due to that is essential that each\n       service uses the most comprehensive and strict sandboxing and\n       security settings possible. the tool will take into account some\n       of these combinations and relationships between the settings, but\n       not all. also note that the security and sandboxing settings\n       analyzed here only apply to the operations executed by the service\n       code itself. if a service has access to an ipc system (such as\n       d-bus) it might request operations from other services that are\n       not subject to the same restrictions. any comprehensive security\n       and sandboxing analysis is hence incomplete if the ipc access\n       policy is not validated too.\nexample 21. analyze systemd-logind.service\n$ systemd-analyze security --no-pager systemd-logind.service\n             name                description                              exposure\n           \u00e2\u009c\u0097 privatenetwork=     service has access to the host's network      0.5\n           \u00e2\u009c\u0097 user=/dynamicuser=  service runs as root user                     0.4\n           \u00e2\u009c\u0097 deviceallow=        service has no device acl                     0.2\n           \u00e2\u009c\u0093 ipaddressdeny=      service blocks all ip address ranges\n           ...\n           \u00e2\u0086\u0092 overall exposure level for systemd-logind.service: 4.1 ok \u00f0\u009f\u0099\u0082\nsystemd-analyze inspect-elf\nfile\n...\n       this command will load the specified files, and if they are elf\n       objects (executables, libraries, core files, etc.) it will parse\n       the embedded packaging metadata, if any, and print it in a table\n       or json format. see the\npackage metadata for executable files\n[1]\n       document for more information.\nexample 22. print information about a core file as json\n$ systemd-analyze inspect-elf --json=pretty \\\n                   core.fsverity.1000.f77dac5dc161402aa44e15b7dd9dcf97.58561.1637106137000000\n           {\n                   \"elftype\" : \"coredump\",\n                   \"elfarchitecture\" : \"amd x86-64\",\n                   \"/home/bluca/git/fsverity-utils/fsverity\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"7c895ecd2a271f93e96268f479fdc3c64a2ec4ee\"\n                   },\n                   \"/home/bluca/git/fsverity-utils/libfsverity.so.0\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"b5e428254abf14237b0ae70ed85fffbb98a78f88\"\n                   }\n           }\nsystemd-analyze fdstore\nunit\n...\n       lists the current contents of the specified service unit's file\n       descriptor store. this shows names, inode types, device numbers,\n       inode numbers, paths and open modes of the open file descriptors.\n       the specified units must have\nfiledescriptorstoremax=\nenabled, see\nsystemd.service(5)\nfor details.\nexample 23. table output\n$ systemd-analyze fdstore systemd-journald.service\n           fdname type devno   inode rdevno path             flags\n           stored sock 0:8   4218620 -      socket:[4218620] ro\n           stored sock 0:8   4213198 -      socket:[4213198] ro\n           stored sock 0:8   4213190 -      socket:[4213190] ro\n           ...\n\n       note: the \"devno\" column refers to the major/minor numbers of the\n       device node backing the file system the file descriptor's inode is\n       on. the \"rdevno\" column refers to the major/minor numbers of the\n       device node itself if the file descriptor refers to one. compare\n       with corresponding\n.st_dev\nand\n.st_rdev\nfields in\nstruct stat\n(see\nstat(2)\nfor details). the listed inode numbers in the \"inode\"\n       column are on the file system indicated by \"devno\".\nsystemd-analyze image-policy\npolicy\n...\n       this command analyzes the specified image policy string, as per\nsystemd.image-policy(7)\n. the policy is normalized and simplified.\n       for each currently defined partition identifier (as per the\ndiscoverable partitions specification\n[2]) the effect of the image\n       policy string is shown in tabular form.\nexample 24. example output\n$ systemd-analyze image-policy swap=encrypted:usr=read-only-on+verity:root=encrypted\n           analyzing policy: root=encrypted:usr=verity+read-only-on:swap=encrypted\n                  long form: root=encrypted:usr=verity+read-only-on:swap=encrypted:=unused+absent\n\n           partition       mode        read-only growfs\n           root            encrypted   -         -\n           usr             verity      yes       -\n           home            ignore      -         -\n           srv             ignore      -         -\n           esp             ignore      -         -\n           xbootldr        ignore      -         -\n           swap            encrypted   -         -\n           root-verity     ignore      -         -\n           usr-verity      unprotected yes       -\n           root-verity-sig ignore      -         -\n           usr-verity-sig  ignore      -         -\n           tmp             ignore      -         -\n           var             ignore      -         -\n           default         ignore      -         -\nsystemd-analyze has-tpm2\nreports whether the system is equipped with a usable tpm2 device.\n       if a tpm2 device has been discovered, is supported, and is being\n       used by firmware, by the os kernel drivers and by userspace (i.e.\n       systemd) this prints \"yes\" and exits with exit status zero. if no\n       such device is discovered/supported/used, prints \"no\". otherwise,\n       prints \"partial\". in either of these two cases exits with non-zero\n       exit status. it also shows five lines indicating separately\n       whether firmware, drivers, the system, the kernel and libraries\n       discovered/support/use tpm2. currently, required libraries are\n       libtss2-esys.so.0, libtss2-rc.so.0, and libtss2-mu.so.0. the\n       requirement may be changed in the future release.\n\n       note, this checks for tpm 2.0 devices only, and does not consider\n       tpm 1.2 at all.\n\n       combine with\n--quiet\nto suppress the output.\nexample 25. example output\nyes\n           +firmware\n           +driver\n           +system\n           +subsystem\n           +libraries\n             +libtss2-esys.so.0\n             +libtss2-rc.so.0\n             +libtss2-mu.so.0\n\n       added in version 257.\nsystemd-analyze pcrs [\npcr\n...]\n       this command shows the known tpm2 pcrs along with their\n       identifying names and current values.\nexample 26. example output\n$ systemd-analyze pcrs\n           nr name                sha256\n            0 platform-code       bcd2eb527108bbb1f5528409bcbe310aa9b74f687854cc5857605993f3d9eb11\n            1 platform-config     b60622856eb7ce52637b80f30a520e6e87c347daa679f3335f4f1a600681bb01\n            2 external-code       1471262403e9a62f9c392941300b4807fbdb6f0bfdd50abfab752732087017dd\n            3 external-config     3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            4 boot-loader-code    939f7fa1458e1f7ce968874d908e524fc0debf890383d355e4ce347b7b78a95c\n            5 boot-loader-config  864c61c5ea5ecbdb6951e6cb6d9c1f4b4eac79772f7fe13b8bece569d83d3768\n            6 -                   3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            7 secure-boot-policy  9c905bd9b9891bfb889b90a54c4b537b889cfa817c4389cc25754823a9443255\n            8 -                   0000000000000000000000000000000000000000000000000000000000000000\n            9 kernel-initrd       9caa29b128113ef42aa53d421f03437be57211e5ebafc0fa8b5d4514ee37ff0c\n           10 ima                 5ea9e3dab53eb6b483b6ec9e3b2c712bea66bca1b155637841216e0094387400\n           11 kernel-boot         0000000000000000000000000000000000000000000000000000000000000000\n           12 kernel-config       627ffa4b405e911902fe1f1a8b0164693b31acab04f805f15bccfe2209c7eace\n           13 sysexts             0000000000000000000000000000000000000000000000000000000000000000\n           14 shim-policy         0000000000000000000000000000000000000000000000000000000000000000\n           15 system-identity     0000000000000000000000000000000000000000000000000000000000000000\n           16 debug               0000000000000000000000000000000000000000000000000000000000000000\n           17 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           18 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           19 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           20 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           21 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           22 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           23 application-support 0000000000000000000000000000000000000000000000000000000000000000\nsystemd-analyze srk [>\nfile\n]\n       this command reads the storage root key (srk) from the tpm2\n       device, and writes it in marshalled tpm2b_public format to stdout.\n       the output is non-printable data, so it should be redirected to a\n       file or into a pipe.\nexample 27. save the storage root key to srk.tpm2b_public\nsystemd-analyze srk >srk.tpm2b_public\nsystemd-analyze architectures [\nname\n...]\n       lists all known cpu architectures, and which ones are native. the\n       listed architecture names are those\nconditionarchitecture=\nsupports, see\nsystemd.unit(5)\nfor details. if architecture names\n       are specified only those specified are listed.\nexample 28. table output\n$ systemd-analyze architectures\n           name        support\n           alpha       foreign\n           arc         foreign\n           arc-be      foreign\n           arm         foreign\n           arm64       foreign\n           ...\n           sparc       foreign\n           sparc64     foreign\n           tilegx      foreign\n           x86         secondary\n           x86-64      native\nsystemd-analyze smbios11\nshows a list of smbios type #11 strings passed to the system. also\n       see\nsmbios-type-11(7)\n.\nexample 29. example output\n$ systemd-analyze smbios11\n           io.systemd.stub.kernel-cmdline-extra=console=ttys0\n           io.systemd.credential.binary:ssh.ephemeral-authorized_keys-all=c3nolwvkmju1mtkgqufbqumztnphqzfswkrjmu5urtvbqufbsurgd20xbfp4wlrgcljteg9zqlozotyzce1uyljcadmwm1mxvxhlsum2nmygbgvubmfydeb6zxrhcg==\n           io.systemd.credential:vmm.notify_socket=vsock-stream:2:254570042\n\n           3 smbios type #11 strings passed.\n\n       added in version 257.\nsystemd-analyze chid\nshows a list of computer hardware ids (chids) of the local system.\n       these ids identify the system's computer hardware, based on smbios\n       data. see\nusing computer hardware ids (chids)\n[3] for details about\n       chids.\nexample 30. example output\n$ systemd-analyze chid\n           type input  chid\n              3 mfpsmp 520537c0-3b59-504f-b062-9682ea236b21\n              4 mfps-- edf05dc8-a53d-5b2c-8023-630bca2a2463\n              5 mfp--- ebc6a4d9-ec48-537a-916b-c69fa4fdd814\n              6 m--smp 5ebe4bba-f598-5e90-9ff2-9fd0d3211465\n              7 m--s-- 1a3fb835-b42a-5f9c-a38c-eff5bfd5c41d\n              8 m-p-mp 2a831dce-8163-5bad-8406-435b8c752dd8\n              9 m-p--- 7c21c878-4a75-50f7-9816-21e811588da0\n             10 mf--mp 9a003537-bcc5-500e-b10a-8d8892e4fc64\n             11 mf---- bb9122bb-8a5c-50d2-a742-a85beb719909\n             13 m---mp bfc36935-5032-5987-a0a3-6311f01de33a\n\n           legend: m \u00e2\u0086\u0092 sys_vendor (lenovo) \u00e2\u0094\u0084 f \u00e2\u0086\u0092 product_family (thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 p \u00e2\u0086\u0092 product_name (20xw0055ge)\n                   s \u00e2\u0086\u0092 product_sku (lenovo_mt_20xw_bu_think_fm_thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 m \u00e2\u0086\u0092 board_vendor (lenovo)\n                   p \u00e2\u0086\u0092 board_name (20xw0055ge)\n\n       added in version 258.",
      "examples": "",
      "options": ""
    },
    {
      "command": "pmfind",
      "description": "pmfind\nsearches for instances of the specified pcp service being\n       advertised on the network and prints a list of urls corresponding\n       to the services discovered.  it can be used in conjunction with\npmfind_check(1)\nto automate the monitoring of remote pcp collector\n       systems.",
      "examples": "",
      "options": ""
    },
    {
      "command": "ippfind",
      "description": "ippfind\nfinds services registered with a dns server or available\n       through local devices.  its primary purpose is to find ipp\n       printers and show their uris, show their current status, or run\n       commands.\nregistration types\nippfind\nsupports the following registration types:\n\n       _http._tcp\n            hypertext transport protocol (http, rfc 2616)\n\n       _https._tcp\n            secure hypertext transport protocol (https, rfc 2818)\n\n       _ipp._tcp\n            internet printing protocol (ipp, rfc 2911)\n\n       _ipps._tcp\n            secure internet printing protocol (ipps, draft)\n\n       _printer._tcp\n            line printer daemon (lpd, rfc 1179)\nexpressions\nippfind\nsupports expressions much like the\nfind(1)\nutility.\n       however, unlike\nfind(1)\n,\nippfind\nuses posix regular expressions\n       instead of shell filename matching patterns.  if\n--exec\n,\n-l\n,\n--ls\n,\n-p\n,\n--print\n,\n--print-name\n,\n-q\n,\n--quiet\n,\n-s\n, or\n-x\nis not\n       specified,\nippfind\nadds\n--print\nto print the service uri of\n       anything it finds.  the following expressions are supported:\n-d\nregex\n--domain\nregex\ntrue if the domain matches the given regular expression.\n--false\nalways false.\n-h\nregex\n--host\nregex\ntrue is the hostname matches the given regular expression.\n-l\n--ls\nlists attributes returned by get-printer-attributes for ipp\n            printers and traditional\nfind\n\"-ls\" output for http urls.\n            the result is true if the uri is accessible, false otherwise.\n--local\ntrue if the service is local to this computer.\n-n\nname\n--literal-name\nname\ntrue if the service instance name matches the given name.\n-n\nregex\n--name\nregex\ntrue if the service instance name matches the given regular\n            expression.\n--path\nregex\ntrue if the uri resource path matches the given regular\n            expression.\n-p\nnumber\n[\n-\nnumber\n]\n--port\nnumber\n[\n-\nnumber\n]\n            true if the port matches the given number or range.\n-p\n--print\nprints the uri if the result of previous expressions is true.\n            the result is always true.\n-q\n--quiet\nquiet mode - just returns the exit codes below.\n-r\n--remote\ntrue if the service is not local to this computer.\n-s\n--print-name\nprints the service instance name if the result of previous\n            expressions is true.  the result is always true.\n--true\nalways true.\n-t\nkey\n--txt\nkey\ntrue if the txt record contains the named key.\n--txt-\nkey regex\ntrue if the txt record contains the named key and matches the\n            given regular expression.\n-u\nregex\n--uri\nregex\ntrue if the uri matches the given regular expression.\n-x\nutility\n[\nargument\n... ]\n;\n--exec\nutility\n[\nargument\n... ]\n;\nexecutes the specified program if the current result is true.\n            \"{foo}\" arguments are replaced with the corresponding value -\n            see substitutions below.\n\n       expressions may also contain modifiers:\n(\nexpression\n)\ngroup the result of expressions.\n!\nexpression\n--not\nexpression\nunary not of the expression.\nexpression expression\nexpression\n--and\nexpression\nlogical and of expressions.\nexpression\n--or\nexpression\nlogical or of expressions.\nsubstitutions\nthe substitutions for \"{foo}\" in\n-e\nand\n--exec\nare:\n{service_domain}\ndomain name, e.g., \"example.com.\", \"local.\", etc.\n{service_hostname}\nfully-qualified domain name, e.g., \"printer.example.com.\",\n            \"printer.local.\", etc.\n{service_name}\nservice instance name, e.g., \"my fine printer\".\n{service_port}\nport number for server, typically 631 for ipp and 80 for\n            http.\n{service_regtype}\ndns-sd registration type, e.g., \"_ipp._tcp\", \"_http._tcp\",\n            etc.\n{service_scheme}\nuri scheme for dns-sd registration type, e.g., \"ipp\", \"http\",\n            etc.\n{}\n{service_uri}\nuri for service, e.g., \"ipp://printer.local./ipp/print\",\n            \"http://printer.local./\", etc.\n{txt_\nkey\n}\nvalue of txt record\nkey\n(lowercase).",
      "examples": "",
      "options": ""
    },
    {
      "command": "nmap",
      "description": "nmap (\u00e2\u0080\u009cnetwork mapper\u00e2\u0080\u009d) is an open source tool for network\n       exploration and security auditing. it was designed to rapidly scan\n       large networks, although it works fine against single hosts. nmap\n       uses raw ip packets in novel ways to determine what hosts are\n       available on the network, what services (application name and\n       version) those hosts are offering, what operating systems (and os\n       versions) they are running, what type of packet filters/firewalls\n       are in use, and dozens of other characteristics. while nmap is\n       commonly used for security audits, many systems and network\n       administrators find it useful for routine tasks such as network\n       inventory, managing service upgrade schedules, and monitoring host\n       or service uptime.\n\n       the output from nmap is a list of scanned targets, with\n       supplemental information on each depending on the options used.\n       key among that information is the \u00e2\u0080\u009cinteresting ports table\u00e2\u0080\u009d.  that\n       table lists the port number and protocol, service name, and state.\n       the state is either open, filtered, closed, or unfiltered.  open\n       means that an application on the target machine is listening for\n       connections/packets on that port.  filtered means that a firewall,\n       filter, or other network obstacle is blocking the port so that\n       nmap cannot tell whether it is open or closed.  closed ports have\n       no application listening on them, though they could open up at any\n       time. ports are classified as unfiltered when they are responsive\n       to nmap's probes, but nmap cannot determine whether they are open\n       or closed. nmap reports the state combinations open|filtered and\n       closed|filtered when it cannot determine which of the two states\n       describe a port. the port table may also include software version\n       details when version detection has been requested. when an ip\n       protocol scan is requested (\n-so\n), nmap provides information on\n       supported ip protocols rather than listening ports.\n\n       in addition to the interesting ports table, nmap can provide\n       further information on targets, including reverse dns names,\n       operating system guesses, device types, and mac addresses.\n\n       a typical nmap scan is shown in example 1. the only nmap arguments\n       used in this example are\n-a\n, to enable os and version detection,\n       script scanning, and traceroute;\n-t4\nfor faster execution; and\n       then the hostname.\nexample 1. a representative nmap scan\n#\nnmap -a -t4 scanme.nmap.org\nnmap scan report for scanme.nmap.org (74.207.244.221)\n           host is up (0.029s latency).\n           rdns record for 74.207.244.221: li86-221.members.linode.com\n           not shown: 995 closed ports\n           port     state    service     version\n           22/tcp   open     ssh         openssh 5.3p1 debian 3ubuntu7 (protocol 2.0)\n           | ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (dsa)\n           |_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (rsa)\n           80/tcp   open     http        apache httpd 2.2.14 ((ubuntu))\n           |_http-title: go ahead and scanme!\n           646/tcp  filtered ldp\n           1720/tcp filtered h.323/q.931\n           9929/tcp open     nping-echo  nping echo\n           device type: general purpose\n           running: linux 2.6.x\n           os cpe: cpe:/o:linux:linux_kernel:2.6.39\n           os details: linux 2.6.39\n           network distance: 11 hops\n           service info: os: linux; cpe: cpe:/o:linux:kernel\n\n           traceroute (using port 53/tcp)\n           hop rtt      address\n           [cut first 10 hops for brevity]\n           11  17.65 ms li86-221.members.linode.com (74.207.244.221)\n\n           nmap done: 1 ip address (1 host up) scanned in 14.40 seconds\n\n       the newest version of nmap can be obtained from\nhttps://nmap.org\n.\n       the newest version of this man page is available at\nhttps://nmap.org/book/man.html\n.  it is also included as a chapter\n       of nmap network scanning: the official nmap project guide to\n       network discovery and security scanning (see\nhttps://nmap.org/book/\n).",
      "examples": "",
      "options": ""
    },
    {
      "command": "nping",
      "description": "nping is an open-source tool for network packet generation,\n       response analysis and response time measurement. nping allows\n       users to generate network packets of a wide range of protocols,\n       letting them tune virtually any field of the protocol headers.\n       while nping can be used as a simple ping utility to detect active\n       hosts, it can also be used as a raw packet generator for network\n       stack stress tests, arp poisoning, denial of service attacks,\n       route tracing, and other purposes.\n\n       additionally, nping offers a special mode of operation called the\n       \"echo mode\", that lets users see how the generated probes change\n       in transit, revealing the differences between the transmitted\n       packets and the packets received at the other end. see section\n       \"echo mode\" for details.\n\n       the output from nping is a list of the packets that are being sent\n       and received. the level of detail depends on the options used.\n\n       a typical nping execution is shown in example 1. the only nping\n       arguments used in this example are\n-c\n, to specify the number of\n       times to target each host,\n--tcp\nto specify tcp probe mode,\n-p\n80,433\nto specify the target ports; and then the two target\n       hostnames.\nexample 1. a representative nping execution\n#\nnping -c 1 --tcp -p 80,433 scanme.nmap.org google.com\nstarting nping (\nhttps://nmap.org/nping\n)\n           sent (0.0120s) tcp 96.16.226.135:50091 > 64.13.134.52:80 s ttl=64 id=52072 iplen=40  seq=1077657388 win=1480\n           rcvd (0.1810s) tcp 64.13.134.52:80 > 96.16.226.135:50091 sa ttl=53 id=0 iplen=44  seq=4158134847 win=5840 <mss 1460>\n           sent (1.0140s) tcp 96.16.226.135:50091 > 74.125.45.100:80 s ttl=64 id=13932 iplen=40  seq=1077657388 win=1480\n           rcvd (1.1370s) tcp 74.125.45.100:80 > 96.16.226.135:50091 sa ttl=52 id=52913 iplen=44  seq=2650443864 win=5720 <mss 1430>\n           sent (2.0140s) tcp 96.16.226.135:50091 > 64.13.134.52:433 s ttl=64 id=8373 iplen=40  seq=1077657388 win=1480\n           sent (3.0140s) tcp 96.16.226.135:50091 > 74.125.45.100:433 s ttl=64 id=23624 iplen=40  seq=1077657388 win=1480\n\n           statistics for host scanme.nmap.org (64.13.134.52):\n            |  probes sent: 2 | rcvd: 1 | lost: 1  (50.00%)\n            |_ max rtt: 169.720ms | min rtt: 169.720ms | avg rtt: 169.720ms\n           statistics for host google.com (74.125.45.100):\n            |  probes sent: 2 | rcvd: 1 | lost: 1  (50.00%)\n            |_ max rtt: 122.686ms | min rtt: 122.686ms | avg rtt: 122.686ms\n           raw packets sent: 4 (160b) | rcvd: 2 (92b) | lost: 2 (50.00%)\n           tx time: 3.00296s | tx bytes/s: 53.28 | tx pkts/s: 1.33\n           rx time: 3.00296s | rx bytes/s: 30.64 | rx pkts/s: 0.67\n           nping done: 2 ip addresses pinged in 4.01 seconds\n\n       the newest version of nping can be obtained with nmap at\nhttps://nmap.org\n. the newest version of this man page is available\n       at\nhttps://nmap.org/book/nping-man.html\n.\n\n       -->\n         .sh \"options summary\"\n\n       this options summary is printed when nping is run with no\n       arguments. it helps people remember the most common options, but\n       is no substitute for the in-depth documentation in the rest of\n       this manual. some obscure options aren't even included here.\n\n           nping 0.7.92svn (\nhttps://nmap.org/nping\n)\n           usage: nping [probe mode] [options] {target specification}\n\n           target specification:\n             targets may be specified as hostnames, ip addresses, networks, etc.\n             ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.*.1-24\n           probe modes:\n             --tcp-connect                    : unprivileged tcp connect probe mode.\n             --tcp                            : tcp probe mode.\n             --udp                            : udp probe mode.\n             --icmp                           : icmp probe mode.\n             --arp                            : arp/rarp probe mode.\n             --tr, --traceroute               : traceroute mode (can only be used with\n                                                tcp/udp/icmp modes).\n           tcp connect mode:\n              -p, --dest-port <port spec>     : set destination port(s).\n              -g, --source-port <portnumber>  : try to use a custom source port.\n           tcp probe mode:\n              -g, --source-port <portnumber>  : set source port.\n              -p, --dest-port <port spec>     : set destination port(s).\n              --seq <seqnumber>               : set sequence number.\n              --flags <flag list>             : set tcp flags (ack,psh,rst,syn,fin...)\n              --ack <acknumber>               : set ack number.\n              --win <size>                    : set window size.\n              --badsum                        : use a random invalid checksum.\n           udp probe mode:\n              -g, --source-port <portnumber>  : set source port.\n              -p, --dest-port <port spec>     : set destination port(s).\n              --badsum                        : use a random invalid checksum.\n           icmp probe mode:\n             --icmp-type <type>               : icmp type.\n             --icmp-code <code>               : icmp code.\n             --icmp-id <id>                   : set identifier.\n             --icmp-seq <n>                   : set sequence number.\n             --icmp-redirect-addr <addr>      : set redirect address.\n             --icmp-param-pointer <pnt>       : set parameter problem pointer.\n             --icmp-advert-lifetime <time>    : set router advertisement lifetime.\n             --icmp-advert-entry <ip,pref>    : add router advertisement entry.\n             --icmp-orig-time  <timestamp>    : set originate timestamp.\n             --icmp-recv-time  <timestamp>    : set receive timestamp.\n             --icmp-trans-time <timestamp>    : set transmit timestamp.\n           arp/rarp probe mode:\n             --arp-type <type>                : type: arp, arp-reply, rarp, rarp-reply.\n             --arp-sender-mac <mac>           : set sender mac address.\n             --arp-sender-ip  <addr>          : set sender ip address.\n             --arp-target-mac <mac>           : set target mac address.\n             --arp-target-ip  <addr>          : set target ip address.\n           ipv4 options:\n             -s, --source-ip                  : set source ip address.\n             --dest-ip <addr>                 : set destination ip address (used as an\n                                                alternative to {target specification} ).\n             --tos <tos>                      : set type of service field (8bits).\n             --id  <id>                       : set identification field (16 bits).\n             --df                             : set don't fragment flag.\n             --mf                             : set more fragments flag.\n             --evil                           : set reserved / evil flag.\n             --ttl <hops>                     : set time to live [0-255].\n             --badsum-ip                      : use a random invalid checksum.\n             --ip-options <s|r [route]|l [route]|t|u ...> : set ip options\n             --ip-options <hex string>                    : set ip options\n             --mtu <size>                     : set mtu. packets get fragmented if mtu is\n                                                small enough.\n           ipv6 options:\n             -6, --ipv6                       : use ip version 6.\n             --dest-ip                        : set destination ip address (used as an\n                                                alternative to {target specification}).\n             --hop-limit                      : set hop limit (same as ipv4 ttl).\n             --traffic-class <class> :        : set traffic class.\n             --flow <label>                   : set flow label.\n           ethernet options:\n             --dest-mac <mac>                 : set destination mac address. (disables\n                                                arp resolution)\n             --source-mac <mac>               : set source mac address.\n             --ether-type <type>              : set ethertype value.\n           payload options:\n             --data <hex string>              : include a custom payload.\n             --data-string <text>             : include a custom ascii text.\n             --data-length <len>              : include len random bytes as payload.\n           echo client/server:\n             --echo-client <passphrase>       : run nping in client mode.\n             --echo-server <passphrase>       : run nping in server mode.\n             --echo-port <port>               : use custom <port> to listen or connect.\n             --no-crypto                      : disable encryption and authentication.\n             --once                           : stop the server after one connection.\n             --safe-payloads                  : erase application data in echoed packets.\n           timing and performance:\n             options which take <time> are in seconds, or append 'ms' (milliseconds),\n             's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m, 0.25h).\n             --delay <time>                   : adjust delay between probes.\n             --rate  <rate>                   : send num packets per second.\n           misc:\n             -h, --help                       : display help information.\n             -v, --version                    : display current version number.\n             -c, --count <n>                  : stop after <n> rounds.\n             -e, --interface <name>           : use supplied network interface.\n             -h, --hide-sent                  : do not display sent packets.\n             -n, --no-capture                 : do not try to capture replies.\n             --privileged                     : assume user is fully privileged.\n             --unprivileged                   : assume user lacks raw socket privileges.\n             --send-eth                       : send packets at the raw ethernet layer.\n             --send-ip                        : send packets using raw ip sockets.\n             --bpf-filter <filter spec>       : specify custom bpf filter.\n           output:\n             -v                               : increment verbosity level by one.\n             -v[level]                        : set verbosity level. e.g: -v4\n             -d                               : increment debugging level by one.\n             -d[level]                        : set debugging level. e.g: -d3\n             -q                               : decrease verbosity level by one.\n             -q[n]                            : decrease verbosity level n times\n             --quiet                          : set verbosity and debug level to minimum.\n             --debug                          : set verbosity and debug to the max level.\n           examples:\n             nping scanme.nmap.org\n             nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1\n             nping --icmp --icmp-type time --delay 500ms 192.168.254.254\n             nping --echo-server \"public\" -e wlan0 -vvv\n             nping --echo-client \"public\" echo.nmap.org --tcp -p1-1024 --flags ack\n\n           see the man page for many more options, descriptions, and examples",
      "examples": "",
      "options": ""
    }
  ],
  "context": "Retrieved commands:\n\nCommand: systemd-analyze\nDescription: systemd-analyze\nmay be used to determine system boot-up\n       performance statistics and retrieve other state and tracing\n       information from the system and service manager, and to verify the\n       correctness of unit files. it is also used to access special\n       functions useful for advanced system manager debugging.\n\n       if no command is passed,\nsystemd-analyze time\nis implied.\nsystemd-analyze time\nthis command prints the time spent in the kernel before userspace\n       has been reached, the time spent in the initrd before normal\n       system userspace has been reached, and the time normal system\n       userspace took to initialize. note that these measurements simply\n       measure the time passed up to the point where all system services\n       have been spawned, but not necessarily until they fully finished\n       initialization or the disk is idle.\nexample 1. show how long the boot took\n# in a container\n           $ systemd-analyze time\n           startup finished in 296ms (userspace)\n           multi-user.target reached after 275ms in userspace\n\n           # on a real machine\n           $ systemd-analyze time\n           startup finished in 2.584s (kernel) + 19.176s (initrd) + 47.847s (userspace) = 1min 9.608s\n           multi-user.target reached after 47.820s in userspace\nsystemd-analyze blame\nthis command prints a list of all running units, ordered by the\n       time they took to initialize. this information may be used to\n       optimize boot-up times. note that the output might be misleading\n       as the initialization of one service might be slow simply because\n       it waits for the initialization of another service to complete.\n       also note:\nsystemd-analyze blame\ndoes not display results for\n       services with\ntype=simple\n, because systemd considers such services\n       to be started immediately, hence no measurement of the\n       initialization delays can be done. also note that this command\n       only shows the time units took for starting up, it does not show\n       how long unit jobs spent in the execution queue. in particular it\n       shows the time units spent in \"activating\" state, which is not\n       defined for units such as device units that transition directly\n       from \"inactive\" to \"active\". this command hence gives an\n       impression of the performance of program code, but cannot\n       accurately reflect latency introduced by waiting for hardware and\n       similar events.\nexample 2. show which units took the most time during boot\n$ systemd-analyze blame\n                    32.875s pmlogger.service\n                    20.905s systemd-networkd-wait-online.service\n                    13.299s dev-vda1.device\n                    ...\n                       23ms sysroot.mount\n                       11ms initrd-udevadm-cleanup-db.service\n                        3ms sys-kernel-config.mount\nsystemd-analyze critical-chain [\nunit\n...]\n       this command prints a tree of the time-critical chain of units\n       (for each of the specified\nunit\ns or for the default target\n       otherwise). the time after the unit is active or started is\n       printed after the \"@\" character. the time the unit takes to start\n       is printed after the \"+\" character. note that the output might be\n       misleading as the initialization of services might depend on\n       socket activation and because of the parallel execution of units.\n       also, similarly to the\nblame\ncommand, this only takes into account\n       the time units spent in \"activating\" state, and hence does not\n       cover units that never went through an \"activating\" state (such as\n       device units that transition directly from \"inactive\" to\n       \"active\"). moreover, it does not show information on jobs (and in\n       particular not jobs that timed out).\nexample 3. systemd-analyze critical-chain\n$ systemd-analyze critical-chain\n           multi-user.target @47.820s\n           \u00e2\u0094\u0094\u00e2\u0094\u0080pmie.service @35.968s +548ms\n             \u00e2\u0094\u0094\u00e2\u0094\u0080pmcd.service @33.715s +2.247s\n               \u00e2\u0094\u0094\u00e2\u0094\u0080network-online.target @33.712s\n                 \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd-wait-online.service @12.804s +20.905s\n                   \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-networkd.service @11.109s +1.690s\n                     \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-udevd.service @9.201s +1.904s\n                       \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-tmpfiles-setup-dev.service @7.306s +1.776s\n                         \u00e2\u0094\u0094\u00e2\u0094\u0080kmod-static-nodes.service @6.976s +177ms\n                           \u00e2\u0094\u0094\u00e2\u0094\u0080systemd-journald.socket\n                             \u00e2\u0094\u0094\u00e2\u0094\u0080system.slice\n                               \u00e2\u0094\u0094\u00e2\u0094\u0080-.slice\nsystemd-analyze dump [\npattern\n...]\n       without any parameter, this command outputs a (usually very long)\n       human-readable serialization of the complete service manager\n       state. optional glob pattern may be specified, causing the output\n       to be limited to units whose names match one of the patterns. the\n       output format is subject to change without notice and should not\n       be parsed by applications. this command is rate limited for\n       unprivileged users.\nexample 4. show the internal state of user manager\n$ systemd-analyze --user dump\n           timestamp userspace: thu 2019-03-14 23:28:07 cet\n           timestamp finish: thu 2019-03-14 23:28:07 cet\n           timestamp generators-start: thu 2019-03-14 23:28:07 cet\n           timestamp generators-finish: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-start: thu 2019-03-14 23:28:07 cet\n           timestamp units-load-finish: thu 2019-03-14 23:28:07 cet\n           -> unit proc-timer_list.mount:\n                   description: /proc/timer_list\n                   ...\n           -> unit default.target:\n                   description: main user target\n           ...\nsystemd-analyze malloc [\nd-bus service\n...]\n       this command can be used to request the output of the internal\n       memory state (as returned by\nmalloc_info(3)\n) of a d-bus service.\n       if no service is specified, the query will be sent to\n       org.freedesktop.systemd1 (the system or user service manager). the\n       output format is not guaranteed to be stable and should not be\n       parsed by applications.\n\n       the service must implement the org.freedesktop.memoryallocation1\n       interface. in the systemd suite, it is currently only implemented\n       by the manager.\nsystemd-analyze plot\nthis command prints either an svg graphic, detailing which system\n       services have been started at what time, highlighting the time\n       they spent on initialization, or the raw time data in json or\n       table format.\nexample 5. plot a bootchart\n$ systemd-analyze plot >bootup.svg\n           $ eog bootup.svg&\n\n       note that this plot is based on the most recent per-unit timing\n       data of loaded units. this means that if a unit gets started, then\n       stopped and then started again the information shown will cover\n       the most recent start cycle, not the first one. thus it is\n       recommended to consult this information only shortly after boot,\n       so that this distinction does not matter. moreover, units that are\n       not referenced by any other unit through a dependency might be\n       unloaded by the service manager once they terminate (and did not\n       fail). such units will not show up in the plot.\nsystemd-analyze dot [\npattern\n...]\n       this command generates textual dependency graph description in dot\n       format for further processing with the graphviz\ndot\n(1) tool. use a\n       command line like\nsystemd-analyze dot | dot -tsvg >systemd.svg\nto\n       generate a graphical dependency tree. unless\n--order\nor\n--require\nis passed, the generated graph will show both ordering and\n       requirement dependencies. optional pattern globbing style\n       specifications (e.g.  *.target) may be given at the end. a unit\n       dependency is included in the graph if any of these patterns match\n       either the origin or destination node.\nexample 6. plot all dependencies of any unit whose name starts\nwith \"avahi-daemon\"\n$ systemd-analyze dot 'avahi-daemon.*' | dot -tsvg >avahi.svg\n           $ eog avahi.svg\nexample 7. plot the dependencies between all known target units\n$ systemd-analyze dot --to-pattern='*.target' --from-pattern='*.target' \\\n                 | dot -tsvg >targets.svg\n           $ eog targets.svg\nsystemd-analyze unit-paths\nthis command outputs a list of all directories from which unit\n       files, .d overrides, and .wants, .requires symlinks may be loaded.\n       combine with\n--user\nto retrieve the list for the user manager\n       instance, and\n--global\nfor the global configuration of user\n       manager instances.\nexample 8. show all paths for generated units\n$ systemd-analyze unit-paths | grep '^/run'\n           /run/systemd/system.control\n           /run/systemd/transient\n           /run/systemd/generator.early\n           /run/systemd/system\n           /run/systemd/system.attached\n           /run/systemd/generator\n           /run/systemd/generator.late\n\n       note that this verb prints the list that is compiled into\nsystemd-analyze\nitself, and does not communicate with the running\n       manager. use\n\n           systemctl [--user] [--global] show -p unitpath --value\n\n       to retrieve the actual list that the manager uses, with any empty\n       directories omitted.\nsystemd-analyze exit-status [\nstatus\n...]\n       this command prints a list of exit statuses along with their\n       \"class\", i.e. the source of the definition (one of \"glibc\",\n       \"systemd\", \"lsb\", or \"bsd\"), see the process exit codes section in\nsystemd.exec(5)\n. if no additional arguments are specified, all\n       known statuses are shown. otherwise, only the definitions for the\n       specified codes are shown.\nexample 9. show some example exit status names\n$ systemd-analyze exit-status 0 1 {63..65}\n           name    status class\n           success 0      glibc\n           failure 1      glibc\n           -       63     -\n           usage   64     bsd\n           dataerr 65     bsd\nsystemd-analyze capability [\ncapability\n... | {-m | --mask}\nmask\n]\n       this command prints a list of linux capabilities along with their\n       numeric ids. see\ncapabilities(7)\nfor details. if no argument is\n       specified the full list of capabilities known to the service\n       manager and the kernel is shown. capabilities defined by the\n       kernel but not known to the service manager are shown as\n       \"cap_???\". optionally, if arguments are specified they may refer\n       to specific cabilities by name or numeric id, in which case only\n       the indicated capabilities are shown in the table.\n\n       alternatively, if\n--mask\nis passed, a single numeric argument must\n       be specified, which is interpreted as a hexadecimal capability\n       mask. in this case, only the capabilities present in the mask are\n       shown in the table. this mode is intended to aid in decoding\n       capability sets available via various debugging interfaces (e.g.\n       \"/proc/pid/status\").\nexample 10. show some example capability names\n$ systemd-analyze capability 0 1 {30..32}\n           name              number\n           cap_chown              0\n           cap_dac_override       1\n           cap_audit_control     30\n           cap_setfcap           31\n           cap_mac_override      32\nexample 11. decode a capability mask extracted from /proc\n$ systemd-analyze capability -m 0000000000003c00\n           name                 number\n           cap_net_bind_service     10\n           cap_net_broadcast        11\n           cap_net_admin            12\n           cap_net_raw              13\nsystemd-analyze condition\ncondition\n...\n       this command will evaluate\ncondition*=...\nand\nassert*=...\nassignments, and print their values, and the resulting value of\n       the combined condition set. see\nsystemd.unit(5)\nfor a list of\n       available conditions and asserts.\nexample 12. evaluate conditions that check kernel versions\n$ systemd-analyze condition 'conditionkernelversion = ! <4.0' \\\n                   'conditionkernelversion = >=5.1' \\\n                   'conditionacpower=|false' \\\n                   'conditionarchitecture=|!arm' \\\n                   'assertpathexists=/etc/os-release'\n           test.service: assertpathexists=/etc/os-release succeeded.\n           asserts succeeded.\n           test.service: conditionarchitecture=|!arm succeeded.\n           test.service: conditionacpower=|false failed.\n           test.service: conditionkernelversion=>=5.1 succeeded.\n           test.service: conditionkernelversion=!<4.0 succeeded.\n           conditions succeeded.\nsystemd-analyze syscall-filter [\nset\n...]\n       this command will list system calls contained in the specified\n       system call set\nset\n, or all known sets if no sets are specified.\n       argument\nset\nmust include the \"@\" prefix.\nsystemd-analyze filesystems [\nset\n...]\n       this command will list filesystems in the specified filesystem set\nset\n, or all known sets if no sets are specified. argument\nset\nmust\n       include the \"@\" prefix.\nsystemd-analyze calendar\nexpression\n...\n       this command will parse and normalize repetitive calendar time\n       events, and will calculate when they elapse next. this takes the\n       same input as the\noncalendar=\nsetting in\nsystemd.timer(5)\n,\n       following the syntax described in\nsystemd.time(7)\n. by default,\n       only the next time the calendar expression will elapse is shown;\n       use\n--iterations=\nto show the specified number of next times the\n       expression elapses. each time the expression elapses forms a\n       timestamp, see the\ntimestamp\nverb below.\nexample 13. show leap days in the near future\n$ systemd-analyze calendar --iterations=5 '*-2-29 0:0:0'\n             original form: *-2-29 0:0:0\n           normalized form: *-02-29 00:00:00\n               next elapse: sat 2020-02-29 00:00:00 utc\n                  from now: 11 months 15 days left\n                  iter. #2: thu 2024-02-29 00:00:00 utc\n                  from now: 4 years 11 months left\n                  iter. #3: tue 2028-02-29 00:00:00 utc\n                  from now: 8 years 11 months left\n                  iter. #4: sun 2032-02-29 00:00:00 utc\n                  from now: 12 years 11 months left\n                  iter. #5: fri 2036-02-29 00:00:00 utc\n                  from now: 16 years 11 months left\nsystemd-analyze timestamp\ntimestamp\n...\n       this command parses a timestamp (i.e. a single point in time) and\n       outputs the normalized form and the difference between this\n       timestamp and now. the timestamp should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing timestamps\".\nexample 14. show parsing of timestamps\n$ systemd-analyze timestamp yesterday now tomorrow\n             original form: yesterday\n           normalized form: mon 2019-05-20 00:00:00 cest\n                  (in utc): sun 2019-05-19 22:00:00 utc\n              unix seconds: @15583032000\n                  from now: 1 day 9h ago\n\n             original form: now\n           normalized form: tue 2019-05-21 09:48:39 cest\n                  (in utc): tue 2019-05-21 07:48:39 utc\n              unix seconds: @1558424919.659757\n                  from now: 43us ago\n\n             original form: tomorrow\n           normalized form: wed 2019-05-22 00:00:00 cest\n                  (in utc): tue 2019-05-21 22:00:00 utc\n              unix seconds: @15584760000\n                  from now: 14h left\nsystemd-analyze timespan\nexpression\n...\n       this command parses a time span (i.e. a difference between two\n       timestamps) and outputs the normalized form and the equivalent\n       value in microseconds. the time span should adhere to the syntax\n       documented in\nsystemd.time(7)\n, section \"parsing time spans\".\n       values without units are parsed as seconds.\nexample 15. show parsing of timespans\n$ systemd-analyze timespan 1s 300s '1year 0.000001s'\n           original: 1s\n                 \u00ee\u00bcs: 1000000\n              human: 1s\n\n           original: 300s\n                 \u00ee\u00bcs: 300000000\n              human: 5min\n\n           original: 1year 0.000001s\n                 \u00ee\u00bcs: 31557600000001\n              human: 1y 1us\nsystemd-analyze cat-config\nname\n|\npath\n...\n       this command is similar to\nsystemctl cat\n, but operates on config\n       files. it will copy the contents of a config file and any drop-ins\n       to standard output, using the usual systemd set of directories and\n       rules for precedence. each argument must be either an absolute\n       path including the prefix (such as /etc/systemd/logind.conf or\n       /usr/lib/systemd/logind.conf), or a name relative to the prefix\n       (such as systemd/logind.conf).\nexample 16. showing logind configuration\n$ systemd-analyze cat-config systemd/logind.conf\n           # /etc/systemd/logind.conf\n           ...\n           [login]\n           nautovts=8\n           ...\n\n           # /usr/lib/systemd/logind.conf.d/20-test.conf\n           ... some override from another package\n\n           # /etc/systemd/logind.conf.d/50-override.conf\n           ... some administrator override\nsystemd-analyze compare-versions\nversion1\n[\nop\n]\nversion2\nthis command has two distinct modes of operation, depending on\n       whether the operator\nop\nis specified.\n\n       in the first mode \u00e2\u0080\u0094 when\nop\nis not specified \u00e2\u0080\u0094, it will compare\n       the two version strings and print either \"\nversion1\n<\nversion2\n\", or\n       \"\nversion1\n==\nversion2\n\", or \"\nversion1\n>\nversion2\n\" as appropriate.\n\n       the exit status is\n0\nif the versions are equal,\n11\nif the version\n       of the right is smaller, and\n12\nif the version of the left is\n       smaller. (this matches the convention used by\nrpmdev-vercmp\n.)\n\n       in the second mode \u00e2\u0080\u0094 when\nop\nis specified \u00e2\u0080\u0094 it will compare the\n       two version strings using the operation\nop\nand return\n0\n(success)\n       if they condition is satisfied, and\n1\n(failure) otherwise.\nop\nmay\n       be\nlt\n,\nle\n,\neq\n,\nne\n,\nge\n,\ngt\n. in this mode, no output is printed.\n       (this matches the convention used by\ndpkg(1)\n--compare-versions\n.)\nexample 17. compare versions of a package\n$ systemd-analyze compare-versions systemd-250~rc1.fc36.aarch64 systemd-251.fc36.aarch64\n           systemd-250~rc1.fc36.aarch64 < systemd-251.fc36.aarch64\n           $ echo $?\n           12\n\n           $ systemd-analyze compare-versions 1 lt 2; echo $?\n           0\n           $ systemd-analyze compare-versions 1 ge 2; echo $?\n           1\nsystemd-analyze verify\nfile\n...\n       this command will load unit files and print warnings if any errors\n       are detected. files specified on the command line will be loaded,\n       but also any other units referenced by them. a unit's name on disk\n       can be overridden by specifying an alias after a colon; see below\n       for an example. the full unit search path is formed by combining\n       the directories for all command line arguments, and the usual unit\n       load paths. the variable\n$systemd_unit_path\nis supported, and may\n       be used to replace or augment the compiled in set of unit load\n       paths; see\nsystemd.unit(5)\n. all units files present in the\n       directories containing the command line arguments will be used in\n       preference to the other paths. if a template unit without an\n       instance name is specified (e.g.  foo@.service), \"test_instance\"\n       will be used as the instance name, which can be controlled by\n--instance=\noption.\n\n       the following errors are currently detected:\n\n       \u00e2\u0080\u00a2   unknown sections and directives,\n\n       \u00e2\u0080\u00a2   missing dependencies which are required to start the given\n           unit,\n\n       \u00e2\u0080\u00a2   man pages listed in\ndocumentation=\nwhich are not found in the\n           system,\n\n       \u00e2\u0080\u00a2   commands listed in\nexecstart=\nand similar which are not found\n           in the system or not executable.\nexample 18. misspelt directives\n$ cat ./user.slice\n           [unit]\n           whatisthis=11\n           documentation=man:nosuchfile(1)\n           requires=different.service\n\n           [service]\n           description=x\n\n           $ systemd-analyze verify ./user.slice\n           [./user.slice:9] unknown lvalue 'whatisthis' in section 'unit'\n           [./user.slice:13] unknown section 'service'. ignoring.\n           error: org.freedesktop.systemd1.loadfailed:\n              unit different.service failed to load:\n              no such file or directory.\n           failed to create user.slice/start: invalid argument\n           user.slice: man nosuchfile(1) command failed with code 16\nexample 19. missing service units\n$ tail ./a.socket ./b.socket\n           ==> ./a.socket <==\n           [socket]\n           listenstream=100\n\n           ==> ./b.socket <==\n           [socket]\n           listenstream=100\n           accept=yes\n\n           $ systemd-analyze verify ./a.socket ./b.socket\n           service a.service not loaded, a.socket cannot be started.\n           service b@0.service not loaded, b.socket cannot be started.\nexample 20. aliasing a unit\n$ cat /tmp/source\n           [unit]\n           description=hostname printer\n\n           [service]\n           type=simple\n           execstart=/usr/bin/echo %h\n           mysterykey=true\n\n           $ systemd-analyze verify /tmp/source\n           failed to prepare filename /tmp/source: invalid argument\n\n           $ systemd-analyze verify /tmp/source:alias.service\n           alias.service:7: unknown key name 'mysterykey' in section 'service', ignoring.\nsystemd-analyze security [\nunit\n...]\n       this command analyzes the security and sandboxing settings of one\n       or more specified service units. if at least one unit name is\n       specified the security settings of the specified service units are\n       inspected and a detailed analysis is shown. if no unit name is\n       specified, all currently loaded, long-running service units are\n       inspected and a terse table with results shown. the command checks\n       for various security-related service settings, assigning each a\n       numeric \"exposure level\" value, depending on how important a\n       setting is. it then calculates an overall exposure level for the\n       whole unit, which is an estimation in the range 0.0...10.0\n       indicating how exposed a service is security-wise. high exposure\n       levels indicate very little applied sandboxing. low exposure\n       levels indicate tight sandboxing and strongest security\n       restrictions. note that this only analyzes the per-service\n       security features systemd itself implements. this means that any\n       additional security mechanisms applied by the service code itself\n       are not accounted for. the exposure level determined this way\n       should not be misunderstood: a high exposure level neither means\n       that there is no effective sandboxing applied by the service code\n       itself, nor that the service is actually vulnerable to remote or\n       local attacks. high exposure levels do indicate however that most\n       likely the service might benefit from additional settings applied\n       to them.\n\n       please note that many of the security and sandboxing settings\n       individually can be circumvented \u00e2\u0080\u0094 unless combined with others.\n       for example, if a service retains the privilege to establish or\n       undo mount points many of the sandboxing options can be undone by\n       the service code itself. due to that is essential that each\n       service uses the most comprehensive and strict sandboxing and\n       security settings possible. the tool will take into account some\n       of these combinations and relationships between the settings, but\n       not all. also note that the security and sandboxing settings\n       analyzed here only apply to the operations executed by the service\n       code itself. if a service has access to an ipc system (such as\n       d-bus) it might request operations from other services that are\n       not subject to the same restrictions. any comprehensive security\n       and sandboxing analysis is hence incomplete if the ipc access\n       policy is not validated too.\nexample 21. analyze systemd-logind.service\n$ systemd-analyze security --no-pager systemd-logind.service\n             name                description                              exposure\n           \u00e2\u009c\u0097 privatenetwork=     service has access to the host's network      0.5\n           \u00e2\u009c\u0097 user=/dynamicuser=  service runs as root user                     0.4\n           \u00e2\u009c\u0097 deviceallow=        service has no device acl                     0.2\n           \u00e2\u009c\u0093 ipaddressdeny=      service blocks all ip address ranges\n           ...\n           \u00e2\u0086\u0092 overall exposure level for systemd-logind.service: 4.1 ok \u00f0\u009f\u0099\u0082\nsystemd-analyze inspect-elf\nfile\n...\n       this command will load the specified files, and if they are elf\n       objects (executables, libraries, core files, etc.) it will parse\n       the embedded packaging metadata, if any, and print it in a table\n       or json format. see the\npackage metadata for executable files\n[1]\n       document for more information.\nexample 22. print information about a core file as json\n$ systemd-analyze inspect-elf --json=pretty \\\n                   core.fsverity.1000.f77dac5dc161402aa44e15b7dd9dcf97.58561.1637106137000000\n           {\n                   \"elftype\" : \"coredump\",\n                   \"elfarchitecture\" : \"amd x86-64\",\n                   \"/home/bluca/git/fsverity-utils/fsverity\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"7c895ecd2a271f93e96268f479fdc3c64a2ec4ee\"\n                   },\n                   \"/home/bluca/git/fsverity-utils/libfsverity.so.0\" : {\n                           \"type\" : \"deb\",\n                           \"name\" : \"fsverity-utils\",\n                           \"version\" : \"1.3-1\",\n                           \"buildid\" : \"b5e428254abf14237b0ae70ed85fffbb98a78f88\"\n                   }\n           }\nsystemd-analyze fdstore\nunit\n...\n       lists the current contents of the specified service unit's file\n       descriptor store. this shows names, inode types, device numbers,\n       inode numbers, paths and open modes of the open file descriptors.\n       the specified units must have\nfiledescriptorstoremax=\nenabled, see\nsystemd.service(5)\nfor details.\nexample 23. table output\n$ systemd-analyze fdstore systemd-journald.service\n           fdname type devno   inode rdevno path             flags\n           stored sock 0:8   4218620 -      socket:[4218620] ro\n           stored sock 0:8   4213198 -      socket:[4213198] ro\n           stored sock 0:8   4213190 -      socket:[4213190] ro\n           ...\n\n       note: the \"devno\" column refers to the major/minor numbers of the\n       device node backing the file system the file descriptor's inode is\n       on. the \"rdevno\" column refers to the major/minor numbers of the\n       device node itself if the file descriptor refers to one. compare\n       with corresponding\n.st_dev\nand\n.st_rdev\nfields in\nstruct stat\n(see\nstat(2)\nfor details). the listed inode numbers in the \"inode\"\n       column are on the file system indicated by \"devno\".\nsystemd-analyze image-policy\npolicy\n...\n       this command analyzes the specified image policy string, as per\nsystemd.image-policy(7)\n. the policy is normalized and simplified.\n       for each currently defined partition identifier (as per the\ndiscoverable partitions specification\n[2]) the effect of the image\n       policy string is shown in tabular form.\nexample 24. example output\n$ systemd-analyze image-policy swap=encrypted:usr=read-only-on+verity:root=encrypted\n           analyzing policy: root=encrypted:usr=verity+read-only-on:swap=encrypted\n                  long form: root=encrypted:usr=verity+read-only-on:swap=encrypted:=unused+absent\n\n           partition       mode        read-only growfs\n           root            encrypted   -         -\n           usr             verity      yes       -\n           home            ignore      -         -\n           srv             ignore      -         -\n           esp             ignore      -         -\n           xbootldr        ignore      -         -\n           swap            encrypted   -         -\n           root-verity     ignore      -         -\n           usr-verity      unprotected yes       -\n           root-verity-sig ignore      -         -\n           usr-verity-sig  ignore      -         -\n           tmp             ignore      -         -\n           var             ignore      -         -\n           default         ignore      -         -\nsystemd-analyze has-tpm2\nreports whether the system is equipped with a usable tpm2 device.\n       if a tpm2 device has been discovered, is supported, and is being\n       used by firmware, by the os kernel drivers and by userspace (i.e.\n       systemd) this prints \"yes\" and exits with exit status zero. if no\n       such device is discovered/supported/used, prints \"no\". otherwise,\n       prints \"partial\". in either of these two cases exits with non-zero\n       exit status. it also shows five lines indicating separately\n       whether firmware, drivers, the system, the kernel and libraries\n       discovered/support/use tpm2. currently, required libraries are\n       libtss2-esys.so.0, libtss2-rc.so.0, and libtss2-mu.so.0. the\n       requirement may be changed in the future release.\n\n       note, this checks for tpm 2.0 devices only, and does not consider\n       tpm 1.2 at all.\n\n       combine with\n--quiet\nto suppress the output.\nexample 25. example output\nyes\n           +firmware\n           +driver\n           +system\n           +subsystem\n           +libraries\n             +libtss2-esys.so.0\n             +libtss2-rc.so.0\n             +libtss2-mu.so.0\n\n       added in version 257.\nsystemd-analyze pcrs [\npcr\n...]\n       this command shows the known tpm2 pcrs along with their\n       identifying names and current values.\nexample 26. example output\n$ systemd-analyze pcrs\n           nr name                sha256\n            0 platform-code       bcd2eb527108bbb1f5528409bcbe310aa9b74f687854cc5857605993f3d9eb11\n            1 platform-config     b60622856eb7ce52637b80f30a520e6e87c347daa679f3335f4f1a600681bb01\n            2 external-code       1471262403e9a62f9c392941300b4807fbdb6f0bfdd50abfab752732087017dd\n            3 external-config     3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            4 boot-loader-code    939f7fa1458e1f7ce968874d908e524fc0debf890383d355e4ce347b7b78a95c\n            5 boot-loader-config  864c61c5ea5ecbdb6951e6cb6d9c1f4b4eac79772f7fe13b8bece569d83d3768\n            6 -                   3d458cfe55cc03ea1f443f1562beec8df51c75e14a9fcf9a7234a13f198e7969\n            7 secure-boot-policy  9c905bd9b9891bfb889b90a54c4b537b889cfa817c4389cc25754823a9443255\n            8 -                   0000000000000000000000000000000000000000000000000000000000000000\n            9 kernel-initrd       9caa29b128113ef42aa53d421f03437be57211e5ebafc0fa8b5d4514ee37ff0c\n           10 ima                 5ea9e3dab53eb6b483b6ec9e3b2c712bea66bca1b155637841216e0094387400\n           11 kernel-boot         0000000000000000000000000000000000000000000000000000000000000000\n           12 kernel-config       627ffa4b405e911902fe1f1a8b0164693b31acab04f805f15bccfe2209c7eace\n           13 sysexts             0000000000000000000000000000000000000000000000000000000000000000\n           14 shim-policy         0000000000000000000000000000000000000000000000000000000000000000\n           15 system-identity     0000000000000000000000000000000000000000000000000000000000000000\n           16 debug               0000000000000000000000000000000000000000000000000000000000000000\n           17 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           18 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           19 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           20 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           21 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           22 -                   ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n           23 application-support 0000000000000000000000000000000000000000000000000000000000000000\nsystemd-analyze srk [>\nfile\n]\n       this command reads the storage root key (srk) from the tpm2\n       device, and writes it in marshalled tpm2b_public format to stdout.\n       the output is non-printable data, so it should be redirected to a\n       file or into a pipe.\nexample 27. save the storage root key to srk.tpm2b_public\nsystemd-analyze srk >srk.tpm2b_public\nsystemd-analyze architectures [\nname\n...]\n       lists all known cpu architectures, and which ones are native. the\n       listed architecture names are those\nconditionarchitecture=\nsupports, see\nsystemd.unit(5)\nfor details. if architecture names\n       are specified only those specified are listed.\nexample 28. table output\n$ systemd-analyze architectures\n           name        support\n           alpha       foreign\n           arc         foreign\n           arc-be      foreign\n           arm         foreign\n           arm64       foreign\n           ...\n           sparc       foreign\n           sparc64     foreign\n           tilegx      foreign\n           x86         secondary\n           x86-64      native\nsystemd-analyze smbios11\nshows a list of smbios type #11 strings passed to the system. also\n       see\nsmbios-type-11(7)\n.\nexample 29. example output\n$ systemd-analyze smbios11\n           io.systemd.stub.kernel-cmdline-extra=console=ttys0\n           io.systemd.credential.binary:ssh.ephemeral-authorized_keys-all=c3nolwvkmju1mtkgqufbqumztnphqzfswkrjmu5urtvbqufbsurgd20xbfp4wlrgcljteg9zqlozotyzce1uyljcadmwm1mxvxhlsum2nmygbgvubmfydeb6zxrhcg==\n           io.systemd.credential:vmm.notify_socket=vsock-stream:2:254570042\n\n           3 smbios type #11 strings passed.\n\n       added in version 257.\nsystemd-analyze chid\nshows a list of computer hardware ids (chids) of the local system.\n       these ids identify the system's computer hardware, based on smbios\n       data. see\nusing computer hardware ids (chids)\n[3] for details about\n       chids.\nexample 30. example output\n$ systemd-analyze chid\n           type input  chid\n              3 mfpsmp 520537c0-3b59-504f-b062-9682ea236b21\n              4 mfps-- edf05dc8-a53d-5b2c-8023-630bca2a2463\n              5 mfp--- ebc6a4d9-ec48-537a-916b-c69fa4fdd814\n              6 m--smp 5ebe4bba-f598-5e90-9ff2-9fd0d3211465\n              7 m--s-- 1a3fb835-b42a-5f9c-a38c-eff5bfd5c41d\n              8 m-p-mp 2a831dce-8163-5bad-8406-435b8c752dd8\n              9 m-p--- 7c21c878-4a75-50f7-9816-21e811588da0\n             10 mf--mp 9a003537-bcc5-500e-b10a-8d8892e4fc64\n             11 mf---- bb9122bb-8a5c-50d2-a742-a85beb719909\n             13 m---mp bfc36935-5032-5987-a0a3-6311f01de33a\n\n           legend: m \u00e2\u0086\u0092 sys_vendor (lenovo) \u00e2\u0094\u0084 f \u00e2\u0086\u0092 product_family (thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 p \u00e2\u0086\u0092 product_name (20xw0055ge)\n                   s \u00e2\u0086\u0092 product_sku (lenovo_mt_20xw_bu_think_fm_thinkpad x1 carbon gen 9) \u00e2\u0094\u0084 m \u00e2\u0086\u0092 board_vendor (lenovo)\n                   p \u00e2\u0086\u0092 board_name (20xw0055ge)\n\n       added in version 258.\nRelevant sections:\n- \n\n---\n\nCommand: pmfind\nDescription: pmfind\nsearches for instances of the specified pcp service being\n       advertised on the network and prints a list of urls corresponding\n       to the services discovered.  it can be used in conjunction with\npmfind_check(1)\nto automate the monitoring of remote pcp collector\n       systems.\nRelevant sections:\n- \n\n---\n\nCommand: ippfind\nDescription: ippfind\nfinds services registered with a dns server or available\n       through local devices.  its primary purpose is to find ipp\n       printers and show their uris, show their current status, or run\n       commands.\nregistration types\nippfind\nsupports the following registration types:\n\n       _http._tcp\n            hypertext transport protocol (http, rfc 2616)\n\n       _https._tcp\n            secure hypertext transport protocol (https, rfc 2818)\n\n       _ipp._tcp\n            internet printing protocol (ipp, rfc 2911)\n\n       _ipps._tcp\n            secure internet printing protocol (ipps, draft)\n\n       _printer._tcp\n            line printer daemon (lpd, rfc 1179)\nexpressions\nippfind\nsupports expressions much like the\nfind(1)\nutility.\n       however, unlike\nfind(1)\n,\nippfind\nuses posix regular expressions\n       instead of shell filename matching patterns.  if\n--exec\n,\n-l\n,\n--ls\n,\n-p\n,\n--print\n,\n--print-name\n,\n-q\n,\n--quiet\n,\n-s\n, or\n-x\nis not\n       specified,\nippfind\nadds\n--print\nto print the service uri of\n       anything it finds.  the following expressions are supported:\n-d\nregex\n--domain\nregex\ntrue if the domain matches the given regular expression.\n--false\nalways false.\n-h\nregex\n--host\nregex\ntrue is the hostname matches the given regular expression.\n-l\n--ls\nlists attributes returned by get-printer-attributes for ipp\n            printers and traditional\nfind\n\"-ls\" output for http urls.\n            the result is true if the uri is accessible, false otherwise.\n--local\ntrue if the service is local to this computer.\n-n\nname\n--literal-name\nname\ntrue if the service instance name matches the given name.\n-n\nregex\n--name\nregex\ntrue if the service instance name matches the given regular\n            expression.\n--path\nregex\ntrue if the uri resource path matches the given regular\n            expression.\n-p\nnumber\n[\n-\nnumber\n]\n--port\nnumber\n[\n-\nnumber\n]\n            true if the port matches the given number or range.\n-p\n--print\nprints the uri if the result of previous expressions is true.\n            the result is always true.\n-q\n--quiet\nquiet mode - just returns the exit codes below.\n-r\n--remote\ntrue if the service is not local to this computer.\n-s\n--print-name\nprints the service instance name if the result of previous\n            expressions is true.  the result is always true.\n--true\nalways true.\n-t\nkey\n--txt\nkey\ntrue if the txt record contains the named key.\n--txt-\nkey regex\ntrue if the txt record contains the named key and matches the\n            given regular expression.\n-u\nregex\n--uri\nregex\ntrue if the uri matches the given regular expression.\n-x\nutility\n[\nargument\n... ]\n;\n--exec\nutility\n[\nargument\n... ]\n;\nexecutes the specified program if the current result is true.\n            \"{foo}\" arguments are replaced with the corresponding value -\n            see substitutions below.\n\n       expressions may also contain modifiers:\n(\nexpression\n)\ngroup the result of expressions.\n!\nexpression\n--not\nexpression\nunary not of the expression.\nexpression expression\nexpression\n--and\nexpression\nlogical and of expressions.\nexpression\n--or\nexpression\nlogical or of expressions.\nsubstitutions\nthe substitutions for \"{foo}\" in\n-e\nand\n--exec\nare:\n{service_domain}\ndomain name, e.g., \"example.com.\", \"local.\", etc.\n{service_hostname}\nfully-qualified domain name, e.g., \"printer.example.com.\",\n            \"printer.local.\", etc.\n{service_name}\nservice instance name, e.g., \"my fine printer\".\n{service_port}\nport number for server, typically 631 for ipp and 80 for\n            http.\n{service_regtype}\ndns-sd registration type, e.g., \"_ipp._tcp\", \"_http._tcp\",\n            etc.\n{service_scheme}\nuri scheme for dns-sd registration type, e.g., \"ipp\", \"http\",\n            etc.\n{}\n{service_uri}\nuri for service, e.g., \"ipp://printer.local./ipp/print\",\n            \"http://printer.local./\", etc.\n{txt_\nkey\n}\nvalue of txt record\nkey\n(lowercase).\nRelevant sections:\n- \n\n---\n\nCommand: nmap\nDescription: nmap (\u00e2\u0080\u009cnetwork mapper\u00e2\u0080\u009d) is an open source tool for network\n       exploration and security auditing. it was designed to rapidly scan\n       large networks, although it works fine against single hosts. nmap\n       uses raw ip packets in novel ways to determine what hosts are\n       available on the network, what services (application name and\n       version) those hosts are offering, what operating systems (and os\n       versions) they are running, what type of packet filters/firewalls\n       are in use, and dozens of other characteristics. while nmap is\n       commonly used for security audits, many systems and network\n       administrators find it useful for routine tasks such as network\n       inventory, managing service upgrade schedules, and monitoring host\n       or service uptime.\n\n       the output from nmap is a list of scanned targets, with\n       supplemental information on each depending on the options used.\n       key among that information is the \u00e2\u0080\u009cinteresting ports table\u00e2\u0080\u009d.  that\n       table lists the port number and protocol, service name, and state.\n       the state is either open, filtered, closed, or unfiltered.  open\n       means that an application on the target machine is listening for\n       connections/packets on that port.  filtered means that a firewall,\n       filter, or other network obstacle is blocking the port so that\n       nmap cannot tell whether it is open or closed.  closed ports have\n       no application listening on them, though they could open up at any\n       time. ports are classified as unfiltered when they are responsive\n       to nmap's probes, but nmap cannot determine whether they are open\n       or closed. nmap reports the state combinations open|filtered and\n       closed|filtered when it cannot determine which of the two states\n       describe a port. the port table may also include software version\n       details when version detection has been requested. when an ip\n       protocol scan is requested (\n-so\n), nmap provides information on\n       supported ip protocols rather than listening ports.\n\n       in addition to the interesting ports table, nmap can provide\n       further information on targets, including reverse dns names,\n       operating system guesses, device types, and mac addresses.\n\n       a typical nmap scan is shown in example 1. the only nmap arguments\n       used in this example are\n-a\n, to enable os and version detection,\n       script scanning, and traceroute;\n-t4\nfor faster execution; and\n       then the hostname.\nexample 1. a representative nmap scan\n#\nnmap -a -t4 scanme.nmap.org\nnmap scan report for scanme.nmap.org (74.207.244.221)\n           host is up (0.029s latency).\n           rdns record for 74.207.244.221: li86-221.members.linode.com\n           not shown: 995 closed ports\n           port     state    service     version\n           22/tcp   open     ssh         openssh 5.3p1 debian 3ubuntu7 (protocol 2.0)\n           | ssh-hostkey: 1024 8d:60:f1:7c:ca:b7:3d:0a:d6:67:54:9d:69:d9:b9:dd (dsa)\n           |_2048 79:f8:09:ac:d4:e2:32:42:10:49:d3:bd:20:82:85:ec (rsa)\n           80/tcp   open     http        apache httpd 2.2.14 ((ubuntu))\n           |_http-title: go ahead and scanme!\n           646/tcp  filtered ldp\n           1720/tcp filtered h.323/q.931\n           9929/tcp open     nping-echo  nping echo\n           device type: general purpose\n           running: linux 2.6.x\n           os cpe: cpe:/o:linux:linux_kernel:2.6.39\n           os details: linux 2.6.39\n           network distance: 11 hops\n           service info: os: linux; cpe: cpe:/o:linux:kernel\n\n           traceroute (using port 53/tcp)\n           hop rtt      address\n           [cut first 10 hops for brevity]\n           11  17.65 ms li86-221.members.linode.com (74.207.244.221)\n\n           nmap done: 1 ip address (1 host up) scanned in 14.40 seconds\n\n       the newest version of nmap can be obtained from\nhttps://nmap.org\n.\n       the newest version of this man page is available at\nhttps://nmap.org/book/man.html\n.  it is also included as a chapter\n       of nmap network scanning: the official nmap project guide to\n       network discovery and security scanning (see\nhttps://nmap.org/book/\n).\nRelevant sections:\n- \n- \n- \n\n---\n\nCommand: nping\nDescription: nping is an open-source tool for network packet generation,\n       response analysis and response time measurement. nping allows\n       users to generate network packets of a wide range of protocols,\n       letting them tune virtually any field of the protocol headers.\n       while nping can be used as a simple ping utility to detect active\n       hosts, it can also be used as a raw packet generator for network\n       stack stress tests, arp poisoning, denial of service attacks,\n       route tracing, and other purposes.\n\n       additionally, nping offers a special mode of operation called the\n       \"echo mode\", that lets users see how the generated probes change\n       in transit, revealing the differences between the transmitted\n       packets and the packets received at the other end. see section\n       \"echo mode\" for details.\n\n       the output from nping is a list of the packets that are being sent\n       and received. the level of detail depends on the options used.\n\n       a typical nping execution is shown in example 1. the only nping\n       arguments used in this example are\n-c\n, to specify the number of\n       times to target each host,\n--tcp\nto specify tcp probe mode,\n-p\n80,433\nto specify the target ports; and then the two target\n       hostnames.\nexample 1. a representative nping execution\n#\nnping -c 1 --tcp -p 80,433 scanme.nmap.org google.com\nstarting nping (\nhttps://nmap.org/nping\n)\n           sent (0.0120s) tcp 96.16.226.135:50091 > 64.13.134.52:80 s ttl=64 id=52072 iplen=40  seq=1077657388 win=1480\n           rcvd (0.1810s) tcp 64.13.134.52:80 > 96.16.226.135:50091 sa ttl=53 id=0 iplen=44  seq=4158134847 win=5840 <mss 1460>\n           sent (1.0140s) tcp 96.16.226.135:50091 > 74.125.45.100:80 s ttl=64 id=13932 iplen=40  seq=1077657388 win=1480\n           rcvd (1.1370s) tcp 74.125.45.100:80 > 96.16.226.135:50091 sa ttl=52 id=52913 iplen=44  seq=2650443864 win=5720 <mss 1430>\n           sent (2.0140s) tcp 96.16.226.135:50091 > 64.13.134.52:433 s ttl=64 id=8373 iplen=40  seq=1077657388 win=1480\n           sent (3.0140s) tcp 96.16.226.135:50091 > 74.125.45.100:433 s ttl=64 id=23624 iplen=40  seq=1077657388 win=1480\n\n           statistics for host scanme.nmap.org (64.13.134.52):\n            |  probes sent: 2 | rcvd: 1 | lost: 1  (50.00%)\n            |_ max rtt: 169.720ms | min rtt: 169.720ms | avg rtt: 169.720ms\n           statistics for host google.com (74.125.45.100):\n            |  probes sent: 2 | rcvd: 1 | lost: 1  (50.00%)\n            |_ max rtt: 122.686ms | min rtt: 122.686ms | avg rtt: 122.686ms\n           raw packets sent: 4 (160b) | rcvd: 2 (92b) | lost: 2 (50.00%)\n           tx time: 3.00296s | tx bytes/s: 53.28 | tx pkts/s: 1.33\n           rx time: 3.00296s | rx bytes/s: 30.64 | rx pkts/s: 0.67\n           nping done: 2 ip addresses pinged in 4.01 seconds\n\n       the newest version of nping can be obtained with nmap at\nhttps://nmap.org\n. the newest version of this man page is available\n       at\nhttps://nmap.org/book/nping-man.html\n.\n\n       -->\n         .sh \"options summary\"\n\n       this options summary is printed when nping is run with no\n       arguments. it helps people remember the most common options, but\n       is no substitute for the in-depth documentation in the rest of\n       this manual. some obscure options aren't even included here.\n\n           nping 0.7.92svn (\nhttps://nmap.org/nping\n)\n           usage: nping [probe mode] [options] {target specification}\n\n           target specification:\n             targets may be specified as hostnames, ip addresses, networks, etc.\n             ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.*.1-24\n           probe modes:\n             --tcp-connect                    : unprivileged tcp connect probe mode.\n             --tcp                            : tcp probe mode.\n             --udp                            : udp probe mode.\n             --icmp                           : icmp probe mode.\n             --arp                            : arp/rarp probe mode.\n             --tr, --traceroute               : traceroute mode (can only be used with\n                                                tcp/udp/icmp modes).\n           tcp connect mode:\n              -p, --dest-port <port spec>     : set destination port(s).\n              -g, --source-port <portnumber>  : try to use a custom source port.\n           tcp probe mode:\n              -g, --source-port <portnumber>  : set source port.\n              -p, --dest-port <port spec>     : set destination port(s).\n              --seq <seqnumber>               : set sequence number.\n              --flags <flag list>             : set tcp flags (ack,psh,rst,syn,fin...)\n              --ack <acknumber>               : set ack number.\n              --win <size>                    : set window size.\n              --badsum                        : use a random invalid checksum.\n           udp probe mode:\n              -g, --source-port <portnumber>  : set source port.\n              -p, --dest-port <port spec>     : set destination port(s).\n              --badsum                        : use a random invalid checksum.\n           icmp probe mode:\n             --icmp-type <type>               : icmp type.\n             --icmp-code <code>               : icmp code.\n             --icmp-id <id>                   : set identifier.\n             --icmp-seq <n>                   : set sequence number.\n             --icmp-redirect-addr <addr>      : set redirect address.\n             --icmp-param-pointer <pnt>       : set parameter problem pointer.\n             --icmp-advert-lifetime <time>    : set router advertisement lifetime.\n             --icmp-advert-entry <ip,pref>    : add router advertisement entry.\n             --icmp-orig-time  <timestamp>    : set originate timestamp.\n             --icmp-recv-time  <timestamp>    : set receive timestamp.\n             --icmp-trans-time <timestamp>    : set transmit timestamp.\n           arp/rarp probe mode:\n             --arp-type <type>                : type: arp, arp-reply, rarp, rarp-reply.\n             --arp-sender-mac <mac>           : set sender mac address.\n             --arp-sender-ip  <addr>          : set sender ip address.\n             --arp-target-mac <mac>           : set target mac address.\n             --arp-target-ip  <addr>          : set target ip address.\n           ipv4 options:\n             -s, --source-ip                  : set source ip address.\n             --dest-ip <addr>                 : set destination ip address (used as an\n                                                alternative to {target specification} ).\n             --tos <tos>                      : set type of service field (8bits).\n             --id  <id>                       : set identification field (16 bits).\n             --df                             : set don't fragment flag.\n             --mf                             : set more fragments flag.\n             --evil                           : set reserved / evil flag.\n             --ttl <hops>                     : set time to live [0-255].\n             --badsum-ip                      : use a random invalid checksum.\n             --ip-options <s|r [route]|l [route]|t|u ...> : set ip options\n             --ip-options <hex string>                    : set ip options\n             --mtu <size>                     : set mtu. packets get fragmented if mtu is\n                                                small enough.\n           ipv6 options:\n             -6, --ipv6                       : use ip version 6.\n             --dest-ip                        : set destination ip address (used as an\n                                                alternative to {target specification}).\n             --hop-limit                      : set hop limit (same as ipv4 ttl).\n             --traffic-class <class> :        : set traffic class.\n             --flow <label>                   : set flow label.\n           ethernet options:\n             --dest-mac <mac>                 : set destination mac address. (disables\n                                                arp resolution)\n             --source-mac <mac>               : set source mac address.\n             --ether-type <type>              : set ethertype value.\n           payload options:\n             --data <hex string>              : include a custom payload.\n             --data-string <text>             : include a custom ascii text.\n             --data-length <len>              : include len random bytes as payload.\n           echo client/server:\n             --echo-client <passphrase>       : run nping in client mode.\n             --echo-server <passphrase>       : run nping in server mode.\n             --echo-port <port>               : use custom <port> to listen or connect.\n             --no-crypto                      : disable encryption and authentication.\n             --once                           : stop the server after one connection.\n             --safe-payloads                  : erase application data in echoed packets.\n           timing and performance:\n             options which take <time> are in seconds, or append 'ms' (milliseconds),\n             's' (seconds), 'm' (minutes), or 'h' (hours) to the value (e.g. 30m, 0.25h).\n             --delay <time>                   : adjust delay between probes.\n             --rate  <rate>                   : send num packets per second.\n           misc:\n             -h, --help                       : display help information.\n             -v, --version                    : display current version number.\n             -c, --count <n>                  : stop after <n> rounds.\n             -e, --interface <name>           : use supplied network interface.\n             -h, --hide-sent                  : do not display sent packets.\n             -n, --no-capture                 : do not try to capture replies.\n             --privileged                     : assume user is fully privileged.\n             --unprivileged                   : assume user lacks raw socket privileges.\n             --send-eth                       : send packets at the raw ethernet layer.\n             --send-ip                        : send packets using raw ip sockets.\n             --bpf-filter <filter spec>       : specify custom bpf filter.\n           output:\n             -v                               : increment verbosity level by one.\n             -v[level]                        : set verbosity level. e.g: -v4\n             -d                               : increment debugging level by one.\n             -d[level]                        : set debugging level. e.g: -d3\n             -q                               : decrease verbosity level by one.\n             -q[n]                            : decrease verbosity level n times\n             --quiet                          : set verbosity and debug level to minimum.\n             --debug                          : set verbosity and debug to the max level.\n           examples:\n             nping scanme.nmap.org\n             nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1\n             nping --icmp --icmp-type time --delay 500ms 192.168.254.254\n             nping --echo-server \"public\" -e wlan0 -vvv\n             nping --echo-client \"public\" echo.nmap.org --tcp -p1-1024 --flags ack\n\n           see the man page for many more options, descriptions, and examples\nRelevant sections:\n- \n- \n- \n- \n- \n\n---\n\n",
  "response": "Here's how to find your IP address from the command line:\n\n### 1. `ip addr`\n\n*   **Explanation:** This command from the `iproute2` suite is the modern, preferred way to find IP addresses on Linux systems. It displays detailed information about network interfaces, including their IP addresses.\n\n*   **Example:**\n\n    ```bash\n    ip addr\n    ```\n    This will list all network interfaces and their associated IP addresses. Look for the `inet` entry within each interface's information.\n\n*   **Targeted Example:** To find the IP address of a specific interface (e.g., `eth0` or `wlan0`):\n\n    ```bash\n    ip addr show eth0\n    ```\n\n    Replace `eth0` with the actual interface name you want to check.\n\n### 2. `hostname -I`\n\n*   **Explanation**: `hostname` is generally used to show or set the system's hostname, but the `-I` option quickly displays all IP addresses assigned to the host.\n*   **Example**:\n\n    ```bash\n    hostname -I\n    ```\n\n    This command returns a space-separated list of IP addresses assigned to the host.\n\n### 3. `ifconfig` (Less Preferred)\n\n*   **Explanation:** `ifconfig` is an older utility (now deprecated on some systems) used to configure network interfaces. While it also displays IP addresses, it's not as versatile or actively maintained as `ip addr`. It may not be installed by default on newer systems.\n\n*   **Example:**\n\n    ```bash\n    ifconfig\n    ```\n\n    This command will list all network interfaces and their configurations, including IP addresses. Look for the `inet addr:` field in the output of each interface.\n\n*   **Targeted Example:** To find the IP address of a specific interface (e.g., `eth0` or `wlan0`):\n\n    ```bash\n    ifconfig eth0\n    ```\n\n    Replace `eth0` with the actual interface name you want to check.\n\n**Recommendation:**\nUse `ip addr` or `hostname -I` as these are the most modern and reliable methods. `hostname -I` is the shortest and gives the essential info. If you need more detailed interface information, `ip addr` is your best bet.\n",
  "analysis": {
    "query_analysis": {
      "intent": "To find the IP address of a system or network interface.",
      "keywords": [
        "IP address",
        "find",
        "display",
        "show",
        "network interface",
        "system"
      ],
      "reformulated_query": "How can I find or display the IP address of my system or a specific network interface using command-line tools in a Unix-like environment?",
      "original_query": "how to find the ip",
      "optimized_query": "how to uncovering the ip",
      "optimization_metrics": {
        "precision": 1.0,
        "recall": 0,
        "f1_score": 0,
        "retrieval_time": 0.01950979232788086,
        "command_count": 5,
        "diverse_categories": 0,
        "query_specificity": 0.55,
        "overall_score": 0.619024510383606
      }
    },
    "command_relevance": [
      {
        "command": "systemd-analyze",
        "relevance_score": 0.6333333333333333
      },
      {
        "command": "pmfind",
        "relevance_score": 0.5666666666666667
      },
      {
        "command": "ippfind",
        "relevance_score": 0.5666666666666667
      },
      {
        "command": "nmap",
        "relevance_score": 0.33333333333333337
      },
      {
        "command": "nping",
        "relevance_score": 0.33333333333333337
      }
    ]
  },
  "command_chains": {
    "next_commands": [
      "aria_chk",
      "dash",
      "mariadb-test",
      "as",
      "cvtsudoers"
    ],
    "command_chains": [
      ""
    ]
  }
}